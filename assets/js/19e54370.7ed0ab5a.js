"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["54714"],{34277(e,t,n){n.r(t),n.d(t,{metadata:()=>i,default:()=>l,frontMatter:()=>r,contentTitle:()=>a,toc:()=>u,assets:()=>d});var i=JSON.parse('{"id":"tutorial/organizing-mutations-queries-and-subscriptions","title":"Organizing Mutations, Queries, and Subscriptions","description":"Relay Operations (Mutations, Queries, and Subscriptions) have strict naming requirements. The operation name must begin with the module name, and end with the GraphQL operation type. The name also must be globally unique.","source":"@site/versioned_docs/version-v18.0.0/tutorial/organizing-mutations-queries-and-subscriptions.md","sourceDirName":"tutorial","slug":"/tutorial/organizing-mutations-queries-and-subscriptions","permalink":"/docs/v18.0.0/tutorial/organizing-mutations-queries-and-subscriptions","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v18.0.0/tutorial/organizing-mutations-queries-and-subscriptions.md","tags":[],"version":"v18.0.0","frontMatter":{},"sidebar":"docs","previous":{"title":"Mutations & Updates","permalink":"/docs/v18.0.0/tutorial/mutations-updates"},"next":{"title":"Advanced Pagination","permalink":"/docs/v18.0.0/guided-tour/list-data/advanced-pagination/"}}'),s=n(74848),o=n(28453);let r={},a="Organizing Mutations, Queries, and Subscriptions",d={},u=[{value:"Recommended Structure For Mutations and Subscriptions",id:"recommended-structure-for-mutations-and-subscriptions",level:3},{value:"Recommended Structure for Queries",id:"recommended-structure-for-queries",level:3}];function c(e){let t={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"organizing-mutations-queries-and-subscriptions",children:"Organizing Mutations, Queries, and Subscriptions"})}),"\n",(0,s.jsx)(t.p,{children:"Relay Operations (Mutations, Queries, and Subscriptions) have strict naming requirements. The operation name must begin with the module name, and end with the GraphQL operation type. The name also must be globally unique."}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"Side note: This naming scheme originates from trying to enforce the uniqueness constraint. At Meta, Haste (a dependency management system for static resources) enforces that all module names are unique to derive sensible globally unique Relay names. Coupling the module name and Relay name also makes it easier to locate a fragment/query/mutation if you know that name. This makes sense within Meta, and may be less sensible in an OSS setting."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"For example:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["A Mutation in the file ",(0,s.jsx)(t.code,{children:"MyComponent.js"})," must be named with the scheme ",(0,s.jsx)(t.code,{children:"MyComponent[MyDescriptiveNameHere]Mutation"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["A Query in the file ",(0,s.jsx)(t.code,{children:"MyComponent.react.js"})," must be named with the scheme ",(0,s.jsx)(t.code,{children:"MyComponent*Query"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["A NewsFeed component may have mutations/queries that shouldn't logically start with ",(0,s.jsx)(t.code,{children:"NewsFeed"}),", but Relay requires this ",(0,s.jsx)(t.em,{children:"if they are defined in that file"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"recommended-structure-for-mutations-and-subscriptions",children:"Recommended Structure For Mutations and Subscriptions"}),"\n",(0,s.jsxs)(t.p,{children:["Put Mutations in their own hook module so the name is closer to ",(0,s.jsx)(t.em,{children:"what the mutation does"})," rather than ",(0,s.jsx)(t.em,{children:"which component invokes it"}),". If the module name is correctly descriptive, it is fine to declare it in the same file."]}),"\n",(0,s.jsxs)(t.p,{children:["If you are adding a Mutation for ",(0,s.jsx)(t.code,{children:"Post"}),", like adding a comment to a post, you may create a new file titled ",(0,s.jsx)(t.code,{children:"useAddPostComment.js"}),". Your mutation (in this file) will then be named ",(0,s.jsx)(t.code,{children:"useAddPostCommentMutation"}),", which is a perfectly descriptive name."]}),"\n",(0,s.jsxs)(t.p,{children:["You may consider putting all of these hooks in a dedicated ",(0,s.jsx)(t.code,{children:"hooks"})," directory."]}),"\n",(0,s.jsx)(t.h3,{id:"recommended-structure-for-queries",children:"Recommended Structure for Queries"}),"\n",(0,s.jsx)(t.p,{children:"Root components should have a single query that is tightly coupled to a component, since it describes that component's data dependencies. Queries and fragments should co-locate with their data-use code."})]})}function l(e={}){let{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453(e,t,n){n.d(t,{R:()=>r,x:()=>a});var i=n(96540);let s={},o=i.createContext(s);function r(e){let t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);