"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["98441"],{71928(e,t,n){n.r(t),n.d(t,{metadata:()=>r,default:()=>p,frontMatter:()=>s,contentTitle:()=>l,toc:()=>c,assets:()=>a});var r=JSON.parse('{"id":"api-reference/types/CacheConfig","title":"CacheConfig","description":"Type CacheConfig","source":"@site/versioned_docs/version-v16.0.0/api-reference/types/CacheConfig.md","sourceDirName":"api-reference/types","slug":"/api-reference/types/CacheConfig","permalink":"/docs/v16.0.0/api-reference/types/CacheConfig","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v16.0.0/api-reference/types/CacheConfig.md","tags":[],"version":"v16.0.0","frontMatter":{}}'),i=n(74848),o=n(28453);let s={},l,a={},c=[{value:"Type <code>CacheConfig</code>",id:"type-cacheconfig",level:4}];function d(e){let t={code:"code",em:"em",h4:"h4",li:"li",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.h4,{id:"type-cacheconfig",children:["Type ",(0,i.jsx)(t.code,{children:"CacheConfig"})]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["An object with the following fields:","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"force"}),": ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.em,{children:"[Optional]"})})," A boolean. If true, causes a query to be issued unconditionally, regardless of the state of any configured response cache."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"poll"}),": ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.em,{children:"[Optional]"})})," A number. Causes a query to live-update by polling at the specified interval, in milliseconds. (This value will be passed to ",(0,i.jsx)(t.code,{children:"setTimeout"}),")."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"liveConfigId"}),": ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.em,{children:"[Optional]"})})," A string. Causes a query to live-update by calling GraphQLLiveQuery; it represents a configuration of gateway when doing live query."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"metadata"}),": ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.em,{children:"[Optional]"})})," An object. User-supplied metadata."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"transactionId"}),": ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.em,{children:"[Optional]"})})," A string. A user-supplied value, intended for use as a unique id for a given instance of executing an operation."]}),"\n"]}),"\n"]}),"\n"]})]})}function p(e={}){let{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},86775(e,t,n){n.r(t),n.d(t,{metadata:()=>r,default:()=>f,frontMatter:()=>c,contentTitle:()=>d,toc:()=>h,assets:()=>p});var r=JSON.parse('{"id":"api-reference/types/MutationConfig","title":"MutationConfig","description":"Type MutationConfig","source":"@site/versioned_docs/version-v16.0.0/api-reference/types/MutationConfig.md","sourceDirName":"api-reference/types","slug":"/api-reference/types/MutationConfig","permalink":"/docs/v16.0.0/api-reference/types/MutationConfig","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v16.0.0/api-reference/types/MutationConfig.md","tags":[],"version":"v16.0.0","frontMatter":{}}'),i=n(74848),o=n(28453),s=n(71928),l=n(59834),a=n(25371);let c={},d,p={},h=[{value:"Type <code>MutationConfig&lt;TMutationConfig: MutationParameters&gt;</code>",id:"type-mutationconfigtmutationconfig-mutationparameters",level:4},...s.toc,...l.toc,...a.toc,{value:"Type <code>MutationParameters</code>",id:"type-mutationparameters",level:4}];function u(e){let t={a:"a",code:"code",em:"em",h4:"h4",li:"li",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.h4,{id:"type-mutationconfigtmutationconfig-mutationparameters",children:["Type ",(0,i.jsx)(t.code,{children:"MutationConfig<TMutationConfig: MutationParameters>"})]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["An object with the following fields:","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"cacheConfig"}),": ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.em,{children:"[Optional]"})})," ",(0,i.jsx)(t.a,{href:"#type-cacheconfig",children:(0,i.jsx)(t.code,{children:"CacheConfig"})})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"mutation"}),": ",(0,i.jsx)(t.code,{children:"GraphQLTaggedNode"}),". A mutation specified using a GraphQL literal"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"onError"}),": ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.em,{children:"[Optional]"})})," ",(0,i.jsx)(t.code,{children:"(Error) => void"}),". An optional callback executed if the mutation results in an error."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"onCompleted"}),": ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.em,{children:"[Optional]"})})," ",(0,i.jsx)(t.code,{children:"($ElementType<TMutationConfig, 'response'>) => void"}),". An optional callback that is executed when the mutation completes.","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The value passed to ",(0,i.jsx)(t.code,{children:"onCompleted"})," is the the mutation fragment, as read out from the store, ",(0,i.jsx)(t.strong,{children:"after"})," updaters and declarative mutation directives are applied. This means that data from within unmasked fragments will not be read, and records that were deleted (e.g. by ",(0,i.jsx)(t.code,{children:"@deleteRecord"}),") may also be null."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"onUnsubscribe"}),": ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.em,{children:"[Optional]"})})," ",(0,i.jsx)(t.code,{children:"() => void"}),". An optional callback that is executed when the mutation is unsubscribed, which occurs when the returned ",(0,i.jsx)(t.code,{children:"Disposable"})," is disposed."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"optimisticResponse"}),": ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.em,{children:"[Optional]"})})," An object whose type matches the raw response type of the mutation. Make sure you decorate your mutation with ",(0,i.jsx)(t.code,{children:"@raw_response_type"})," if you are using this field."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"optimisticUpdater"}),": ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.em,{children:"[Optional]"})})," ",(0,i.jsx)(t.a,{href:"#type-selectorstoreupdater",children:(0,i.jsx)(t.code,{children:"SelectorStoreUpdater"})}),". A callback that is executed when ",(0,i.jsx)(t.code,{children:"commitMutation"})," is called, after the ",(0,i.jsx)(t.code,{children:"optimisticResponse"})," has been normalized into the store."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"updater"}),": ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.em,{children:"[Optional]"})})," ",(0,i.jsx)(t.a,{href:"#type-selectorstoreupdater",children:(0,i.jsx)(t.code,{children:"SelectorStoreUpdater"})}),". A callback that is executed when a payload is received, after the payload has been written into the store."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"uploadables"}),": ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.em,{children:"[Optional]"})})," ",(0,i.jsx)(t.a,{href:"#type-uploadablemap",children:(0,i.jsx)(t.code,{children:"UploadableMap"})}),". An optional uploadable map."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"variables"}),": ",(0,i.jsx)(t.code,{children:"$ElementType<TMutationConfig, 'variables'>"}),". The variables to pass to the mutation."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.default,{}),"\n",(0,i.jsx)(l.default,{}),"\n",(0,i.jsx)(a.default,{}),"\n",(0,i.jsxs)(t.h4,{id:"type-mutationparameters",children:["Type ",(0,i.jsx)(t.code,{children:"MutationParameters"})]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["An object with the following fields:","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"response"}),": An object"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"variables"}),": An object"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"rawResponse"}),": An optional object"]}),"\n"]}),"\n"]}),"\n"]})]})}function f(e={}){let{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},59834(e,t,n){n.r(t),n.d(t,{metadata:()=>r,default:()=>h,frontMatter:()=>l,contentTitle:()=>a,toc:()=>d,assets:()=>c});var r=JSON.parse('{"id":"api-reference/types/SelectorStoreUpdater","title":"SelectorStoreUpdater","description":"Type SelectorStoreUpdater","source":"@site/versioned_docs/version-v16.0.0/api-reference/types/SelectorStoreUpdater.md","sourceDirName":"api-reference/types","slug":"/api-reference/types/SelectorStoreUpdater","permalink":"/docs/v16.0.0/api-reference/types/SelectorStoreUpdater","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v16.0.0/api-reference/types/SelectorStoreUpdater.md","tags":[],"version":"v16.0.0","frontMatter":{}}'),i=n(74848),o=n(28453),s=n(66497);let l={},a,c={},d=[{value:"Type <code>SelectorStoreUpdater</code>",id:"type-selectorstoreupdater",level:4}];function p(e){let t={code:"code",em:"em",h4:"h4",li:"li",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.h4,{id:"type-selectorstoreupdater",children:["Type ",(0,i.jsx)(t.code,{children:"SelectorStoreUpdater"})]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["A function with signature ",(0,i.jsx)(t.code,{children:"(store: RecordSourceSelectorProxy, data) => void"})]}),"\n",(0,i.jsxs)(t.li,{children:["This interface allows you to ",(0,i.jsx)(t.em,{children:"imperatively"})," write and read data directly to and from the Relay store. This means that you have full control over how to update the store in response to the subscription payload: you can ",(0,i.jsx)(t.em,{children:"create entirely new records"}),", or ",(0,i.jsx)(t.em,{children:"update or delete existing ones"}),". The full API for reading and writing to the Relay store is available ",(0,i.jsx)("a",{href:(0,s.default)("docs/api-reference/store/#recordsourceselectorproxy"),children:"here"}),"."]}),"\n"]})]})}function h(e={}){let{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},25371(e,t,n){n.r(t),n.d(t,{metadata:()=>r,default:()=>p,frontMatter:()=>s,contentTitle:()=>l,toc:()=>c,assets:()=>a});var r=JSON.parse('{"id":"api-reference/types/UploadableMap","title":"UploadableMap","description":"Type UploadableMap","source":"@site/versioned_docs/version-v16.0.0/api-reference/types/UploadableMap.md","sourceDirName":"api-reference/types","slug":"/api-reference/types/UploadableMap","permalink":"/docs/v16.0.0/api-reference/types/UploadableMap","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v16.0.0/api-reference/types/UploadableMap.md","tags":[],"version":"v16.0.0","frontMatter":{}}'),i=n(74848),o=n(28453);let s={},l,a={},c=[{value:"Type <code>UploadableMap</code>",id:"type-uploadablemap",level:4}];function d(e){let t={a:"a",code:"code",h4:"h4",li:"li",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.h4,{id:"type-uploadablemap",children:["Type ",(0,i.jsx)(t.code,{children:"UploadableMap"})]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["An object whose values are ",(0,i.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/File",children:(0,i.jsx)(t.code,{children:"File"})})," or ",(0,i.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Blob",children:(0,i.jsx)(t.code,{children:"Blob"})}),"."]}),"\n"]})]})}function p(e={}){let{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453(e,t,n){n.d(t,{R:()=>s,x:()=>l});var r=n(96540);let i={},o=r.createContext(i);function s(e){let t=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);