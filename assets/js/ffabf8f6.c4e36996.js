"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["42913"],{99107(e,t,r){r.r(t),r.d(t,{metadata:()=>n,default:()=>p,frontMatter:()=>o,contentTitle:()=>i,toc:()=>d,assets:()=>l});var n=JSON.parse('{"id":"guides/relay-resolvers/return-types","title":"Return Types","description":"Showing the different types of return values for Relay Resolvers","source":"@site/docs/guides/relay-resolvers/return-types.mdx","sourceDirName":"guides/relay-resolvers","slug":"/guides/relay-resolvers/return-types/","permalink":"/docs/next/guides/relay-resolvers/return-types/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/docs/guides/relay-resolvers/return-types.mdx","tags":[],"version":"current","frontMatter":{"id":"return-types","title":"Return Types","slug":"/guides/relay-resolvers/return-types/","description":"Showing the different types of return values for Relay Resolvers","keywords":["resolvers","derived","selectors","reactive"]},"sidebar":"docs","previous":{"title":"Defining Fields","permalink":"/docs/next/guides/relay-resolvers/defining-fields/"},"next":{"title":"Field Arguments","permalink":"/docs/next/guides/relay-resolvers/field-arguments/"}}'),s=r(74848),a=r(28453);let o={id:"return-types",title:"Return Types",slug:"/guides/relay-resolvers/return-types/",description:"Showing the different types of return values for Relay Resolvers",keywords:["resolvers","derived","selectors","reactive"]},i,l={},d=[{value:"Scalar Types",id:"scalar-types",level:2},{value:"List Types",id:"list-types",level:2},{value:"Client-defined GraphQL Types",id:"client-defined-graphql-types",level:2},{value:"Server Types",id:"server-types",level:2},{value:"Abstract Types",id:"abstract-types",level:2},{value:"JavaScript Values",id:"javascript-values",level:2}];function c(e){let t={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Relay Resolvers support a number of different return types, each of which has different semantics. This page will walk through the different types of supported return values and how they are used."}),"\n",(0,s.jsx)(t.h2,{id:"scalar-types",children:"Scalar Types"}),"\n",(0,s.jsx)(t.p,{children:"The simplest type for a resolver to return is a built-in GraphQL scalar value. Scalar values are values that can be represented as a primitive value in GraphQL, such as a string, number, or boolean. To return a scalar simply define your resolver as returning the scalar type and then return the corresponding JavaScript value from your resolver function."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'/**\n * @RelayResolver Post.isValid: Boolean\n */\nexport function isValid(post: PostModel): boolean {\n  return post.content !== "" && post.author != null;\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"list-types",children:"List Types"}),"\n",(0,s.jsx)(t.p,{children:"Resolvers may also return a list of values. To do so, define your resolver as returning a list of the corresponding type and return an array from your resolver function."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"/**\n * @RelayResolver User.favoriteColors: [String]\n */\nexport function favoriteColors(user: UserModel): string[] {\n  return user.favoriteColors;\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"This pattern can be used for the other types, with the exception of server types, which don't yet support lists."}),"\n",(0,s.jsx)(t.h2,{id:"client-defined-graphql-types",children:"Client-defined GraphQL Types"}),"\n",(0,s.jsxs)(t.p,{children:['Resolvers can also model edges to other GraphQL types in your Resolver schema. If the type was defined as a "strong" type, the resolver function must return an object ',(0,s.jsx)(t.code,{children:"{ id: DataID }"})," where ",(0,s.jsx)(t.code,{children:"DataID"})," is the ID of the object. Relay will take care of invoking the type's model resolver function."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"import {DataID} from 'relay-runtime';\n/**\n * @RelayResolver Post.author: User\n */\nexport function author(post: PostModel): { id: DataID } {\n  return { id: post.authorId };\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["If the type was defined as ",(0,s.jsx)(t.code,{children:"@weak"}),", the resolver function must return an object matching the type's model type."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"/**\n * @RelayResolver User.profilePicture: ProfilePicture\n */\nexport function profilePicture(user: UserModel): ProfilePicture {\n  return {\n    url: user.profilePicture.url,\n    width: user.profilePicture.width,\n    height: user.profilePicture.width,\n  }\n}\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:"Relay will emit type assertions in its generated code to help catch errors where a resolver implementation does not match whats declared in its docblock."})}),"\n",(0,s.jsx)(t.h2,{id:"server-types",children:"Server Types"}),"\n",(0,s.jsxs)(t.p,{children:["Relay Resolvers also support modeling edges to types defined on your server schema that implement the ",(0,s.jsxs)(t.a,{href:"https://graphql.org/learn/global-object-identification/#node-root-field",children:[(0,s.jsx)(t.code,{children:"Node"})," specification"]}),". Since objects which implement Node each have a globally unique ID, resolvers modeling edges to these server types simply need to return that unique ID."]}),"\n",(0,s.jsx)(t.p,{children:"At compile-time Relay derives a GraphQL query for each selections on this field and will lazily fetch that data on render."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"import {DataID} from 'relay-runtime';\n/**\n * @RelayResolver Post.author: User\n */\nexport function author(post: PostModel): DataID {\n  return post.authorId;\n}\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsx)(t.p,{children:"Edges to server types that are only known the client force Relay to fetch data lazily which will force an additional cascading network roundtrip. This is generally not optimal and should be avoided where possible."})}),"\n",(0,s.jsxs)(t.p,{children:["To highlight this point, at compile time, Relay requires that selection that reads client to server edge field annotate the field with the ",(0,s.jsx)(t.code,{children:"@waterfall"})," directive. This is intended to remind the author and reviewer that a tradeoff is being made here and to carefully consider the implications."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"function Post() {\n  const data = useLazyLoadQuery(graphql`\n    query PostQuery {\n      post {\n        author @waterfall {\n          name\n        }\n      }\n    }`, {});\n  return <p>{data.post.author.name}</p>;\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"abstract-types",children:"Abstract Types"}),"\n",(0,s.jsxs)(t.p,{children:['Resolvers may return some permutations of "abstract" types (GraphQL unions and interfaces). To use this feature simply use the abstract type\'s name in the docblock field description and include the typename in the object returned from your resolver. For "strong" types, that will look like: ',(0,s.jsx)(t.code,{children:"{id: DataID, __typename: string}"}),'. For "weak" types that will look like: ',(0,s.jsx)(t.code,{children:"{__relay_model_instance: T, __typename: string}"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'import {DataID} from \'relay-runtime\';\n\ntype AnimalTypenames = "Cat" | "Dog";\n/**\n * @RelayResolver User.pet: Animal\n */\nexport function pet(user: User): {id: DataID, __typename: AnimalTypenames } {\n  return {id: "5", __typename: "Dog" }\n}\n'})}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:"Relay will generate type assertions to ensure your resolver function returns the expected type. However, not all combinations are supported. For example, Relay does not yet support the following permutations of abstract types: Unions including weak types, abstract types which mix strong add weak types, and abstract types which include server-backed types."})}),"\n",(0,s.jsxs)(t.p,{children:["While abstract types themselves cannot be defined using Resolver syntax today, you may define interfaces and unions, as well as their members, using ",(0,s.jsx)(t.a,{href:"/docs/next/guides/client-schema-extensions/",children:"Client Schema Extensions"}),". For example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-graphql",metastring:'title="client-schema.graphql"',children:"interface Animal {\n legs: Int\n}\n\nextend type Cat implements Animal {\n  __do_not_use: String # Placeholder because GraphQL does not allow empty field sets.\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"javascript-values",children:"JavaScript Values"}),"\n",(0,s.jsxs)(t.p,{children:["There are rare cases where you want to return an arbitrary JavaScript value from your Resolver schema, one which cannot not have a corresponding GraphQL type. As an escape hatch Relay supports a custom return type ",(0,s.jsx)(t.code,{children:"RelayResolverValue"})," that allows you to return any JavaScript value from your resolver. ",(0,s.jsx)(t.strong,{children:"JavaScript values returned from resolvers should be immutable."})]}),"\n",(0,s.jsx)(t.p,{children:"Consumers of this field will see a TypeScript/Flow type that is derived from your resolver function's return type."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"/**\n * @RelayResolver Post.publishDate: RelayResolverValue\n */\nexport function metadata(post: PostModel): Date {\n  return post.publishDate;\n}\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsxs)(t.p,{children:["Use of ",(0,s.jsx)(t.code,{children:"RelayResolverValue"}),' should be considered an "escape hatch" and may be deprecated in future versions of Relay. In most cases a preferable pattern is to define a custom scalar in your ',(0,s.jsx)(t.a,{href:"/docs/next/guides/client-schema-extensions/",children:"client schema extensions"})," and add a type definition for that custom scalar in your Relay config."]})})]})}function p(e={}){let{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453(e,t,r){r.d(t,{R:()=>o,x:()=>i});var n=r(96540);let s={},a=n.createContext(s);function o(e){let t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);