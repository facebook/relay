"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3417],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>l,MDXProvider:()=>p,mdx:()=>g,useMDXComponents:()=>c,withMDXComponents:()=>s});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},o.apply(this,arguments)}function m(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function d(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?m(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):m(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),s=function(e){return function(n){var t=c(n.components);return a.createElement(e,o({},n,{components:t}))}},c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):d(d({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,m=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),s=c(t),p=r,h=s["".concat(m,".").concat(p)]||s[p]||u[p]||o;return t?a.createElement(h,d(d({ref:n},l),{},{components:t})):a.createElement(h,d({ref:n},l))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,m=new Array(o);m[0]=h;var d={};for(var i in n)hasOwnProperty.call(n,i)&&(d[i]=n[i]);d.originalType=e,d.mdxType="string"==typeof e?e:r,m[1]=d;for(var l=2;l<o;l++)m[l]=t[l];return a.createElement.apply(null,m)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},68629:(e,n,t)=>{t.d(n,{Z:()=>u});var a=t(39960),r=t(86341),o=t(67294);function m(){var e=window.encodeURI(JSON.stringify({title:"Feedback about "+window.location.pathname,description:"**!!! Required !!!**\n\nPlease modify the task description to let us know how the docs can be improved.\n\n**Please do not ask support questions via this form! Instead, ask in fburl.com/relay_support**",tag_ids:{add:[0xac96423e5b680,0x64079768ac750]}}));window.open("https://www.internalfb.com/tasks/?n="+e)}function d(e){var n=e.children;return o.createElement("div",{className:"docsRating",id:"docsRating"},o.createElement("hr",null),n)}var i=function(){var e=o.useState(!1),n=e[0],t=e[1],a=function(e){t(!0),function(e){window.ga&&window.ga("send",{hitType:"event",eventCategory:"button",eventAction:"feedback",eventValue:e})}(e)};return n?"Thank you for letting us know!":o.createElement(o.Fragment,null,"Is this page useful?",o.createElement("svg",{className:"i_thumbsup",alt:"Like",id:"docsRating-like",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 81.13 89.76",onClick:function(){return a(1)}},o.createElement("path",{d:"M22.9 6a18.57 18.57 0 002.67 8.4 25.72 25.72 0 008.65 7.66c3.86 2 8.67 7.13 13.51 11 3.86 3.11 8.57 7.11 11.54 8.45s13.59.26 14.64 1.17c1.88 1.63 1.55 9-.11 15.25-1.61 5.86-5.96 10.55-6.48 16.86-.4 4.83-2.7 4.88-10.93 4.88h-1.35c-3.82 0-8.24 2.93-12.92 3.62a68 68 0 01-9.73.5c-3.57 0-7.86-.08-13.25-.08-3.56 0-4.71-1.83-4.71-4.48h8.42a3.51 3.51 0 000-7H12.28a2.89 2.89 0 01-2.88-2.88 1.91 1.91 0 01.77-1.78h16.46a3.51 3.51 0 000-7H12.29c-3.21 0-4.84-1.83-4.84-4a6.41 6.41 0 011.17-3.78h19.06a3.5 3.5 0 100-7H9.75A3.51 3.51 0 016 42.27a3.45 3.45 0 013.75-3.48h13.11c5.61 0 7.71-3 5.71-5.52-4.43-4.74-10.84-12.62-11-18.71-.15-6.51 2.6-7.83 5.36-8.56m0-6a6.18 6.18 0 00-1.53.2c-6.69 1.77-10 6.65-9.82 14.5.08 5.09 2.99 11.18 8.52 18.09H9.74a9.52 9.52 0 00-6.23 16.9 12.52 12.52 0 00-2.07 6.84 9.64 9.64 0 003.65 7.7 7.85 7.85 0 00-1.7 5.13 8.9 8.9 0 005.3 8.13 6 6 0 00-.26 1.76c0 6.37 4.2 10.48 10.71 10.48h13.25a73.75 73.75 0 0010.6-.56 35.89 35.89 0 007.58-2.18 17.83 17.83 0 014.48-1.34h1.35c4.69 0 7.79 0 10.5-1 3.85-1.44 6-4.59 6.41-9.38.2-2.46 1.42-4.85 2.84-7.62a41.3 41.3 0 003.42-8.13 48 48 0 001.59-10.79c.1-5.13-1-8.48-3.35-10.55-2.16-1.87-4.64-1.87-9.6-1.88a46.86 46.86 0 01-6.64-.29c-1.92-.94-5.72-4-8.51-6.3l-1.58-1.28c-1.6-1.3-3.27-2.79-4.87-4.23-3.33-3-6.47-5.79-9.61-7.45a20.2 20.2 0 01-6.43-5.53 12.44 12.44 0 01-1.72-5.36 6 6 0 00-6-5.86z"})),o.createElement("svg",{className:"i_thumbsdown",alt:"Dislike",id:"docsRating-dislike",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 81.13 89.76",onClick:function(){return a(0)}},o.createElement("path",{d:"M22.9 6a18.57 18.57 0 002.67 8.4 25.72 25.72 0 008.65 7.66c3.86 2 8.67 7.13 13.51 11 3.86 3.11 8.57 7.11 11.54 8.45s13.59.26 14.64 1.17c1.88 1.63 1.55 9-.11 15.25-1.61 5.86-5.96 10.55-6.48 16.86-.4 4.83-2.7 4.88-10.93 4.88h-1.35c-3.82 0-8.24 2.93-12.92 3.62a68 68 0 01-9.73.5c-3.57 0-7.86-.08-13.25-.08-3.56 0-4.71-1.83-4.71-4.48h8.42a3.51 3.51 0 000-7H12.28a2.89 2.89 0 01-2.88-2.88 1.91 1.91 0 01.77-1.78h16.46a3.51 3.51 0 000-7H12.29c-3.21 0-4.84-1.83-4.84-4a6.41 6.41 0 011.17-3.78h19.06a3.5 3.5 0 100-7H9.75A3.51 3.51 0 016 42.27a3.45 3.45 0 013.75-3.48h13.11c5.61 0 7.71-3 5.71-5.52-4.43-4.74-10.84-12.62-11-18.71-.15-6.51 2.6-7.83 5.36-8.56m0-6a6.18 6.18 0 00-1.53.2c-6.69 1.77-10 6.65-9.82 14.5.08 5.09 2.99 11.18 8.52 18.09H9.74a9.52 9.52 0 00-6.23 16.9 12.52 12.52 0 00-2.07 6.84 9.64 9.64 0 003.65 7.7 7.85 7.85 0 00-1.7 5.13 8.9 8.9 0 005.3 8.13 6 6 0 00-.26 1.76c0 6.37 4.2 10.48 10.71 10.48h13.25a73.75 73.75 0 0010.6-.56 35.89 35.89 0 007.58-2.18 17.83 17.83 0 014.48-1.34h1.35c4.69 0 7.79 0 10.5-1 3.85-1.44 6-4.59 6.41-9.38.2-2.46 1.42-4.85 2.84-7.62a41.3 41.3 0 003.42-8.13 48 48 0 001.59-10.79c.1-5.13-1-8.48-3.35-10.55-2.16-1.87-4.64-1.87-9.6-1.88a46.86 46.86 0 01-6.64-.29c-1.92-.94-5.72-4-8.51-6.3l-1.58-1.28c-1.6-1.3-3.27-2.79-4.87-4.23-3.33-3-6.47-5.79-9.61-7.45a20.2 20.2 0 01-6.43-5.53 12.44 12.44 0 01-1.72-5.36 6 6 0 00-6-5.86z"})))},l=function(){return o.createElement("p",null,"Let us know how these docs can be improved by",o.createElement("a",{className:"button",role:"button",tabIndex:0,onClick:m},"Filing a task"))},s=function(){return o.createElement("p",null,"Help us make the site even better by"," ",o.createElement(a.default,{to:"https://www.surveymonkey.com/r/FYC9TCJ"},"answering a few quick questions"),".")},c=function(){return o.createElement(d,null,o.createElement(l,null),o.createElement(i,null),o.createElement(s,null))},p=function(){return o.createElement(d,null,o.createElement(i,null),o.createElement(s,null))};const u=function(){return(0,r.fbContent)({internal:o.createElement(c,null),external:o.createElement(p,null)})}},37519:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>y,frontMatter:()=>s,metadata:()=>p,toc:()=>h});var a,r=t(83117),o=t(80102),m=(t(67294),t(3905)),d=t(68629),i=t(86341),l=["components"],s={id:"server-3d",title:"Server 3D",slug:"/guides/data-driven-dependencies/server-3d/",description:"Server side data driven dependencies (3D)",keywords:["3D","Server 3D","data driven dependencies","module","match","MatchContainer"]},c=void 0,p={unversionedId:"guides/data-driven-dependencies/server-3d",id:"guides/data-driven-dependencies/server-3d",title:"Server 3D",description:"Server side data driven dependencies (3D)",source:"@site/docs/guides/data-driven-dependencies/server-3d.md",sourceDirName:"guides/data-driven-dependencies",slug:"/guides/data-driven-dependencies/server-3d/",permalink:"/docs/next/guides/data-driven-dependencies/server-3d/",draft:!1,editUrl:"https://github.com/facebook/relay/tree/main/website/docs/guides/data-driven-dependencies/server-3d.md",tags:[],version:"current",frontMatter:{id:"server-3d",title:"Server 3D",slug:"/guides/data-driven-dependencies/server-3d/",description:"Server side data driven dependencies (3D)",keywords:["3D","Server 3D","data driven dependencies","module","match","MatchContainer"]},sidebar:"docs",previous:{title:"Introduction",permalink:"/docs/next/guides/data-driven-dependencies/introduction/"},next:{title:"Client 3D",permalink:"/docs/next/guides/data-driven-dependencies/client-3d/"}},u={},h=[{value:"Simple 3D with @module",id:"simple-3d-with-module",level:2},{value:"@module Usage Guide",id:"module-usage-guide",level:3},{value:"Server Changes",id:"server-changes",level:4},{value:"Client Changes",id:"client-changes",level:4},{value:"Advanced 3D with @match",id:"advanced-3d-with-match",level:2},{value:"@match Design Principles",id:"match-design-principles",level:3},{value:"@match Usage Guide",id:"match-usage-guide",level:3},{value:"Server Changes",id:"server-changes-1",level:4},{value:"Choose Render Strategy API",id:"choose-render-strategy-api",level:4},{value:"Client Changes",id:"client-changes-1",level:4},{value:"Multiple 3D Selections Per Fragment",id:"multiple-3d-selections-per-fragment",level:2},{value:"Usage with Relay Hooks",id:"usage-with-relay-hooks",level:2},{value:"Using non-React modules",id:"using-non-react-modules",level:2},{value:"Important Notes / Troubleshooting",id:"important-notes--troubleshooting",level:2},{value:"ServerCallableModule Is No Longer Required",id:"servercallablemodule-is-no-longer-required",level:2}],g=(a="FbSuspensePlaceholder",function(e){return console.warn("Component "+a+" was not imported, exported, or provided by MDXProvider as global scope"),(0,m.mdx)("div",e)}),x={toc:h};function y(e){var n=e.components,t=(0,o.Z)(e,l);return(0,m.mdx)("wrapper",(0,r.Z)({},x,t,{components:n,mdxType:"MDXLayout"}),(0,m.mdx)(i.FbInternalOnly,{mdxType:"FbInternalOnly"},(0,m.mdx)("admonition",{type:"note"},(0,m.mdx)("p",{parentName:"admonition"},"Throughout this guide, we use ",(0,m.mdx)("inlineCode",{parentName:"p"},"MatchContainer"),". If you are in www, but not in Comet, you should use RelayFBMatchContainer."))),(0,m.mdx)(i.OssOnly,{mdxType:"OssOnly"},(0,m.mdx)("admonition",{type:"warning"},(0,m.mdx)("p",{parentName:"admonition"},"Server 3D requires configuring your server to support various features! It is unlikely to work in OSS without significant work. Relay does not claim to fully support Server 3D in OSS (yet), but ",(0,m.mdx)("a",{parentName:"p",href:"../client-3d/"},"Client 3D")," is fully supported."))),(0,m.mdx)("p",null,"Use server 3D when all the data fields used to render your 3D components are fetched from GraphQL servers."),(0,m.mdx)("h2",{id:"simple-3d-with-module"},"Simple 3D with @module"),(0,m.mdx)("p",null,"The basic cases for 3D are the first two cases described in ",(0,m.mdx)("a",{parentName:"p",href:"../introduction/#use-cases"},"Use Cases"),": content that is typically missing (where the corresponding rendering code is typically unused) or a union of many types (where only some of the possible rendering code is typically used). These cases are supported with the ",(0,m.mdx)("inlineCode",{parentName:"p"},"@module(name: String)")," directive on fragment spreads, which specifies a React component to download only if the data exists and fragment's type matches."),(0,m.mdx)("h3",{id:"module-usage-guide"},"@module Usage Guide"),(0,m.mdx)("p",null,"Let's walk through how to handle a comment that may contain an image attachment, where we only want to download the image rendering code when an image is actually present."),(0,m.mdx)("h4",{id:"server-changes"},"Server Changes"),(0,m.mdx)(i.FbInternalOnly,{mdxType:"FbInternalOnly"},(0,m.mdx)("ul",null,(0,m.mdx)("li",{parentName:"ul"},"For each concrete (GraphQLObject) type that you want to use ",(0,m.mdx)("inlineCode",{parentName:"li"},"@module")," with, update the schema to use the ",(0,m.mdx)("inlineCode",{parentName:"li"},"HasJSDependency")," trait. In this case we'd add the trait to the type of the ",(0,m.mdx)("inlineCode",{parentName:"li"},"Comment.image")," field \u2014 let's say that is ",(0,m.mdx)("inlineCode",{parentName:"li"},"CommentImage"),":")),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-php"},"<<\n  GraphQLObject('CommentImage', 'An image attached to a comment'),\n  Oncalls('<todo>')\n>>\nfinal class CommentImage ... {\n  // Note: Each type used with @module must use the `HasJSDependency` trait\n  // to allow dynamically loading a client-specified React component\n  use HasJSDependency;\n\n  ...\n}\n")),(0,m.mdx)("ul",null,(0,m.mdx)("li",{parentName:"ul"},"Rebuild the GraphQL schema with ",(0,m.mdx)("inlineCode",{parentName:"li"},"phps graphql"),"."))),(0,m.mdx)(i.OssOnly,{mdxType:"OssOnly"},(0,m.mdx)("ul",null,(0,m.mdx)("li",{parentName:"ul"},"For each concrete (GraphQLObject) type that you want to use ",(0,m.mdx)("inlineCode",{parentName:"li"},"@module")," with, update the schema to support the fields (",(0,m.mdx)("inlineCode",{parentName:"li"},"__fragment")," and ",(0,m.mdx)("inlineCode",{parentName:"li"},"__component"),") that are present later in this document."))),(0,m.mdx)("h4",{id:"client-changes"},"Client Changes"),(0,m.mdx)("p",null,"Your Relay fragment can now use ",(0,m.mdx)("inlineCode",{parentName:"p"},"@module"),". In this example, if the ",(0,m.mdx)("inlineCode",{parentName:"p"},"comment.image")," field is present (non-null), we load the ",(0,m.mdx)("inlineCode",{parentName:"p"},"CommentImage.react")," component and use the ",(0,m.mdx)("inlineCode",{parentName:"p"},"CommentImage_image")," fragment to load its data."),(0,m.mdx)("p",null,"On the Relay side you'd write:"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-graphql"},'fragment Comment_comment on Comment {\n  image {\n    ...CommentImage_image\n      @module(name: "CommentImage.react")\n  }\n}\n')),(0,m.mdx)(i.FbInternalOnly,{mdxType:"FbInternalOnly"},"Which the server receives as the following:",(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-graphql"},'fragment Comment_comment on Comment {\n  image {\n    ... on CommentImage {\n       ...CommentImage_image\n       __component: js("CommentImage.react")\n       __fragment: js("CommentImage_image$normalization.graphql")\n    }\n  }\n}\n'))),(0,m.mdx)("p",null,"To consume the ",(0,m.mdx)("inlineCode",{parentName:"p"},"comment.image")," field and render the component when the data exists, you shouldn't statically require the component (which would introduce a static dependency) and instead use ",(0,m.mdx)("inlineCode",{parentName:"p"},"MatchContainer")," to return the dynamically selected component:"),(0,m.mdx)(i.FbInternalOnly,{mdxType:"FbInternalOnly"},"Within Meta, use `CometRelay.MatchContainer` (Comet) or `RelayFBMatchContainer` (www)."),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-js"},"const {useFragment, graphql, MatchContainer} = require('react-relay');\n\nfunction CommentRenderer(props) {\n  const comment = useFragment(\n    /* fragment Comment_comment from above */,\n    props.comment,\n  );\n\n  if (comment.image == null) {\n    // Handle cases where the field failed to load or was null\n    return null;\n  }\n  // MatchContainer may suspend while loading the component or its data,\n  // consider wrapping with React.Suspense.\n  return (\n    <Suspense fallback={null}>\n      <MatchContainer\n        // data for field containing @module selection\n        match={comment.image}\n        props={{ /* ...other props... */ }}\n      />\n    </Suspense>\n  );\n}\nmodule.exports = CommentRenderer;\n")),(0,m.mdx)("admonition",{type:"caution"},(0,m.mdx)("p",{parentName:"admonition"},"When using MatchContainer, the component loaded using 3D needs to have the same prop name as the fragment suffix e.g. if your fragment is ",(0,m.mdx)("inlineCode",{parentName:"p"},"Comment_comment"),", your prop needs to be called ",(0,m.mdx)("inlineCode",{parentName:"p"},"comment")," instead of something like ",(0,m.mdx)("inlineCode",{parentName:"p"},"comment$key"))),(0,m.mdx)("h2",{id:"advanced-3d-with-match"},"Advanced 3D with @match"),(0,m.mdx)("p",null,"In some cases a given piece of content can be rendered in a variety of different rendering strategies. In this case, the client and server have to negotiate to choose the ideal strategy for each piece of content: the content may be eligible to be rendered as SuperFancyMarkdown, but if the client doesn't support that type the app should fallback to just regular Markdown rather than showing nothing at all. Relay supports this client/server negotiation with the ",(0,m.mdx)("inlineCode",{parentName:"p"},"@match")," directive."),(0,m.mdx)("h3",{id:"match-design-principles"},"@match Design Principles"),(0,m.mdx)("ul",null,(0,m.mdx)("li",{parentName:"ul"},"The client specifies which strategies it supports (a given client may not support all possible strategies), how it will render that data (one React component per strategy), and what data it needs (a GraphQL fragment for each strategy, describing the React component's data dependencies)."),(0,m.mdx)("li",{parentName:"ul"},"The server - specifically ",(0,m.mdx)("em",{parentName:"li"},"product logic in the schema"),' - selects the rendering strategy to use, selecting the "best" strategy given the user, data, and the client\'s supported strategies.'),(0,m.mdx)("li",{parentName:"ul"},"The code (Component) and data (GraphQL) for the selected strategy is downloaded ",(0,m.mdx)("em",{parentName:"li"},"dynamically")," once the strategy is selected. Data is downloaded as normal GraphQL data, and metadata about the code is sent down in a side-channel (technically, in the ",(0,m.mdx)("a",{parentName:"li",href:"https://graphql.org/learn/response/#extensions"},(0,m.mdx)("inlineCode",{parentName:"a"},"extensions"))," field of the GraphQL payload).")),(0,m.mdx)("h3",{id:"match-usage-guide"},"@match Usage Guide"),(0,m.mdx)("p",null,"Let's walk through the steps to implementing an example of adding a new data-driven dependency for a ",(0,m.mdx)("inlineCode",{parentName:"p"},"Comment")," type with ",(0,m.mdx)("inlineCode",{parentName:"p"},"markdown")," and ",(0,m.mdx)("inlineCode",{parentName:"p"},"plaintext")," rendering strategies."),(0,m.mdx)("h4",{id:"server-changes-1"},"Server Changes"),(0,m.mdx)(i.FbInternalOnly,{mdxType:"FbInternalOnly"},(0,m.mdx)("ul",null,(0,m.mdx)("li",{parentName:"ul"},"Define a new ",(0,m.mdx)("inlineCode",{parentName:"li"},"GraphQLUnion")," type with a variant for each rendering strategy:")),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-php"},"<<\n  GraphQLUnion('CommentRenderer', 'Data-driven dependency for comments...'),\n  Oncalls('<todo>')\n>>\ninterface ICommentRenderer extends IGraphQLUnion {}\n\n<<\n  GraphQLObject('CommentMarkdownRenderer', 'Comment with markdown rendering'),\n  Oncalls('<todo>')\n>>\nfinal class CommentMarkdownRenderer implements ICommentRenderer {\n  // Note: Each class in the union must use the `HasJSDependency` trait to allow\n  // dynamically loading a client-specified React compon\n  use HasJSDependency;\n\n  <<GraphQLField('markdown', 'Markdown text')>>\n  public function markdown(): string {\n    return 'markdown'; // todo: load markdown content from the comment\n  }\n}\n\n<<\n  GraphQLObject('CommentPlaintextRenderer', 'Comment with plaintext rendering'),\n  Oncalls('<todo>')\n>>\nfinal class CommentPlaintextRenderer implements ICommentRenderer {\n  // Note: Each class in the union must use the `HasJSDependency` trait to allow\n  // dynamically loading a client-specified React compon\n  use HasJSDependency;\n\n  <<GraphQLField('plaintext', 'Plaintext')>>\n  public function plaintext(): string {\n    return 'plaintext'; // todo: load text content from the comment\n  }\n}\n")),(0,m.mdx)("ul",null,(0,m.mdx)("li",{parentName:"ul"},"Add a new field on the ",(0,m.mdx)("inlineCode",{parentName:"li"},"Comment")," type that accepts a ",(0,m.mdx)("inlineCode",{parentName:"li"},"Traversable<string> supported")," argument listing the client's supported strategies, and returns one of the union values to indicate the selected strategy:")),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-php"},"<<\n  GraphQLObject('Comment', 'Comment on a post'),\n  Oncalls('<todo>')\n>>\nfinal class Comment {\n  <<GraphQLField(\n    'comment_content_renderer',\n    'Field that returns a rendering strategy for the main content of the comment',\n  )>>\n  public function commentContentRenderer(Traversable<string> $supported): ICommentRenderer {\n    if (C\\contains($supported, 'CommentMarkdownRenderer') && userIsEligibleForMarkdownContent()) {\n      return new CommentMarkdownRenderer();\n    }\n    return new CommentPlaintextRenderer();\n  }\n}\n")),(0,m.mdx)("ul",null,(0,m.mdx)("li",{parentName:"ul"},"Rebuild the GraphQL schema with ",(0,m.mdx)("inlineCode",{parentName:"li"},"arc rebuild"),".")),(0,m.mdx)("h4",{id:"choose-render-strategy-api"},"Choose Render Strategy API"),(0,m.mdx)("p",null,"In some cases, your use case might require multiple and more complex checks in order to choose a proper render strategy. For those cases, you can extend your strategies with ",(0,m.mdx)("inlineCode",{parentName:"p"},"IRenderStrategy"),".  So, the example above could be extended aggregating ",(0,m.mdx)("inlineCode",{parentName:"p"},"CommentMarkupRenderer")," simply writing the following code:"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-php"},"<<\n  GraphQLObject('CommentMarkupRenderer', 'Comment with markup rendering'),\n  Oncalls('<todo>')\n>>\nfinal class CommentMarkupRenderer implements ICommentRenderer, IRenderStrategy {\n\n  use HasJSDependency;\n\n  <<GraphQLField('markup', 'Markdown text')>>\n  public function markdown(): string {\n    return 'markup'; // todo: load markup content from the comment\n  }\n\n  <<__Override>>\n  public async function genShouldShow(): Awaitable<bool> {\n    return userIsEligibleForMarkupContent();\n  }\n}\nfinal class CommentMarkdownRenderer implements ICommentRenderer, IRenderStrategy {\n  // ...\n  <<__Override>>\n  public async function genShouldShow(): Awaitable<bool> {\n    return userIsEligibleForMarkdownContent();\n  }\n}\n\nfinal class CommentPlaintextRenderer implements ICommentRenderer, IRenderStrategy {\n  // ...\n  <<__Override>>\n  public async function genShouldShow(): Awaitable<bool> {\n    // By default we want to use this strategy as a fallback\n    return true;\n  }\n}\n")),(0,m.mdx)("p",null,"having all RendererStrategies implementing IRenderStrategy, we can choose the strategy using ",(0,m.mdx)("inlineCode",{parentName:"p"},"RenderStrategySelector::genChooseStrategy"),". Making sure to place strategies in the proper order, since the first strategy that ",(0,m.mdx)("inlineCode",{parentName:"p"},"genShouldShow")," returns true will be picked as:"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-php"},"public function commentContentRenderer(Traversable<string> $supported): Awaitable<ICommentRenderer> {\n  return await RenderStrategySelector::genChooseStrategy(\n    vec[\n      CommentMarkdownRenderer(),\n      CommentMarkupRenderer(),\n      CommentPlaintextRenderer(),\n    ],\n    $supported,\n  )\n}\n"))),(0,m.mdx)(i.OssOnly,{mdxType:"OssOnly"},(0,m.mdx)("ul",null,(0,m.mdx)("li",{parentName:"ul"},"Define a new ",(0,m.mdx)("inlineCode",{parentName:"li"},"GraphQLUnion")," type with a variant for each rendering strategy."),(0,m.mdx)("li",{parentName:"ul"},"Add a new field on the ",(0,m.mdx)("inlineCode",{parentName:"li"},"Comment")," type that accepts an ",(0,m.mdx)("inlineCode",{parentName:"li"},"Array<string> supported")," argument listing the client's supported strategies, and returns one of the union values to indicate the selected strategy.")),(0,m.mdx)("p",null,"For example:"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-graphql"},"type CommentMarkdownRenderer {\n  markdown_content: String\n  __component: JSDependency\n  __fragment: JSDependency\n}\n\ntype CommentPlaintextRenderer {\n  plaintext_content: String\n  __component: JSDependency\n  __fragment: JSDependency\n}\n\nunion CommentRenderer = CommentMarkdownRenderer | CommentPlaintextRenderer\n\ntype Comment {\n  # ... other fields here\n  comment_content_renderer(supported: [String!]): CommentRenderer\n}\n"))),(0,m.mdx)("h4",{id:"client-changes-1"},"Client Changes"),(0,m.mdx)("p",null,"Your Relay fragment can now use ",(0,m.mdx)("inlineCode",{parentName:"p"},"@match")," to specify that for the ",(0,m.mdx)("inlineCode",{parentName:"p"},"comment_content_renderer")," field, we expect dependencies to be decided by the data. In this example, if the ",(0,m.mdx)("inlineCode",{parentName:"p"},"comment_content_renderer")," field is of type ",(0,m.mdx)("inlineCode",{parentName:"p"},"CommentMarkdownRenderer"),", we load the ",(0,m.mdx)("inlineCode",{parentName:"p"},"CommentMarkdownRenderer.react")," component and use the ",(0,m.mdx)("inlineCode",{parentName:"p"},"CommentMarkdownRenderer_comment")," fragment to load its data. Similar for the plaintext variant."),(0,m.mdx)("admonition",{type:"caution"},(0,m.mdx)("p",{parentName:"admonition"},"The inline fragments annotated with ",(0,m.mdx)("inlineCode",{parentName:"p"},"@module")," on the same parent 3D fragment must be on distinct concrete types. If they are on the same concrete type, the relay compiler will report an error. So in the example below, ",(0,m.mdx)("inlineCode",{parentName:"p"},"CommentMarkdownRenderer_comment")," must be on a different concrete type than ",(0,m.mdx)("inlineCode",{parentName:"p"},"CommentPlaintextRenderer_comment")," (for example, the former could be on a ",(0,m.mdx)("inlineCode",{parentName:"p"},"MarkdownComment")," type, and the latter on a ",(0,m.mdx)("inlineCode",{parentName:"p"},"PlaintextComment")," type. Both could implement a parent interface ",(0,m.mdx)("inlineCode",{parentName:"p"},"Comment"),").")),(0,m.mdx)("p",null,"On the Relay side you'd write:"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-graphql"},'fragment Comment_comment on Comment {\n  comment_content_renderer @match {\n    ...CommentMarkdownRenderer_comment\n      @module(name: "CommentMarkdownRenderer.react")\n\n    ...CommentPlaintextRenderer_comment\n      @module(name: "CommentPlaintextRenderer.react")\n  }\n}\n')),(0,m.mdx)("p",null,"Which the server receives as the following - note that the ",(0,m.mdx)("inlineCode",{parentName:"p"},"supported")," argument is generated automatically based on the types that we have provided fragments for above:"),(0,m.mdx)(i.FbInternalOnly,{mdxType:"FbInternalOnly"},(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-graphql"},'fragment Comment_comment on Comment {\n  comment_content_renderer(supported: ["CommentMarkdownRenderer", "CommentPlaintextRenderer"]) {\n    ... on CommentMarkdownRenderer {\n       ...CommentMarkdownRenderer_comment\n       __component: js("CommentMarkdownRenderer.react")\n       __fragment: js("CommentMarkdownRenderer_comment$normalization.graphql")\n    }\n    ... on CommentPlaintextRenderer {\n       ...CommentPlaintextRenderer_comment\n       __component: js("CommentPlaintextRenderer.react")\n       __fragment: js("CommentPlaintextRenderer_comment$normalization.graphql")\n    }\n  }\n}\n'))),(0,m.mdx)(i.OssOnly,{mdxType:"OssOnly"},(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-graphql"},'fragment Comment_comment on Comment {\n  comment_content_renderer(supported: ["CommentMarkdownRenderer", "CommentPlaintextRenderer"]) {\n    ... on CommentMarkdownRenderer {\n       ...CommentMarkdownRenderer_comment\n    }\n    ... on CommentPlaintextRenderer {\n       ...CommentPlaintextRenderer_comment\n    }\n  }\n}\n'))),(0,m.mdx)("p",null,"To consume the comment_content_renderer field and render the appropriate container, you shouldn't statically require the component (which would introduce a static dependency) and instead use ",(0,m.mdx)("inlineCode",{parentName:"p"},"MatchContainer")," to return the dynamically selected component:"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-js"},"const React = require('React');\nconst {Suspense} = React;\nconst {graphql, useFragment, MatchContainer} = require('react-relay');\n\nfunction CommentRenderer(props) {\n  const comment = useFragment(\n    /* fragment from above */,\n    props.comment,\n  );\n\n  if (comment.comment_content_renderer == null) {\n    // Handle cases where the field failed to load or was null\n    return null;\n  }\n\n  // MatchContainer may suspend while loading the component/its data,\n  // consider wrapping with React.Suspense.\n  return (\n    <Suspense fallback={null}>\n      <MatchContainer\n        // data for field containing at-module selection\n        match={comment.comment_content_renderer}\n        props={{/* other props */}}\n      />\n    </Suspense>\n  );\n}\nmodule.exports = CommentRenderer;\n")),(0,m.mdx)("admonition",{type:"caution"},(0,m.mdx)("p",{parentName:"admonition"},"When using MatchContainer, the component loaded using 3D needs to have the same prop name as the fragment suffix e.g. if your fragment is ",(0,m.mdx)("inlineCode",{parentName:"p"},"Comment_comment"),", your prop needs to be called ",(0,m.mdx)("inlineCode",{parentName:"p"},"comment")," instead of something like ",(0,m.mdx)("inlineCode",{parentName:"p"},"comment$key"))),(0,m.mdx)("h2",{id:"multiple-3d-selections-per-fragment"},"Multiple 3D Selections Per Fragment"),(0,m.mdx)("p",null,"If your component needs to select multiple data-driven dependencies in a single fragment, each field must be named with a distinct ",(0,m.mdx)("inlineCode",{parentName:"p"},"key"),". The key can be provided by adding the ",(0,m.mdx)("inlineCode",{parentName:"p"},"@match")," directive on the parent field:"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-graphql"},'# DOESN\'T WORK\nfragment Example_comment on Comment {\n  comment_content_renderer @match {\n    ...CommentMarkdownRenderer_comment\n      @module(name: "CommentMarkdownRenderer.react")\n  }\n  attachments {\n    attachment_renderer {\n      ...CommentAttachmentPhotoRenderer_comment\n        @module(name: "CommentPhotoRenderer.react")\n    }\n  }\n}\n')),(0,m.mdx)("p",null,"This will fail with a message such as:"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre"},"`Error: Invalid @module selection: documents with multiple fields containing 3D\nselections must specify a unique 'key' value for each field:\nuse 'attachment_renderer @match(key: \"ExampleComment_<localName>\")'.`\n")),(0,m.mdx)("p",null,"In this case, follow the suggestion in the error and add ",(0,m.mdx)("inlineCode",{parentName:"p"},'@match(key: "...")')," on the second 3D field (",(0,m.mdx)("inlineCode",{parentName:"p"},"attachment_renderer")," in this case):"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre"},'// OK - different keys with @match\nfragment Example_comment on Comment {\n  comment_content_renderer @match {\n    ...CommentMarkdownRenderer_comment\n      @module(name: "CommentMarkdownRenderer.react")\n  }\n  attachments {\n    attachment_renderer @match(key: "Example_comment__attachment") {\n      ...CommentAttachmentPhotoRenderer_comment\n        @module(name: "CommentPhotoRenderer.react")\n    }\n  }\n}\n')),(0,m.mdx)("p",null,"Internally, Relay uses the 'key' value to isolate the results of each field in the store. This ensures that even if both fields return the same object, that the results can't collide."),(0,m.mdx)("h2",{id:"usage-with-relay-hooks"},"Usage with Relay Hooks"),(0,m.mdx)("p",null,"The preferred way of using 3D is with the ",(0,m.mdx)("a",{parentName:"p",href:"../../../api-reference/use-fragment/"},(0,m.mdx)("inlineCode",{parentName:"a"},"useFragment"))," API."),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-js"},"// CommentRenderer.react.js\n\nconst {graphql, useFragment, MatchContainer} = require('react-relay');\n\nfunction CommentRenderer(props) {\n  const comment = useFragment(\n    graphql`\n      fragment Comment_comment on Comment {\n        image {\n          ...CommentImageRenderer_image @module(name: \"CommentImageRenderer.react\")\n        }\n      }\n    `,\n    props.comment,\n  );\n\n  if (comment.image == null) {\n    // Handle cases where the field failed to load or was null\n    return null;\n  }\n\n  // MatchContainer may suspend while loading the component/its data,\n  // consider wrapping with React.Suspense.\n  return (\n    <Suspense fallback={null}>\n      <MatchContainer\n        // data for field containing @module selection\n        match={comment.image}\n        props={{...other props...}}\n      />\n    </Suspense>\n  );\n}\nmodule.exports = CommentRenderer;\n")),(0,m.mdx)(g,{mdxType:"FbSuspensePlaceholder"}),(0,m.mdx)("p",null,"The component that is dynamically loaded via 3D can also be a component that uses ",(0,m.mdx)("inlineCode",{parentName:"p"},"useFragment"),":"),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-js"},"// CommentImageRenderer.react.js\nimport type {CommentImageRenderer_image$key} from 'CommentImageRenderer_image.graphql'\n\nconst {useFragment} = require('react-relay');\n\ntype Props = {\n  image: CommentImageRenderer_image$key,\n};\n\nfunction CommentImageRenderer(props) {\n  const data = useFragment(\n    graphql`\n      fragment CommentImageRenderer_image on Image {\n        src\n      }\n    `,\n    props.image,\n  );\n\n  return (...);\n}\n\nmodule.exports = CommentImageRenderer;\n")),(0,m.mdx)(i.FbInternalOnly,{mdxType:"FbInternalOnly"},(0,m.mdx)("h2",{id:"using-non-react-modules"},"Using non-React modules"),(0,m.mdx)("p",null,"The typical usage of data-driven dependencies is to dynamically load modules that export a React component with data-dependencies expressed via Relay. However, Relay also supports dynamically loading ",(0,m.mdx)("em",{parentName:"p"},"arbitrary")," JS modules. This works the same ",(0,m.mdx)("inlineCode",{parentName:"p"},"@match")," / ",(0,m.mdx)("inlineCode",{parentName:"p"},"@module")," syntax, but (as you may expect) ",(0,m.mdx)("inlineCode",{parentName:"p"},"MatchContainer")," won't work for this case. Instead, use ",(0,m.mdx)("inlineCode",{parentName:"p"},"ModuleResource.read()"),". The above example using ",(0,m.mdx)("inlineCode",{parentName:"p"},"MatchContainer")," can be rewritten to manually read and use the ",(0,m.mdx)("inlineCode",{parentName:"p"},"@module")," result:"),(0,m.mdx)("admonition",{type:"tip"},(0,m.mdx)("p",{parentName:"admonition"},"In www, outside of Comet, you should use ",(0,m.mdx)("inlineCode",{parentName:"p"},"RelayFBModuleResource.read()")," instead of ",(0,m.mdx)("inlineCode",{parentName:"p"},"ModuleResource.read()"),".")),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-js"},"const React = require('React');\nconst {Suspense} = React;\nconst {graphql, useFragment, ModuleResource} = require('react-relay');\nconst CommentFragment = graphql`\n  fragment Comment_comment on Comment {\n    comment_content_renderer @match {\n      ...CommentMarkdownRenderer_comment\n        @module(name: \"CommentMarkdownRenderer.react\")\n      ...CommentPlaintextRenderer_comment\n        @module(name: \"CommentPlaintextRenderer.react\")\n    }\n  }\n`;\nfunction CommentRenderer(props) {\n  const comment = useFragment(\n    CommentFragment,\n    props.comment,\n  );\n  if (comment.image == null) {\n    // Handle cases where the field failed to load or was null\n    return null;\n  }\n  // NOTE: this will suspend if the module is not loaded:\n  // the *parent* component should wrap this one in a Suspense boundary\n  // MatchedModule will be:\n  // - null if there was no match\n  // - CommentMarkdownRenderer.react if the result was markdown\n  // - CommentPlaintextRenderer.react if the result was plaintext\n\n  const MatchedModule = ModuleResource.read(comment.image);\n\n  if (MatchedModule == null) {\n    return null; // no match\n  }\n  // Here we ensure that all possible matched components accept the data\n  // on the same prop key, in this case 'comment'\n  // Note that MatchContainer automatically determines the\n  // correct prop key to use for the matched data.\n  return (\n    <MatchedModule\n      comment={comment.image}\n    />\n  );\n}\nmodule.exports = CommentRenderer;\n")),(0,m.mdx)("p",null,"You can also use ",(0,m.mdx)("inlineCode",{parentName:"p"},"@module")," directly to load a non-React module for a field if it isn't null (without using ",(0,m.mdx)("inlineCode",{parentName:"p"},"@match"),"), and similarly consume the module using ",(0,m.mdx)("inlineCode",{parentName:"p"},"ModuleResource.read()"),":"),(0,m.mdx)("admonition",{type:"tip"},(0,m.mdx)("p",{parentName:"admonition"},"In www, outside of Comet, you should use ",(0,m.mdx)("inlineCode",{parentName:"p"},"RelayFBModuleResource.read()")," instead of ",(0,m.mdx)("inlineCode",{parentName:"p"},"ModuleResource.read()"),".")),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-js"},'function CommentRenderer(props) {\n  const comment = useFragment(\n    graphql`\n      fragment Comment_comment on Comment {\n        image {\n          ...CommentImage_image\n            @module(name: "ImageProcessingModule")\n        }\n      }\n    `,\n    props.comment,\n  );\n\n  if (comment.image == null) {\n    // Handle cases where the field failed to load or was null\n    return null;\n  }\n\n  // NOTE: this will suspend if the module is not loaded\n  const ImageProcessingModule = ModuleResource.read(comment.image);\n\n  if (ImageProcessingModule == null) {\n    return null; // no match\n  }\n\n  // ...\n}\n')),(0,m.mdx)("p",null,(0,m.mdx)("strong",{parentName:"p"},"Note:")," ",(0,m.mdx)("inlineCode",{parentName:"p"},"@module"),' requires a fragment, which cannot be empty. If you don\'t want to fetch any data from the server (only conditionally files), you can define a "dummy" fragment for your field:'),(0,m.mdx)("pre",null,(0,m.mdx)("code",{parentName:"pre",className:"language-javascript"},'// Define a fragment as a wrapper to use with @module\n// The fragment below will be able to reference this fragment by name\ngraphql`\n  fragment FragmentForModule_image on Image {\n    __typename # only use __typename here since we don\'t need any data\n  }\n`;\n\nfunction CommentRenderer(props) {\n  const comment = useFragment(\n    graphql`\n      fragment Comment_comment on Comment {\n        image {\n          # Spread wrapper fragment\n          ...FragmentForModule_image\n            @module(name: "ImageProcessingModule")\n        }\n      }\n    `,\n    props.comment,\n  );\n\n  // ...\n}\n'))),(0,m.mdx)("h2",{id:"important-notes--troubleshooting"},"Important Notes / Troubleshooting"),(0,m.mdx)("ul",null,(0,m.mdx)("li",{parentName:"ul"},"Note that ",(0,m.mdx)("inlineCode",{parentName:"li"},"MatchContainer")," will suspend until the selected component finishes loading, so be sure to wrap it in a ",(0,m.mdx)("inlineCode",{parentName:"li"},"Suspense")," placeholder.")),(0,m.mdx)(i.FbInternalOnly,{mdxType:"FbInternalOnly"},(0,m.mdx)("h2",{id:"servercallablemodule-is-no-longer-required"},"ServerCallableModule Is No Longer Required"),(0,m.mdx)("p",null,"Usage of 3D ",(0,m.mdx)("strong",{parentName:"p"},"previously")," required adding an ",(0,m.mdx)("inlineCode",{parentName:"p"},"@ServerCallableModule")," annotation to components loaded with ",(0,m.mdx)("inlineCode",{parentName:"p"},"@module"),". ",(0,m.mdx)("strong",{parentName:"p"},"This annotation is no longer required"),'. You may see diffs titled "',"[Codemod][DeadServerCallable]",'" that remove these now-unnecessary annotations, these diffs are expected and safe to land so long as they are only removing these annotations and not accidentally making other changes (i.e. please sanity-check the bot!).')),(0,m.mdx)(d.Z,{mdxType:"DocsRating"}))}y.isMDXComponent=!0}}]);