/*
 * This file is generated, do not modify directly.
 *
 * Generated by:
 *   ./generate_flatbuffer.py
 *
 * Using:
 *   flatc version 1.12.0
 *
 * NOTE: The script requires `flatc` in the path which can be installed
 *       using `brew install flatbuffers` or similar.
 *
 * @generated
 */

#![allow(unused_imports, dead_code)]

use std::mem;
use std::cmp::Ordering;

use flatbuffers;

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBConstValueKind {
  Null = 0,
  String = 1,
  Bool = 2,
  Int = 3,
  Float = 4,
  Enum = 5,
  List = 6,
  Object = 7,

}

pub const ENUM_MIN_FBCONST_VALUE_KIND: i8 = 0;
pub const ENUM_MAX_FBCONST_VALUE_KIND: i8 = 7;

impl<'a> flatbuffers::Follow<'a> for FBConstValueKind {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBConstValueKind {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const FBConstValueKind;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const FBConstValueKind;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBConstValueKind {
    type Output = FBConstValueKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBConstValueKind>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBCONST_VALUE_KIND:[FBConstValueKind; 8] = [
  FBConstValueKind::Null,
  FBConstValueKind::String,
  FBConstValueKind::Bool,
  FBConstValueKind::Int,
  FBConstValueKind::Float,
  FBConstValueKind::Enum,
  FBConstValueKind::List,
  FBConstValueKind::Object
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBCONST_VALUE_KIND:[&'static str; 8] = [
    "Null",
    "String",
    "Bool",
    "Int",
    "Float",
    "Enum",
    "List",
    "Object"
];

pub fn enum_name_fbconst_value_kind(e: FBConstValueKind) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_FBCONST_VALUE_KIND[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBTypeKind {
  Scalar = 0,
  InputObject = 1,
  Enum = 2,
  Object = 3,
  Interface = 4,
  Union = 5,

}

pub const ENUM_MIN_FBTYPE_KIND: i8 = 0;
pub const ENUM_MAX_FBTYPE_KIND: i8 = 5;

impl<'a> flatbuffers::Follow<'a> for FBTypeKind {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBTypeKind {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const FBTypeKind;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const FBTypeKind;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBTypeKind {
    type Output = FBTypeKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBTypeKind>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBTYPE_KIND:[FBTypeKind; 6] = [
  FBTypeKind::Scalar,
  FBTypeKind::InputObject,
  FBTypeKind::Enum,
  FBTypeKind::Object,
  FBTypeKind::Interface,
  FBTypeKind::Union
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBTYPE_KIND:[&'static str; 6] = [
    "Scalar",
    "InputObject",
    "Enum",
    "Object",
    "Interface",
    "Union"
];

pub fn enum_name_fbtype_kind(e: FBTypeKind) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_FBTYPE_KIND[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBTypeReferenceKind {
  Named = 0,
  NonNull = 1,
  List = 2,

}

pub const ENUM_MIN_FBTYPE_REFERENCE_KIND: i8 = 0;
pub const ENUM_MAX_FBTYPE_REFERENCE_KIND: i8 = 2;

impl<'a> flatbuffers::Follow<'a> for FBTypeReferenceKind {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBTypeReferenceKind {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const FBTypeReferenceKind;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const FBTypeReferenceKind;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBTypeReferenceKind {
    type Output = FBTypeReferenceKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBTypeReferenceKind>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBTYPE_REFERENCE_KIND:[FBTypeReferenceKind; 3] = [
  FBTypeReferenceKind::Named,
  FBTypeReferenceKind::NonNull,
  FBTypeReferenceKind::List
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBTYPE_REFERENCE_KIND:[&'static str; 3] = [
    "Named",
    "NonNull",
    "List"
];

pub fn enum_name_fbtype_reference_kind(e: FBTypeReferenceKind) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_FBTYPE_REFERENCE_KIND[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FBDirectiveLocation {
  Query = 0,
  Mutation = 1,
  Subscription = 2,
  Field = 3,
  FragmentDefinition = 4,
  FragmentSpread = 5,
  InlineFragment = 6,
  Schema = 7,
  Scalar = 8,
  Object = 9,
  FieldDefinition = 10,
  ArgumentDefinition = 11,
  Interface = 12,
  Union = 13,
  Enum = 14,
  EnumValue = 15,
  InputObject = 16,
  InputFieldDefinition = 17,
  VariableDefinition = 18,

}

pub const ENUM_MIN_FBDIRECTIVE_LOCATION: i8 = 0;
pub const ENUM_MAX_FBDIRECTIVE_LOCATION: i8 = 18;

impl<'a> flatbuffers::Follow<'a> for FBDirectiveLocation {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FBDirectiveLocation {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const FBDirectiveLocation;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const FBDirectiveLocation;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FBDirectiveLocation {
    type Output = FBDirectiveLocation;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FBDirectiveLocation>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FBDIRECTIVE_LOCATION:[FBDirectiveLocation; 19] = [
  FBDirectiveLocation::Query,
  FBDirectiveLocation::Mutation,
  FBDirectiveLocation::Subscription,
  FBDirectiveLocation::Field,
  FBDirectiveLocation::FragmentDefinition,
  FBDirectiveLocation::FragmentSpread,
  FBDirectiveLocation::InlineFragment,
  FBDirectiveLocation::Schema,
  FBDirectiveLocation::Scalar,
  FBDirectiveLocation::Object,
  FBDirectiveLocation::FieldDefinition,
  FBDirectiveLocation::ArgumentDefinition,
  FBDirectiveLocation::Interface,
  FBDirectiveLocation::Union,
  FBDirectiveLocation::Enum,
  FBDirectiveLocation::EnumValue,
  FBDirectiveLocation::InputObject,
  FBDirectiveLocation::InputFieldDefinition,
  FBDirectiveLocation::VariableDefinition
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_FBDIRECTIVE_LOCATION:[&'static str; 19] = [
    "Query",
    "Mutation",
    "Subscription",
    "Field",
    "FragmentDefinition",
    "FragmentSpread",
    "InlineFragment",
    "Schema",
    "Scalar",
    "Object",
    "FieldDefinition",
    "ArgumentDefinition",
    "Interface",
    "Union",
    "Enum",
    "EnumValue",
    "InputObject",
    "InputFieldDefinition",
    "VariableDefinition"
];

pub fn enum_name_fbdirective_location(e: FBDirectiveLocation) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_FBDIRECTIVE_LOCATION[index as usize]
}

pub enum FBConstValueOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBConstValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBConstValue<'a> {
    type Inner = FBConstValue<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBConstValue<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBConstValue {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBConstValueArgs<'args>) -> flatbuffers::WIPOffset<FBConstValue<'bldr>> {
      let mut builder = FBConstValueBuilder::new(_fbb);
      if let Some(x) = args.object_value { builder.add_object_value(x); }
      if let Some(x) = args.list_value { builder.add_list_value(x); }
      if let Some(x) = args.enum_value { builder.add_enum_value(x); }
      if let Some(x) = args.float_value { builder.add_float_value(x); }
      if let Some(x) = args.int_value { builder.add_int_value(x); }
      if let Some(x) = args.string_value { builder.add_string_value(x); }
      builder.add_bool_value(args.bool_value);
      builder.add_kind(args.kind);
      builder.finish()
    }

    pub const VT_KIND: flatbuffers::VOffsetT = 4;
    pub const VT_STRING_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_BOOL_VALUE: flatbuffers::VOffsetT = 8;
    pub const VT_INT_VALUE: flatbuffers::VOffsetT = 10;
    pub const VT_FLOAT_VALUE: flatbuffers::VOffsetT = 12;
    pub const VT_ENUM_VALUE: flatbuffers::VOffsetT = 14;
    pub const VT_LIST_VALUE: flatbuffers::VOffsetT = 16;
    pub const VT_OBJECT_VALUE: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn kind(&self) -> FBConstValueKind {
    self._tab.get::<FBConstValueKind>(FBConstValue::VT_KIND, Some(FBConstValueKind::Null)).unwrap()
  }
  #[inline]
  pub fn string_value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBConstValue::VT_STRING_VALUE, None)
  }
  #[inline]
  pub fn bool_value(&self) -> bool {
    self._tab.get::<bool>(FBConstValue::VT_BOOL_VALUE, Some(false)).unwrap()
  }
  #[inline]
  pub fn int_value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBConstValue::VT_INT_VALUE, None)
  }
  #[inline]
  pub fn float_value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBConstValue::VT_FLOAT_VALUE, None)
  }
  #[inline]
  pub fn enum_value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBConstValue::VT_ENUM_VALUE, None)
  }
  #[inline]
  pub fn list_value(&self) -> Option<FBListValue<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBListValue<'a>>>(FBConstValue::VT_LIST_VALUE, None)
  }
  #[inline]
  pub fn object_value(&self) -> Option<FBObjectValue<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBObjectValue<'a>>>(FBConstValue::VT_OBJECT_VALUE, None)
  }
}

pub struct FBConstValueArgs<'a> {
    pub kind: FBConstValueKind,
    pub string_value: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub bool_value: bool,
    pub int_value: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub float_value: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub enum_value: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub list_value: Option<flatbuffers::WIPOffset<FBListValue<'a >>>,
    pub object_value: Option<flatbuffers::WIPOffset<FBObjectValue<'a >>>,
}
impl<'a> Default for FBConstValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBConstValueArgs {
            kind: FBConstValueKind::Null,
            string_value: None,
            bool_value: false,
            int_value: None,
            float_value: None,
            enum_value: None,
            list_value: None,
            object_value: None,
        }
    }
}
pub struct FBConstValueBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBConstValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_kind(&mut self, kind: FBConstValueKind) {
    self.fbb_.push_slot::<FBConstValueKind>(FBConstValue::VT_KIND, kind, FBConstValueKind::Null);
  }
  #[inline]
  pub fn add_string_value(&mut self, string_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBConstValue::VT_STRING_VALUE, string_value);
  }
  #[inline]
  pub fn add_bool_value(&mut self, bool_value: bool) {
    self.fbb_.push_slot::<bool>(FBConstValue::VT_BOOL_VALUE, bool_value, false);
  }
  #[inline]
  pub fn add_int_value(&mut self, int_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBConstValue::VT_INT_VALUE, int_value);
  }
  #[inline]
  pub fn add_float_value(&mut self, float_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBConstValue::VT_FLOAT_VALUE, float_value);
  }
  #[inline]
  pub fn add_enum_value(&mut self, enum_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBConstValue::VT_ENUM_VALUE, enum_value);
  }
  #[inline]
  pub fn add_list_value(&mut self, list_value: flatbuffers::WIPOffset<FBListValue<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBListValue<'_>>>(FBConstValue::VT_LIST_VALUE, list_value);
  }
  #[inline]
  pub fn add_object_value(&mut self, object_value: flatbuffers::WIPOffset<FBObjectValue<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBObjectValue<'_>>>(FBConstValue::VT_OBJECT_VALUE, object_value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBConstValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBConstValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBConstValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBListValueOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBListValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBListValue<'a> {
    type Inner = FBListValue<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBListValue<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBListValue {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBListValueArgs<'args>) -> flatbuffers::WIPOffset<FBListValue<'bldr>> {
      let mut builder = FBListValueBuilder::new(_fbb);
      if let Some(x) = args.values { builder.add_values(x); }
      builder.finish()
    }

    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBConstValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBConstValue<'a>>>>>(FBListValue::VT_VALUES, None)
  }
}

pub struct FBListValueArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBConstValue<'a >>>>>,
}
impl<'a> Default for FBListValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBListValueArgs {
            values: None,
        }
    }
}
pub struct FBListValueBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBListValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBConstValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBListValue::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBListValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBListValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBListValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBObjectFieldOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBObjectField<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBObjectField<'a> {
    type Inner = FBObjectField<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBObjectField<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBObjectField {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBObjectFieldArgs<'args>) -> flatbuffers::WIPOffset<FBObjectField<'bldr>> {
      let mut builder = FBObjectFieldBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBObjectField::VT_NAME, None)
  }
  #[inline]
  pub fn value(&self) -> Option<FBConstValue<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBConstValue<'a>>>(FBObjectField::VT_VALUE, None)
  }
}

pub struct FBObjectFieldArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub value: Option<flatbuffers::WIPOffset<FBConstValue<'a >>>,
}
impl<'a> Default for FBObjectFieldArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBObjectFieldArgs {
            name: None,
            value: None,
        }
    }
}
pub struct FBObjectFieldBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBObjectFieldBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBObjectField::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<FBConstValue<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBConstValue<'_>>>(FBObjectField::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBObjectFieldBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBObjectFieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBObjectField<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBObjectValueOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBObjectValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBObjectValue<'a> {
    type Inner = FBObjectValue<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBObjectValue<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBObjectValue {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBObjectValueArgs<'args>) -> flatbuffers::WIPOffset<FBObjectValue<'bldr>> {
      let mut builder = FBObjectValueBuilder::new(_fbb);
      if let Some(x) = args.fields { builder.add_fields(x); }
      builder.finish()
    }

    pub const VT_FIELDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn fields(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBObjectField<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBObjectField<'a>>>>>(FBObjectValue::VT_FIELDS, None)
  }
}

pub struct FBObjectValueArgs<'a> {
    pub fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBObjectField<'a >>>>>,
}
impl<'a> Default for FBObjectValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBObjectValueArgs {
            fields: None,
        }
    }
}
pub struct FBObjectValueBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBObjectValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_fields(&mut self, fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBObjectField<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBObjectValue::VT_FIELDS, fields);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBObjectValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBObjectValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBObjectValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTypeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBType<'a> {
    type Inner = FBType<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBType<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBType {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTypeArgs) -> flatbuffers::WIPOffset<FBType<'bldr>> {
      let mut builder = FBTypeBuilder::new(_fbb);
      builder.add_union_id(args.union_id);
      builder.add_interface_id(args.interface_id);
      builder.add_object_id(args.object_id);
      builder.add_enum_id(args.enum_id);
      builder.add_input_object_id(args.input_object_id);
      builder.add_scalar_id(args.scalar_id);
      builder.add_kind(args.kind);
      builder.finish()
    }

    pub const VT_KIND: flatbuffers::VOffsetT = 4;
    pub const VT_SCALAR_ID: flatbuffers::VOffsetT = 6;
    pub const VT_INPUT_OBJECT_ID: flatbuffers::VOffsetT = 8;
    pub const VT_ENUM_ID: flatbuffers::VOffsetT = 10;
    pub const VT_OBJECT_ID: flatbuffers::VOffsetT = 12;
    pub const VT_INTERFACE_ID: flatbuffers::VOffsetT = 14;
    pub const VT_UNION_ID: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn kind(&self) -> FBTypeKind {
    self._tab.get::<FBTypeKind>(FBType::VT_KIND, Some(FBTypeKind::Scalar)).unwrap()
  }
  #[inline]
  pub fn scalar_id(&self) -> u32 {
    self._tab.get::<u32>(FBType::VT_SCALAR_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn input_object_id(&self) -> u32 {
    self._tab.get::<u32>(FBType::VT_INPUT_OBJECT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn enum_id(&self) -> u32 {
    self._tab.get::<u32>(FBType::VT_ENUM_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn object_id(&self) -> u32 {
    self._tab.get::<u32>(FBType::VT_OBJECT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn interface_id(&self) -> u32 {
    self._tab.get::<u32>(FBType::VT_INTERFACE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn union_id(&self) -> u32 {
    self._tab.get::<u32>(FBType::VT_UNION_ID, Some(0)).unwrap()
  }
}

#[derive(Copy, Clone)]
    pub struct FBTypeArgs {
    pub kind: FBTypeKind,
    pub scalar_id: u32,
    pub input_object_id: u32,
    pub enum_id: u32,
    pub object_id: u32,
    pub interface_id: u32,
    pub union_id: u32,
}
impl<'a> Default for FBTypeArgs {
    #[inline]
    fn default() -> Self {
        FBTypeArgs {
            kind: FBTypeKind::Scalar,
            scalar_id: 0,
            input_object_id: 0,
            enum_id: 0,
            object_id: 0,
            interface_id: 0,
            union_id: 0,
        }
    }
}
pub struct FBTypeBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBTypeBuilder<'a, 'b> {
  #[inline]
  pub fn add_kind(&mut self, kind: FBTypeKind) {
    self.fbb_.push_slot::<FBTypeKind>(FBType::VT_KIND, kind, FBTypeKind::Scalar);
  }
  #[inline]
  pub fn add_scalar_id(&mut self, scalar_id: u32) {
    self.fbb_.push_slot::<u32>(FBType::VT_SCALAR_ID, scalar_id, 0);
  }
  #[inline]
  pub fn add_input_object_id(&mut self, input_object_id: u32) {
    self.fbb_.push_slot::<u32>(FBType::VT_INPUT_OBJECT_ID, input_object_id, 0);
  }
  #[inline]
  pub fn add_enum_id(&mut self, enum_id: u32) {
    self.fbb_.push_slot::<u32>(FBType::VT_ENUM_ID, enum_id, 0);
  }
  #[inline]
  pub fn add_object_id(&mut self, object_id: u32) {
    self.fbb_.push_slot::<u32>(FBType::VT_OBJECT_ID, object_id, 0);
  }
  #[inline]
  pub fn add_interface_id(&mut self, interface_id: u32) {
    self.fbb_.push_slot::<u32>(FBType::VT_INTERFACE_ID, interface_id, 0);
  }
  #[inline]
  pub fn add_union_id(&mut self, union_id: u32) {
    self.fbb_.push_slot::<u32>(FBType::VT_UNION_ID, union_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTypeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTypeReferenceOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTypeReference<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTypeReference<'a> {
    type Inner = FBTypeReference<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTypeReference<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTypeReference {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTypeReferenceArgs<'args>) -> flatbuffers::WIPOffset<FBTypeReference<'bldr>> {
      let mut builder = FBTypeReferenceBuilder::new(_fbb);
      if let Some(x) = args.list { builder.add_list(x); }
      if let Some(x) = args.null { builder.add_null(x); }
      if let Some(x) = args.named { builder.add_named(x); }
      builder.add_kind(args.kind);
      builder.finish()
    }

    pub const VT_KIND: flatbuffers::VOffsetT = 4;
    pub const VT_NAMED: flatbuffers::VOffsetT = 6;
    pub const VT_NULL: flatbuffers::VOffsetT = 8;
    pub const VT_LIST: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn kind(&self) -> FBTypeReferenceKind {
    self._tab.get::<FBTypeReferenceKind>(FBTypeReference::VT_KIND, Some(FBTypeReferenceKind::Named)).unwrap()
  }
  #[inline]
  pub fn named(&self) -> Option<FBType<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBType<'a>>>(FBTypeReference::VT_NAMED, None)
  }
  #[inline]
  pub fn null(&self) -> Option<FBTypeReference<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBTypeReference<'a>>>(FBTypeReference::VT_NULL, None)
  }
  #[inline]
  pub fn list(&self) -> Option<FBTypeReference<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBTypeReference<'a>>>(FBTypeReference::VT_LIST, None)
  }
}

pub struct FBTypeReferenceArgs<'a> {
    pub kind: FBTypeReferenceKind,
    pub named: Option<flatbuffers::WIPOffset<FBType<'a >>>,
    pub null: Option<flatbuffers::WIPOffset<FBTypeReference<'a >>>,
    pub list: Option<flatbuffers::WIPOffset<FBTypeReference<'a >>>,
}
impl<'a> Default for FBTypeReferenceArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTypeReferenceArgs {
            kind: FBTypeReferenceKind::Named,
            named: None,
            null: None,
            list: None,
        }
    }
}
pub struct FBTypeReferenceBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBTypeReferenceBuilder<'a, 'b> {
  #[inline]
  pub fn add_kind(&mut self, kind: FBTypeReferenceKind) {
    self.fbb_.push_slot::<FBTypeReferenceKind>(FBTypeReference::VT_KIND, kind, FBTypeReferenceKind::Named);
  }
  #[inline]
  pub fn add_named(&mut self, named: flatbuffers::WIPOffset<FBType<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBType<'_>>>(FBTypeReference::VT_NAMED, named);
  }
  #[inline]
  pub fn add_null(&mut self, null: flatbuffers::WIPOffset<FBTypeReference<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBTypeReference<'_>>>(FBTypeReference::VT_NULL, null);
  }
  #[inline]
  pub fn add_list(&mut self, list: flatbuffers::WIPOffset<FBTypeReference<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBTypeReference<'_>>>(FBTypeReference::VT_LIST, list);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTypeReferenceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTypeReferenceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTypeReference<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBArgumentValueOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBArgumentValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBArgumentValue<'a> {
    type Inner = FBArgumentValue<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBArgumentValue<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBArgumentValue {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBArgumentValueArgs<'args>) -> flatbuffers::WIPOffset<FBArgumentValue<'bldr>> {
      let mut builder = FBArgumentValueBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBArgumentValue::VT_NAME, None)
  }
  #[inline]
  pub fn value(&self) -> Option<FBConstValue<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBConstValue<'a>>>(FBArgumentValue::VT_VALUE, None)
  }
}

pub struct FBArgumentValueArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub value: Option<flatbuffers::WIPOffset<FBConstValue<'a >>>,
}
impl<'a> Default for FBArgumentValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBArgumentValueArgs {
            name: None,
            value: None,
        }
    }
}
pub struct FBArgumentValueBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBArgumentValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBArgumentValue::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<FBConstValue<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBConstValue<'_>>>(FBArgumentValue::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBArgumentValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBArgumentValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBArgumentValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBDirectiveValueOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBDirectiveValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBDirectiveValue<'a> {
    type Inner = FBDirectiveValue<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBDirectiveValue<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBDirectiveValue {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBDirectiveValueArgs<'args>) -> flatbuffers::WIPOffset<FBDirectiveValue<'bldr>> {
      let mut builder = FBDirectiveValueBuilder::new(_fbb);
      if let Some(x) = args.arguments { builder.add_arguments(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_ARGUMENTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBDirectiveValue::VT_NAME, None)
  }
  #[inline]
  pub fn arguments(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBArgumentValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBArgumentValue<'a>>>>>(FBDirectiveValue::VT_ARGUMENTS, None)
  }
}

pub struct FBDirectiveValueArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub arguments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBArgumentValue<'a >>>>>,
}
impl<'a> Default for FBDirectiveValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBDirectiveValueArgs {
            name: None,
            arguments: None,
        }
    }
}
pub struct FBDirectiveValueBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBDirectiveValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBDirectiveValue::VT_NAME, name);
  }
  #[inline]
  pub fn add_arguments(&mut self, arguments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBArgumentValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBDirectiveValue::VT_ARGUMENTS, arguments);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBDirectiveValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBDirectiveValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBDirectiveValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBArgumentOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBArgument<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBArgument<'a> {
    type Inner = FBArgument<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBArgument<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBArgument {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBArgumentArgs<'args>) -> flatbuffers::WIPOffset<FBArgument<'bldr>> {
      let mut builder = FBArgumentBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.type_ { builder.add_type_(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBArgument::VT_NAME, None)
  }
  #[inline]
  pub fn type_(&self) -> Option<FBTypeReference<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBTypeReference<'a>>>(FBArgument::VT_TYPE_, None)
  }
  #[inline]
  pub fn value(&self) -> Option<FBConstValue<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBConstValue<'a>>>(FBArgument::VT_VALUE, None)
  }
}

pub struct FBArgumentArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub type_: Option<flatbuffers::WIPOffset<FBTypeReference<'a >>>,
    pub value: Option<flatbuffers::WIPOffset<FBConstValue<'a >>>,
}
impl<'a> Default for FBArgumentArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBArgumentArgs {
            name: None,
            type_: None,
            value: None,
        }
    }
}
pub struct FBArgumentBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBArgumentBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBArgument::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<FBTypeReference<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBTypeReference<'_>>>(FBArgument::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<FBConstValue<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBConstValue<'_>>>(FBArgument::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBArgumentBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBArgumentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBArgument<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBDirectiveOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBDirective<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBDirective<'a> {
    type Inner = FBDirective<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBDirective<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBDirective {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBDirectiveArgs<'args>) -> flatbuffers::WIPOffset<FBDirective<'bldr>> {
      let mut builder = FBDirectiveBuilder::new(_fbb);
      if let Some(x) = args.locations { builder.add_locations(x); }
      if let Some(x) = args.arguments { builder.add_arguments(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_repeatable(args.repeatable);
      builder.add_is_extension(args.is_extension);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_IS_EXTENSION: flatbuffers::VOffsetT = 6;
    pub const VT_ARGUMENTS: flatbuffers::VOffsetT = 8;
    pub const VT_LOCATIONS: flatbuffers::VOffsetT = 10;
    pub const VT_REPEATABLE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBDirective::VT_NAME, None)
  }
  #[inline]
  pub fn is_extension(&self) -> bool {
    self._tab.get::<bool>(FBDirective::VT_IS_EXTENSION, Some(false)).unwrap()
  }
  #[inline]
  pub fn arguments(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBArgument<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBArgument<'a>>>>>(FBDirective::VT_ARGUMENTS, None)
  }
  #[inline]
  pub fn locations(&self) -> Option<flatbuffers::Vector<'a, FBDirectiveLocation>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, FBDirectiveLocation>>>(FBDirective::VT_LOCATIONS, None)
  }
  #[inline]
  pub fn repeatable(&self) -> bool {
    self._tab.get::<bool>(FBDirective::VT_REPEATABLE, Some(false)).unwrap()
  }
}

pub struct FBDirectiveArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub is_extension: bool,
    pub arguments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBArgument<'a >>>>>,
    pub locations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , FBDirectiveLocation>>>,
    pub repeatable: bool,
}
impl<'a> Default for FBDirectiveArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBDirectiveArgs {
            name: None,
            is_extension: false,
            arguments: None,
            locations: None,
            repeatable: false,
        }
    }
}
pub struct FBDirectiveBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBDirectiveBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBDirective::VT_NAME, name);
  }
  #[inline]
  pub fn add_is_extension(&mut self, is_extension: bool) {
    self.fbb_.push_slot::<bool>(FBDirective::VT_IS_EXTENSION, is_extension, false);
  }
  #[inline]
  pub fn add_arguments(&mut self, arguments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBArgument<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBDirective::VT_ARGUMENTS, arguments);
  }
  #[inline]
  pub fn add_locations(&mut self, locations: flatbuffers::WIPOffset<flatbuffers::Vector<'b , FBDirectiveLocation>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBDirective::VT_LOCATIONS, locations);
  }
  #[inline]
  pub fn add_repeatable(&mut self, repeatable: bool) {
    self.fbb_.push_slot::<bool>(FBDirective::VT_REPEATABLE, repeatable, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBDirectiveBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBDirectiveBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBDirective<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBEnumValueOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBEnumValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBEnumValue<'a> {
    type Inner = FBEnumValue<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBEnumValue<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBEnumValue {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBEnumValueArgs<'args>) -> flatbuffers::WIPOffset<FBEnumValue<'bldr>> {
      let mut builder = FBEnumValueBuilder::new(_fbb);
      if let Some(x) = args.directives { builder.add_directives(x); }
      if let Some(x) = args.value { builder.add_value(x); }
      builder.finish()
    }

    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
    pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBEnumValue::VT_VALUE, None)
  }
  #[inline]
  pub fn directives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>>>(FBEnumValue::VT_DIRECTIVES, None)
  }
}

pub struct FBEnumValueArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub directives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBDirectiveValue<'a >>>>>,
}
impl<'a> Default for FBEnumValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBEnumValueArgs {
            value: None,
            directives: None,
        }
    }
}
pub struct FBEnumValueBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBEnumValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBEnumValue::VT_VALUE, value);
  }
  #[inline]
  pub fn add_directives(&mut self, directives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBDirectiveValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBEnumValue::VT_DIRECTIVES, directives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBEnumValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBEnumValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBEnumValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBScalarOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBScalar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBScalar<'a> {
    type Inner = FBScalar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBScalar<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBScalar {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBScalarArgs<'args>) -> flatbuffers::WIPOffset<FBScalar<'bldr>> {
      let mut builder = FBScalarBuilder::new(_fbb);
      if let Some(x) = args.directives { builder.add_directives(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_is_extension(args.is_extension);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_IS_EXTENSION: flatbuffers::VOffsetT = 6;
    pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBScalar::VT_NAME, None)
  }
  #[inline]
  pub fn is_extension(&self) -> bool {
    self._tab.get::<bool>(FBScalar::VT_IS_EXTENSION, Some(false)).unwrap()
  }
  #[inline]
  pub fn directives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>>>(FBScalar::VT_DIRECTIVES, None)
  }
}

pub struct FBScalarArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub is_extension: bool,
    pub directives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBDirectiveValue<'a >>>>>,
}
impl<'a> Default for FBScalarArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBScalarArgs {
            name: None,
            is_extension: false,
            directives: None,
        }
    }
}
pub struct FBScalarBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBScalarBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBScalar::VT_NAME, name);
  }
  #[inline]
  pub fn add_is_extension(&mut self, is_extension: bool) {
    self.fbb_.push_slot::<bool>(FBScalar::VT_IS_EXTENSION, is_extension, false);
  }
  #[inline]
  pub fn add_directives(&mut self, directives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBDirectiveValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBScalar::VT_DIRECTIVES, directives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBScalarBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBScalarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBScalar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBInputObjectOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBInputObject<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBInputObject<'a> {
    type Inner = FBInputObject<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBInputObject<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBInputObject {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBInputObjectArgs<'args>) -> flatbuffers::WIPOffset<FBInputObject<'bldr>> {
      let mut builder = FBInputObjectBuilder::new(_fbb);
      if let Some(x) = args.directives { builder.add_directives(x); }
      if let Some(x) = args.fields { builder.add_fields(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_FIELDS: flatbuffers::VOffsetT = 6;
    pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBInputObject::VT_NAME, None)
  }
  #[inline]
  pub fn fields(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBArgument<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBArgument<'a>>>>>(FBInputObject::VT_FIELDS, None)
  }
  #[inline]
  pub fn directives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>>>(FBInputObject::VT_DIRECTIVES, None)
  }
}

pub struct FBInputObjectArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBArgument<'a >>>>>,
    pub directives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBDirectiveValue<'a >>>>>,
}
impl<'a> Default for FBInputObjectArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBInputObjectArgs {
            name: None,
            fields: None,
            directives: None,
        }
    }
}
pub struct FBInputObjectBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBInputObjectBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBInputObject::VT_NAME, name);
  }
  #[inline]
  pub fn add_fields(&mut self, fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBArgument<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBInputObject::VT_FIELDS, fields);
  }
  #[inline]
  pub fn add_directives(&mut self, directives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBDirectiveValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBInputObject::VT_DIRECTIVES, directives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBInputObjectBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBInputObjectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBInputObject<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBEnumOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBEnum<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBEnum<'a> {
    type Inner = FBEnum<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBEnum<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBEnum {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBEnumArgs<'args>) -> flatbuffers::WIPOffset<FBEnum<'bldr>> {
      let mut builder = FBEnumBuilder::new(_fbb);
      if let Some(x) = args.directives { builder.add_directives(x); }
      if let Some(x) = args.values { builder.add_values(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_is_extension(args.is_extension);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_IS_EXTENSION: flatbuffers::VOffsetT = 6;
    pub const VT_VALUES: flatbuffers::VOffsetT = 8;
    pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBEnum::VT_NAME, None)
  }
  #[inline]
  pub fn is_extension(&self) -> bool {
    self._tab.get::<bool>(FBEnum::VT_IS_EXTENSION, Some(false)).unwrap()
  }
  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBEnumValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBEnumValue<'a>>>>>(FBEnum::VT_VALUES, None)
  }
  #[inline]
  pub fn directives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>>>(FBEnum::VT_DIRECTIVES, None)
  }
}

pub struct FBEnumArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub is_extension: bool,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBEnumValue<'a >>>>>,
    pub directives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBDirectiveValue<'a >>>>>,
}
impl<'a> Default for FBEnumArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBEnumArgs {
            name: None,
            is_extension: false,
            values: None,
            directives: None,
        }
    }
}
pub struct FBEnumBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBEnumBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBEnum::VT_NAME, name);
  }
  #[inline]
  pub fn add_is_extension(&mut self, is_extension: bool) {
    self.fbb_.push_slot::<bool>(FBEnum::VT_IS_EXTENSION, is_extension, false);
  }
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBEnumValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBEnum::VT_VALUES, values);
  }
  #[inline]
  pub fn add_directives(&mut self, directives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBDirectiveValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBEnum::VT_DIRECTIVES, directives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBEnumBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBEnumBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBEnum<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBObjectOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBObject<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBObject<'a> {
    type Inner = FBObject<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBObject<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBObject {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBObjectArgs<'args>) -> flatbuffers::WIPOffset<FBObject<'bldr>> {
      let mut builder = FBObjectBuilder::new(_fbb);
      if let Some(x) = args.directives { builder.add_directives(x); }
      if let Some(x) = args.interfaces { builder.add_interfaces(x); }
      if let Some(x) = args.fields { builder.add_fields(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_is_extension(args.is_extension);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_IS_EXTENSION: flatbuffers::VOffsetT = 6;
    pub const VT_FIELDS: flatbuffers::VOffsetT = 8;
    pub const VT_INTERFACES: flatbuffers::VOffsetT = 10;
    pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBObject::VT_NAME, None)
  }
  #[inline]
  pub fn is_extension(&self) -> bool {
    self._tab.get::<bool>(FBObject::VT_IS_EXTENSION, Some(false)).unwrap()
  }
  #[inline]
  pub fn fields(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(FBObject::VT_FIELDS, None)
  }
  #[inline]
  pub fn interfaces(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(FBObject::VT_INTERFACES, None)
  }
  #[inline]
  pub fn directives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>>>(FBObject::VT_DIRECTIVES, None)
  }
}

pub struct FBObjectArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub is_extension: bool,
    pub fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u32>>>,
    pub interfaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u32>>>,
    pub directives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBDirectiveValue<'a >>>>>,
}
impl<'a> Default for FBObjectArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBObjectArgs {
            name: None,
            is_extension: false,
            fields: None,
            interfaces: None,
            directives: None,
        }
    }
}
pub struct FBObjectBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBObjectBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBObject::VT_NAME, name);
  }
  #[inline]
  pub fn add_is_extension(&mut self, is_extension: bool) {
    self.fbb_.push_slot::<bool>(FBObject::VT_IS_EXTENSION, is_extension, false);
  }
  #[inline]
  pub fn add_fields(&mut self, fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBObject::VT_FIELDS, fields);
  }
  #[inline]
  pub fn add_interfaces(&mut self, interfaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBObject::VT_INTERFACES, interfaces);
  }
  #[inline]
  pub fn add_directives(&mut self, directives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBDirectiveValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBObject::VT_DIRECTIVES, directives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBObjectBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBObjectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBObject<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBInterfaceOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBInterface<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBInterface<'a> {
    type Inner = FBInterface<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBInterface<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBInterface {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBInterfaceArgs<'args>) -> flatbuffers::WIPOffset<FBInterface<'bldr>> {
      let mut builder = FBInterfaceBuilder::new(_fbb);
      if let Some(x) = args.directives { builder.add_directives(x); }
      if let Some(x) = args.implementing_objects { builder.add_implementing_objects(x); }
      if let Some(x) = args.interfaces { builder.add_interfaces(x); }
      if let Some(x) = args.fields { builder.add_fields(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_is_extension(args.is_extension);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_IS_EXTENSION: flatbuffers::VOffsetT = 6;
    pub const VT_FIELDS: flatbuffers::VOffsetT = 8;
    pub const VT_INTERFACES: flatbuffers::VOffsetT = 10;
    pub const VT_IMPLEMENTING_OBJECTS: flatbuffers::VOffsetT = 12;
    pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBInterface::VT_NAME, None)
  }
  #[inline]
  pub fn is_extension(&self) -> bool {
    self._tab.get::<bool>(FBInterface::VT_IS_EXTENSION, Some(false)).unwrap()
  }
  #[inline]
  pub fn fields(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(FBInterface::VT_FIELDS, None)
  }
  #[inline]
  pub fn interfaces(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(FBInterface::VT_INTERFACES, None)
  }
  #[inline]
  pub fn implementing_objects(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(FBInterface::VT_IMPLEMENTING_OBJECTS, None)
  }
  #[inline]
  pub fn directives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>>>(FBInterface::VT_DIRECTIVES, None)
  }
}

pub struct FBInterfaceArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub is_extension: bool,
    pub fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u32>>>,
    pub interfaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u32>>>,
    pub implementing_objects: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u32>>>,
    pub directives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBDirectiveValue<'a >>>>>,
}
impl<'a> Default for FBInterfaceArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBInterfaceArgs {
            name: None,
            is_extension: false,
            fields: None,
            interfaces: None,
            implementing_objects: None,
            directives: None,
        }
    }
}
pub struct FBInterfaceBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBInterfaceBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBInterface::VT_NAME, name);
  }
  #[inline]
  pub fn add_is_extension(&mut self, is_extension: bool) {
    self.fbb_.push_slot::<bool>(FBInterface::VT_IS_EXTENSION, is_extension, false);
  }
  #[inline]
  pub fn add_fields(&mut self, fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBInterface::VT_FIELDS, fields);
  }
  #[inline]
  pub fn add_interfaces(&mut self, interfaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBInterface::VT_INTERFACES, interfaces);
  }
  #[inline]
  pub fn add_implementing_objects(&mut self, implementing_objects: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBInterface::VT_IMPLEMENTING_OBJECTS, implementing_objects);
  }
  #[inline]
  pub fn add_directives(&mut self, directives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBDirectiveValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBInterface::VT_DIRECTIVES, directives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBInterfaceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBInterfaceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBInterface<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBUnionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBUnion<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBUnion<'a> {
    type Inner = FBUnion<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBUnion<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBUnion {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBUnionArgs<'args>) -> flatbuffers::WIPOffset<FBUnion<'bldr>> {
      let mut builder = FBUnionBuilder::new(_fbb);
      if let Some(x) = args.directives { builder.add_directives(x); }
      if let Some(x) = args.members { builder.add_members(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_is_extension(args.is_extension);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_IS_EXTENSION: flatbuffers::VOffsetT = 6;
    pub const VT_MEMBERS: flatbuffers::VOffsetT = 8;
    pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBUnion::VT_NAME, None)
  }
  #[inline]
  pub fn is_extension(&self) -> bool {
    self._tab.get::<bool>(FBUnion::VT_IS_EXTENSION, Some(false)).unwrap()
  }
  #[inline]
  pub fn members(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(FBUnion::VT_MEMBERS, None)
  }
  #[inline]
  pub fn directives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>>>(FBUnion::VT_DIRECTIVES, None)
  }
}

pub struct FBUnionArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub is_extension: bool,
    pub members: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u32>>>,
    pub directives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBDirectiveValue<'a >>>>>,
}
impl<'a> Default for FBUnionArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBUnionArgs {
            name: None,
            is_extension: false,
            members: None,
            directives: None,
        }
    }
}
pub struct FBUnionBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBUnionBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBUnion::VT_NAME, name);
  }
  #[inline]
  pub fn add_is_extension(&mut self, is_extension: bool) {
    self.fbb_.push_slot::<bool>(FBUnion::VT_IS_EXTENSION, is_extension, false);
  }
  #[inline]
  pub fn add_members(&mut self, members: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBUnion::VT_MEMBERS, members);
  }
  #[inline]
  pub fn add_directives(&mut self, directives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBDirectiveValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBUnion::VT_DIRECTIVES, directives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBUnionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBUnionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBUnion<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBFieldOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBField<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBField<'a> {
    type Inner = FBField<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBField<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBField {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBFieldArgs<'args>) -> flatbuffers::WIPOffset<FBField<'bldr>> {
      let mut builder = FBFieldBuilder::new(_fbb);
      if let Some(x) = args.parent_type { builder.add_parent_type(x); }
      if let Some(x) = args.directives { builder.add_directives(x); }
      if let Some(x) = args.type_ { builder.add_type_(x); }
      if let Some(x) = args.arguments { builder.add_arguments(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_is_extension(args.is_extension);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_IS_EXTENSION: flatbuffers::VOffsetT = 6;
    pub const VT_ARGUMENTS: flatbuffers::VOffsetT = 8;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 10;
    pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 12;
    pub const VT_PARENT_TYPE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBField::VT_NAME, None)
  }
  #[inline]
  pub fn is_extension(&self) -> bool {
    self._tab.get::<bool>(FBField::VT_IS_EXTENSION, Some(false)).unwrap()
  }
  #[inline]
  pub fn arguments(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBArgument<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBArgument<'a>>>>>(FBField::VT_ARGUMENTS, None)
  }
  #[inline]
  pub fn type_(&self) -> Option<FBTypeReference<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBTypeReference<'a>>>(FBField::VT_TYPE_, None)
  }
  #[inline]
  pub fn directives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>>>(FBField::VT_DIRECTIVES, None)
  }
  #[inline]
  pub fn parent_type(&self) -> Option<FBType<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBType<'a>>>(FBField::VT_PARENT_TYPE, None)
  }
}

pub struct FBFieldArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub is_extension: bool,
    pub arguments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBArgument<'a >>>>>,
    pub type_: Option<flatbuffers::WIPOffset<FBTypeReference<'a >>>,
    pub directives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBDirectiveValue<'a >>>>>,
    pub parent_type: Option<flatbuffers::WIPOffset<FBType<'a >>>,
}
impl<'a> Default for FBFieldArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBFieldArgs {
            name: None,
            is_extension: false,
            arguments: None,
            type_: None,
            directives: None,
            parent_type: None,
        }
    }
}
pub struct FBFieldBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBFieldBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBField::VT_NAME, name);
  }
  #[inline]
  pub fn add_is_extension(&mut self, is_extension: bool) {
    self.fbb_.push_slot::<bool>(FBField::VT_IS_EXTENSION, is_extension, false);
  }
  #[inline]
  pub fn add_arguments(&mut self, arguments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBArgument<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBField::VT_ARGUMENTS, arguments);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<FBTypeReference<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBTypeReference<'_>>>(FBField::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_directives(&mut self, directives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBDirectiveValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBField::VT_DIRECTIVES, directives);
  }
  #[inline]
  pub fn add_parent_type(&mut self, parent_type: flatbuffers::WIPOffset<FBType<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBType<'_>>>(FBField::VT_PARENT_TYPE, parent_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBFieldBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBFieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBField<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBTypeMapEntryOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBTypeMapEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBTypeMapEntry<'a> {
    type Inner = FBTypeMapEntry<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBTypeMapEntry<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBTypeMapEntry {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBTypeMapEntryArgs<'args>) -> flatbuffers::WIPOffset<FBTypeMapEntry<'bldr>> {
      let mut builder = FBTypeMapEntryBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBTypeMapEntry::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &FBTypeMapEntry<'_>) ->  bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) ->  ::std::cmp::Ordering {
    let key = self.name();
    key.cmp(&val)
  }
  #[inline]
  pub fn value(&self) -> Option<FBType<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBType<'a>>>(FBTypeMapEntry::VT_VALUE, None)
  }
}

pub struct FBTypeMapEntryArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub value: Option<flatbuffers::WIPOffset<FBType<'a >>>,
}
impl<'a> Default for FBTypeMapEntryArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBTypeMapEntryArgs {
            name: None, // required field
            value: None,
        }
    }
}
pub struct FBTypeMapEntryBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBTypeMapEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBTypeMapEntry::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<FBType<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBType<'_>>>(FBTypeMapEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTypeMapEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBTypeMapEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBTypeMapEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, FBTypeMapEntry::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBDirectiveMapEntryOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBDirectiveMapEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBDirectiveMapEntry<'a> {
    type Inner = FBDirectiveMapEntry<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBDirectiveMapEntry<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBDirectiveMapEntry {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBDirectiveMapEntryArgs<'args>) -> flatbuffers::WIPOffset<FBDirectiveMapEntry<'bldr>> {
      let mut builder = FBDirectiveMapEntryBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FBDirectiveMapEntry::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &FBDirectiveMapEntry<'_>) ->  bool {
    self.name() < o.name()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) ->  ::std::cmp::Ordering {
    let key = self.name();
    key.cmp(&val)
  }
  #[inline]
  pub fn value(&self) -> Option<FBDirective<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FBDirective<'a>>>(FBDirectiveMapEntry::VT_VALUE, None)
  }
}

pub struct FBDirectiveMapEntryArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub value: Option<flatbuffers::WIPOffset<FBDirective<'a >>>,
}
impl<'a> Default for FBDirectiveMapEntryArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBDirectiveMapEntryArgs {
            name: None, // required field
            value: None,
        }
    }
}
pub struct FBDirectiveMapEntryBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBDirectiveMapEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBDirectiveMapEntry::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<FBDirective<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FBDirective<'_>>>(FBDirectiveMapEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBDirectiveMapEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBDirectiveMapEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBDirectiveMapEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, FBDirectiveMapEntry::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FBSchemaOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FBSchema<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FBSchema<'a> {
    type Inner = FBSchema<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FBSchema<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FBSchema {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FBSchemaArgs<'args>) -> flatbuffers::WIPOffset<FBSchema<'bldr>> {
      let mut builder = FBSchemaBuilder::new(_fbb);
      if let Some(x) = args.fields { builder.add_fields(x); }
      if let Some(x) = args.unions { builder.add_unions(x); }
      if let Some(x) = args.interfaces { builder.add_interfaces(x); }
      if let Some(x) = args.objects { builder.add_objects(x); }
      if let Some(x) = args.enums { builder.add_enums(x); }
      if let Some(x) = args.input_objects { builder.add_input_objects(x); }
      if let Some(x) = args.scalars { builder.add_scalars(x); }
      if let Some(x) = args.directives { builder.add_directives(x); }
      if let Some(x) = args.types { builder.add_types(x); }
      builder.add_subscription_type(args.subscription_type);
      builder.add_mutation_type(args.mutation_type);
      builder.add_query_type(args.query_type);
      builder.add_has_subscription_type(args.has_subscription_type);
      builder.add_has_mutation_type(args.has_mutation_type);
      builder.finish()
    }

    pub const VT_QUERY_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_HAS_MUTATION_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_MUTATION_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_HAS_SUBSCRIPTION_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_SUBSCRIPTION_TYPE: flatbuffers::VOffsetT = 12;
    pub const VT_TYPES: flatbuffers::VOffsetT = 14;
    pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 16;
    pub const VT_SCALARS: flatbuffers::VOffsetT = 18;
    pub const VT_INPUT_OBJECTS: flatbuffers::VOffsetT = 20;
    pub const VT_ENUMS: flatbuffers::VOffsetT = 22;
    pub const VT_OBJECTS: flatbuffers::VOffsetT = 24;
    pub const VT_INTERFACES: flatbuffers::VOffsetT = 26;
    pub const VT_UNIONS: flatbuffers::VOffsetT = 28;
    pub const VT_FIELDS: flatbuffers::VOffsetT = 30;

  #[inline]
  pub fn query_type(&self) -> u32 {
    self._tab.get::<u32>(FBSchema::VT_QUERY_TYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn has_mutation_type(&self) -> bool {
    self._tab.get::<bool>(FBSchema::VT_HAS_MUTATION_TYPE, Some(false)).unwrap()
  }
  #[inline]
  pub fn mutation_type(&self) -> u32 {
    self._tab.get::<u32>(FBSchema::VT_MUTATION_TYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn has_subscription_type(&self) -> bool {
    self._tab.get::<bool>(FBSchema::VT_HAS_SUBSCRIPTION_TYPE, Some(false)).unwrap()
  }
  #[inline]
  pub fn subscription_type(&self) -> u32 {
    self._tab.get::<u32>(FBSchema::VT_SUBSCRIPTION_TYPE, Some(0)).unwrap()
  }
  #[inline]
  pub fn types(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBTypeMapEntry<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBTypeMapEntry<'a>>>>>(FBSchema::VT_TYPES, None).unwrap()
  }
  #[inline]
  pub fn directives(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBDirectiveMapEntry<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBDirectiveMapEntry<'a>>>>>(FBSchema::VT_DIRECTIVES, None).unwrap()
  }
  #[inline]
  pub fn scalars(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBScalar<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBScalar<'a>>>>>(FBSchema::VT_SCALARS, None).unwrap()
  }
  #[inline]
  pub fn input_objects(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBInputObject<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBInputObject<'a>>>>>(FBSchema::VT_INPUT_OBJECTS, None).unwrap()
  }
  #[inline]
  pub fn enums(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBEnum<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBEnum<'a>>>>>(FBSchema::VT_ENUMS, None).unwrap()
  }
  #[inline]
  pub fn objects(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBObject<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBObject<'a>>>>>(FBSchema::VT_OBJECTS, None).unwrap()
  }
  #[inline]
  pub fn interfaces(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBInterface<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBInterface<'a>>>>>(FBSchema::VT_INTERFACES, None).unwrap()
  }
  #[inline]
  pub fn unions(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBUnion<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBUnion<'a>>>>>(FBSchema::VT_UNIONS, None).unwrap()
  }
  #[inline]
  pub fn fields(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBField<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBField<'a>>>>>(FBSchema::VT_FIELDS, None).unwrap()
  }
}

pub struct FBSchemaArgs<'a> {
    pub query_type: u32,
    pub has_mutation_type: bool,
    pub mutation_type: u32,
    pub has_subscription_type: bool,
    pub subscription_type: u32,
    pub types: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBTypeMapEntry<'a >>>>>,
    pub directives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBDirectiveMapEntry<'a >>>>>,
    pub scalars: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBScalar<'a >>>>>,
    pub input_objects: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBInputObject<'a >>>>>,
    pub enums: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBEnum<'a >>>>>,
    pub objects: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBObject<'a >>>>>,
    pub interfaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBInterface<'a >>>>>,
    pub unions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBUnion<'a >>>>>,
    pub fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FBField<'a >>>>>,
}
impl<'a> Default for FBSchemaArgs<'a> {
    #[inline]
    fn default() -> Self {
        FBSchemaArgs {
            query_type: 0,
            has_mutation_type: false,
            mutation_type: 0,
            has_subscription_type: false,
            subscription_type: 0,
            types: None, // required field
            directives: None, // required field
            scalars: None, // required field
            input_objects: None, // required field
            enums: None, // required field
            objects: None, // required field
            interfaces: None, // required field
            unions: None, // required field
            fields: None, // required field
        }
    }
}
pub struct FBSchemaBuilder<'a, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a, 'b> FBSchemaBuilder<'a, 'b> {
  #[inline]
  pub fn add_query_type(&mut self, query_type: u32) {
    self.fbb_.push_slot::<u32>(FBSchema::VT_QUERY_TYPE, query_type, 0);
  }
  #[inline]
  pub fn add_has_mutation_type(&mut self, has_mutation_type: bool) {
    self.fbb_.push_slot::<bool>(FBSchema::VT_HAS_MUTATION_TYPE, has_mutation_type, false);
  }
  #[inline]
  pub fn add_mutation_type(&mut self, mutation_type: u32) {
    self.fbb_.push_slot::<u32>(FBSchema::VT_MUTATION_TYPE, mutation_type, 0);
  }
  #[inline]
  pub fn add_has_subscription_type(&mut self, has_subscription_type: bool) {
    self.fbb_.push_slot::<bool>(FBSchema::VT_HAS_SUBSCRIPTION_TYPE, has_subscription_type, false);
  }
  #[inline]
  pub fn add_subscription_type(&mut self, subscription_type: u32) {
    self.fbb_.push_slot::<u32>(FBSchema::VT_SUBSCRIPTION_TYPE, subscription_type, 0);
  }
  #[inline]
  pub fn add_types(&mut self, types: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBTypeMapEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBSchema::VT_TYPES, types);
  }
  #[inline]
  pub fn add_directives(&mut self, directives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBDirectiveMapEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBSchema::VT_DIRECTIVES, directives);
  }
  #[inline]
  pub fn add_scalars(&mut self, scalars: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBScalar<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBSchema::VT_SCALARS, scalars);
  }
  #[inline]
  pub fn add_input_objects(&mut self, input_objects: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBInputObject<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBSchema::VT_INPUT_OBJECTS, input_objects);
  }
  #[inline]
  pub fn add_enums(&mut self, enums: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBEnum<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBSchema::VT_ENUMS, enums);
  }
  #[inline]
  pub fn add_objects(&mut self, objects: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBObject<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBSchema::VT_OBJECTS, objects);
  }
  #[inline]
  pub fn add_interfaces(&mut self, interfaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBInterface<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBSchema::VT_INTERFACES, interfaces);
  }
  #[inline]
  pub fn add_unions(&mut self, unions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBUnion<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBSchema::VT_UNIONS, unions);
  }
  #[inline]
  pub fn add_fields(&mut self, fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FBField<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FBSchema::VT_FIELDS, fields);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBSchemaBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FBSchemaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FBSchema<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, FBSchema::VT_TYPES,"types");
    self.fbb_.required(o, FBSchema::VT_DIRECTIVES,"directives");
    self.fbb_.required(o, FBSchema::VT_SCALARS,"scalars");
    self.fbb_.required(o, FBSchema::VT_INPUT_OBJECTS,"input_objects");
    self.fbb_.required(o, FBSchema::VT_ENUMS,"enums");
    self.fbb_.required(o, FBSchema::VT_OBJECTS,"objects");
    self.fbb_.required(o, FBSchema::VT_INTERFACES,"interfaces");
    self.fbb_.required(o, FBSchema::VT_UNIONS,"unions");
    self.fbb_.required(o, FBSchema::VT_FIELDS,"fields");
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_fbschema<'a>(buf: &'a [u8]) -> FBSchema<'a> {
  flatbuffers::get_root::<FBSchema<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_fbschema<'a>(buf: &'a [u8]) -> FBSchema<'a> {
  flatbuffers::get_size_prefixed_root::<FBSchema<'a>>(buf)
}

#[inline]
pub fn finish_fbschema_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<FBSchema<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_fbschema_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<FBSchema<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
