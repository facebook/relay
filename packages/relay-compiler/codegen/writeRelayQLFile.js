/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 *
 * @flow
 * @providesModule writeRelayQLFile
 */

'use strict';

const SignedSource = require('signedsource');

const crypto = require('crypto');
const invariant = require('invariant');
const prettyStringify = require('prettyStringify');

import type CodegenDirectory from 'CodegenDirectory';
import type {GeneratedNode} from 'RelayConcreteNode';

async function writeRelayQLFile(
  codegenDir: CodegenDirectory,
  generatedNode: GeneratedNode,
  buildCommand: string,
  persistQuery: ?(text: string) => Promise<string>,
  platform: ?string,
): Promise<?GeneratedNode> {
  const moduleName = generatedNode.name + '.graphql';
  const platformName = platform ? moduleName + '.' + platform : moduleName;
  const filename = platformName + '.js';
  const flowTypeName = generatedNode.kind === 'Batch' ?
    'ConcreteBatch' :
    'ConcreteFragment';

  let text = null;
  let hash = null;
  if (generatedNode.kind === 'Batch') {
    text = generatedNode.text;
    invariant(
      text,
      'codegen-runner: Expected query to have text before persisting.'
    );
    const oldContent = codegenDir.read(filename);
    // Hash the concrete node including the query text.
    hash = md5(
      JSON.stringify(generatedNode) +
      (persistQuery ? 'persisted' : '') +
      buildCommand +
      'cache-breaker-3'
    );
    if (hash === extractHash(oldContent)) {
      codegenDir.markUnchanged(filename);
      return null;
    }
    if (codegenDir.onlyValidate) {
      codegenDir.markUpdated(filename);
      return null;
    }
    if (persistQuery) {
      generatedNode = {
        ...generatedNode,
        text: null,
        id: await persistQuery(text),
      };
    }
  }

  const moduleText = generateModule({
    buildCommand,
    moduleName,
    documentName: generatedNode.name,
    documentType: flowTypeName,
    docText: text,
    hash,
    concreteText: prettyStringify(generatedNode),
  });

  codegenDir.writeFile(filename, moduleText);
  return generatedNode;
}

function extractHash(text: ?string): ?string {
  if (!text) {
    return null;
  }
  if (/<<<<<|>>>>>/.test(text)) {
    // looks like a merge conflict
    return null;
  }
  const match = text.match(/^ \* @relayHash (\w{32})$/m);
  return match && match[1];
}

/**
 * Generate a module for the given document name/text.
 */
function generateModule({
  buildCommand,
  moduleName,
  documentName,
  documentType,
  docText,
  concreteText,
  hash,
}: {
  buildCommand: string,
  moduleName: string,
  documentName: string,
  documentType: string,
  docText: ?string,
  concreteText: string,
  hash: ?string,
}): string {
  const docTextComment = docText ?
    '\n/*\n' + docText.trim() + '\n*/\n' :
    '';
  const hashText = hash ?
    '\n * @relayHash ' + hash :
    '';
  const source = `/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 *
 * This file was generated by:
 *   ${buildCommand}
 *
 * ${'@'}providesModule ${moduleName}
 * ${SignedSource.getSigningToken()}${hashText}
 * ${'@'}flow
 * ${'@'}nogrep
 */

'use strict';

import type {${documentType}} from 'RelayConcreteNode';

/* eslint-disable comma-dangle, quotes */
${docTextComment}
const ${documentName}: ${documentType} = ${concreteText};

module.exports = ${documentName};
`;
  return SignedSource.signFile(source);
}

function md5(text: string): string {
  return crypto.createHash('md5').update(text).digest('hex');
}

module.exports = writeRelayQLFile;
