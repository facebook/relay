"use strict";(self.webpackChunkrelay_website=self.webpackChunkrelay_website||[]).push([[23272],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>d,MDXProvider:()=>u,mdx:()=>y,useMDXComponents:()=>p,withMDXComponents:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},i.apply(this,arguments)}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=a.createContext({}),m=function(e){return function(t){var n=p(t.components);return a.createElement(e,i({},t,{components:n}))}},p=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(d.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=o,c=m["".concat(r,".").concat(u)]||m[u]||h[u]||i;return n?a.createElement(c,s(s({ref:t},d),{},{components:n})):a.createElement(c,s({ref:t},d))}));function y(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6537:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>p});var a=n(83117),o=n(80102),i=(n(67294),n(3905)),r=["components"],s={},l="Mutations & Updates",d={unversionedId:"tutorial/mutations-updates",id:"tutorial/mutations-updates",title:"Mutations & Updates",description:"In this chapter we\u2019ll learn how to update data on the server and client. We\u2019ll go through two main examples:",source:"@site/docs/tutorial/mutations-updates.md",sourceDirName:"tutorial",slug:"/tutorial/mutations-updates",permalink:"/docs/next/tutorial/mutations-updates",draft:!1,editUrl:"https://github.com/facebook/relay/tree/main/website/docs/tutorial/mutations-updates.md",tags:[],version:"current",lastUpdatedBy:"Matt Mahoney",lastUpdatedAt:1693456229,formattedLastUpdatedAt:"Aug 31, 2023",frontMatter:{},sidebar:"docs",previous:{title:"Connections & Pagination",permalink:"/docs/next/tutorial/connections-pagination"},next:{title:"Prerequisites",permalink:"/docs/next/getting-started/prerequisites/"}},m={},p=[{value:"Implementing a Like Button",id:"implementing-a-like-button",level:2},{value:"Anatomy of a Mutation",id:"anatomy-of-a-mutation",level:2},{value:"The Like Mutation",id:"the-like-mutation",level:2},{value:"How Relay Automatically Processes Mutation Responses",id:"how-relay-automatically-processes-mutation-responses",level:2},{value:"Using Fragments in the Mutation Response",id:"using-fragments-in-the-mutation-response",level:2},{value:"Improving the UX with an Optimistic Updater",id:"improving-the-ux-with-an-optimistic-updater",level:2},{value:"Step 1 \u2014 Add the optimisticUpdater option to commitMutation",id:"step-1--add-the-optimisticupdater-option-to-commitmutation",level:3},{value:"Step 2 \u2014 Create an Updatable Fragment",id:"step-2--create-an-updatable-fragment",level:3},{value:"Step 3 \u2014 Call readUpdatableFragment",id:"step-3--call-readupdatablefragment",level:3},{value:"Step 4 \u2014 Modify the Updatable Data",id:"step-4--modify-the-updatable-data",level:3},{value:"Adding Comments \u2014 Mutations on Connections",id:"adding-comments--mutations-on-connections",level:2},{value:"Step 1 \u2014 Define the Comment Posting Mutation",id:"step-1--define-the-comment-posting-mutation",level:3},{value:"Step 2 \u2014 Call commitMutation to post it",id:"step-2--call-commitmutation-to-post-it",level:3},{value:"Step 3 \u2014 Add a Declarative Connection Handler",id:"step-3--add-a-declarative-connection-handler",level:3},{value:"Step 4 \u2014 Pass in the Connection ID as a Mutation Variable",id:"step-4--pass-in-the-connection-id-as-a-mutation-variable",level:3},{value:"Summary",id:"summary",level:2}],u={toc:p};function h(e){var t=e.components,s=(0,o.Z)(e,r);return(0,i.mdx)("wrapper",(0,a.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"mutations--updates"},"Mutations & Updates"),(0,i.mdx)("p",null,"In this chapter we\u2019ll learn how to update data on the server and client. We\u2019ll go through two main examples:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Implementing a Like button for newsfeed stories"),(0,i.mdx)("li",{parentName:"ul"},"Implementing the ability to post comments on a newsfeed story")),(0,i.mdx)("p",null,"Updating data is a complicated problem domain, and Relay handles many aspects of it automatically, while also giving you a lot of manual control so that your app can be as robust as possible in handling the cases that can arise."),(0,i.mdx)("p",null,"First let\u2019s distinguish two terms:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"A ",(0,i.mdx)("em",{parentName:"li"},"mutation")," is when you ask the server to perform some action that modifies data on the server. This is a feature of GraphQL that is analogous to an HTTP POST."),(0,i.mdx)("li",{parentName:"ul"},"An ",(0,i.mdx)("em",{parentName:"li"},"update")," is when you modify Relay\u2019s local client-side data store.")),(0,i.mdx)("p",null,"The client doesn\u2019t have the ability to directly manipulate individual pieces of data on the server side. Rather, mutations are opaque, high-level requests that express the user\u2019s intent \u2014 for example, that the user friended somebody, joined a group, posted a comment, liked a particular newsfeed story, blocked somebody, or deleted a comment. (The GraphQL schema defines what mutations are available, as well as the input parameters that each mutation accepts.)"),(0,i.mdx)("p",null,"Mutations can have far-reaching and unpredictable effects on the state of the graph. For example, let\u2019s say you join a group. Many things can change:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Your name gets added to the Group Members list"),(0,i.mdx)("li",{parentName:"ul"},"The group\u2019s membership count gets incremented"),(0,i.mdx)("li",{parentName:"ul"},"The group gets added to your list of groups"),(0,i.mdx)("li",{parentName:"ul"},"Members-only posts appear in the group\u2019s post feed"),(0,i.mdx)("li",{parentName:"ul"},"Your recommended groups may change"),(0,i.mdx)("li",{parentName:"ul"},"The group\u2019s admins may get notifications"),(0,i.mdx)("li",{parentName:"ul"},"Many other non-user-visible effects such as logging, training models, or sending emails"),(0,i.mdx)("li",{parentName:"ul"},"Etc. etc. etc.")),(0,i.mdx)("p",null,"In general, it\u2019s impossible to know what the full downstream effect of a mutation may be. So after asking the server to perform a mutation, the client just has to do its best to update its local data store, keeping the data as consistent as reasonably possible. It does this by asking the server for specific updated data as part of the mutation response, and by imperative code \u2014 called an ",(0,i.mdx)("em",{parentName:"p"},"updater")," \u2014 that fixes up the store to keep it consistent."),(0,i.mdx)("p",null,"There is no principled solution that covers every case. Even if it were possible to know the full effect of a mutation on the graph, there are even circumstances where we don\u2019t ",(0,i.mdx)("em",{parentName:"p"},"want")," to show updated data right away. For example, if you go to somebody\u2019s profile page and block them, you don\u2019t want for everything shown on that page to immediately disappear. The question of what data to update is ultimately a UI design decision."),(0,i.mdx)("p",null,"Relay tries to make it as easy as possible to update data in response to a mutation. For example, if you want to update a certain component, you can spread its fragment into your mutation, which asks the server to send updated data for whatever was selected by that fragment.  For other cases, you have to manually write an ",(0,i.mdx)("em",{parentName:"p"},"updater")," that modifies Relay\u2019s local data store imperatively. We\u2019ll look at all of these cases below."),(0,i.mdx)("hr",null),(0,i.mdx)("h2",{id:"implementing-a-like-button"},"Implementing a Like Button"),(0,i.mdx)("p",null,"Let\u2019s dip our toes in the water by implementing the Like button for Newsfeed stories. Luckily we already have a Like button prepared, so open up ",(0,i.mdx)("inlineCode",{parentName:"p"},"Story.tsx")," and drop it in to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Story")," component, remembering to spread its fragment into Story\u2019s fragment:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"// change-line\nimport StoryLikeButton from './StoryLikeButton';\n\n...\n\nconst StoryFragment = graphql`\n  fragment StoryFragment on Story {\n    title\n    summary\n    // ... etc\n    // change-line\n    ...StoryLikeButtonFragment\n  }\n`;\n\n...\n\nexport default function Story({story}: Props) {\n  const data = useFragment(StoryFragment, story);\n  return (\n    <Card>\n      <PosterByline person={data.poster} />\n      <Heading>{data.title}</Heading>\n      <Timestamp time={data.posterAt} />\n      <Image image={story.thumbnail} width={400} height={400} />\n      <StorySummary summary={data.summary} />\n      // change-line\n      <StoryLikeButton story={data} />\n      <StoryCommentsSection story={data} />\n    </Card>\n  );\n}\n")),(0,i.mdx)("p",null,"Now let\u2019s take a look at ",(0,i.mdx)("inlineCode",{parentName:"p"},"StoryLikeButton.js"),". Currently, it is a button that doesn\u2019t do anything, along with a like count."),(0,i.mdx)("p",null,(0,i.mdx)("img",{alt:"Like button",src:n(70040).Z,width:"1232",height:"462"})),(0,i.mdx)("p",null,"You can look at its fragment to see that it fetches a field ",(0,i.mdx)("inlineCode",{parentName:"p"},"likeCount")," for the like count and ",(0,i.mdx)("inlineCode",{parentName:"p"},"doesViewerLike")," to determine whether the Like button is highlighted (it\u2019s highlighted if the viewer likes the story, i.e. if ",(0,i.mdx)("inlineCode",{parentName:"p"},"doesViewerLike")," is true):"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"const StoryLikeButtonFragment = graphql`\n  fragment StoryLikeButtonFragment on Story {\n    id\n    likeCount\n    doesViewerLike\n  }\n`;\n")),(0,i.mdx)("p",null,"We want to make it so that when you press the Like button"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"The story gets \u201cliked\u201d on the server"),(0,i.mdx)("li",{parentName:"ol"},"Our local client copy of the \u201c",(0,i.mdx)("inlineCode",{parentName:"li"},"likeCount"),"\u201d and \u201c",(0,i.mdx)("inlineCode",{parentName:"li"},"doesViewerLike"),"\u201d fields get updated.")),(0,i.mdx)("p",null,"To do that, we need to write a GraphQL mutation. But first..."),(0,i.mdx)("h2",{id:"anatomy-of-a-mutation"},"Anatomy of a Mutation"),(0,i.mdx)("p",null,"The GraphQL mutation syntax is going to be confusing unless you first understand the following:"),(0,i.mdx)("p",null,"GraphQL has two different request types, Queries and Mutations \u2014 and they work in exactly the same way. This is analogous to how HTTP has GET and POST: technically the only difference is that POST requests are intended to cause effects while GET requests do not. Similarly, a Mutation is exactly like a Query, except that the Mutation is expected to cause things to happen. This means:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"A mutation is part of our client code"),(0,i.mdx)("li",{parentName:"ul"},"A mutation declares ",(0,i.mdx)("em",{parentName:"li"},"variables")," that let the client pass data to the server"),(0,i.mdx)("li",{parentName:"ul"},"The server implements ",(0,i.mdx)("em",{parentName:"li"},"individual fields.")," A given mutation composes together those fields and passes its variables in as field arguments."),(0,i.mdx)("li",{parentName:"ul"},"Each field yields data of a particular type \u2014 either scalar or an edge to some other graph node \u2014 which is returned to the client if that field is selected. In the case of edges, further fields are selected from the node being linked to.")),(0,i.mdx)("p",null,"The only difference is that, in a mutation, selecting a field makes something happen, as well as returning data."),(0,i.mdx)("h2",{id:"the-like-mutation"},"The Like Mutation"),(0,i.mdx)("p",null,"With that in mind, this is what our mutation is going to look like \u2014 go ahead and add this declaration to the file:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"const StoryLikeButtonLikeMutation = graphql`\n  mutation StoryLikeButtonLikeMutation(\n    // color1\n    $id: ID!,\n    // color1\n    $doesLike: Boolean!,\n  ) {\n    // color2\n    likeStory(\n      // color3\n      id: $id,\n      // color3\n      doesLike: $doesLike\n    ) {\n      // color4\n      story {\n        // color5\n        id\n        // color5\n        likeCount\n        // color5\n        doesViewerLike\n      }\n    }\n  }\n`;\n")),(0,i.mdx)("p",null,"This is a lot, let\u2019s break it down:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"The mutation declares ",(0,i.mdx)("span",{className:"color1"},"variables")," which are passed from the client to the server when the mutation is dispatched. Each variable has a name (",(0,i.mdx)("inlineCode",{parentName:"li"},"$id"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"$doesLike"),") and a type (",(0,i.mdx)("inlineCode",{parentName:"li"},"ID!"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"Boolean!"),"). The ",(0,i.mdx)("inlineCode",{parentName:"li"},"!")," after the type indicates that it is required, not optional."),(0,i.mdx)("li",{parentName:"ul"},"The mutation selects a ",(0,i.mdx)("span",{className:"color2"},"mutation field")," defined by the GraphQL schema. Each mutation field that the server defines corresponds to some action that the client can request of the server, such as liking a story.",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"The ",(0,i.mdx)("span",{className:"color3"},"mutation field takes arguments")," (just like any field can do). Here we pass in the mutation variables that we declared as the argument values \u2014 for example, the ",(0,i.mdx)("inlineCode",{parentName:"li"},"doesLike")," field argument is set to be the ",(0,i.mdx)("inlineCode",{parentName:"li"},"$doesLike")," mutation variable."))),(0,i.mdx)("li",{parentName:"ul"},"The ",(0,i.mdx)("inlineCode",{parentName:"li"},"likeStory")," field returns an edge to a node that represents the mutation response. We can select various fields in order to receive updated data. The fields that are available in the mutation response are specified by the GraphQL schema.",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"We select the ",(0,i.mdx)("inlineCode",{parentName:"li"},"story")," field, which is an ",(0,i.mdx)("span",{className:"color4"},"edge to the Story that we just liked"),"."),(0,i.mdx)("li",{parentName:"ul"},"We select specific ",(0,i.mdx)("span",{className:"color5"},"fields from within that Story to get updated data"),". These are the same fields that a query could select about a Story \u2014 in fact, the same fields we selected in our fragment.")))),(0,i.mdx)("p",null,"When we send the server this mutation, we\u2019ll get a response that, just like with queries, matches the shape of the mutation that we sent. For example, the server might send this back to us:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'{\n  "likeStory": {\n    "story": {\n      "id": "34a8c",\n      "likeCount": 47,\n      "doesViewerLike": true\n    }\n  }\n}\n')),(0,i.mdx)("p",null,"and our job will be to update the local data store to incorporate this updated information. Relay will handle this in simple cases, while in more complex cases it will require custom code to update the store intelligently."),(0,i.mdx)("p",null,"But we\u2019re getting ahead of ourselves \u2014 let\u2019s make that button trigger the mutation. Here\u2019s what our component looks like now \u2014 we need to hook up the ",(0,i.mdx)("inlineCode",{parentName:"p"},"onLikeButtonClicked")," event to execute ",(0,i.mdx)("inlineCode",{parentName:"p"},"StoryLikeButtonLikeMutation"),"."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"function StoryLikeButton({story}) {\n  const data = useFragment(StoryLikeButtonFragment, story);\n  function onLikeButtonClicked() {\n    // To be filled in\n  }\n  return (\n    <>\n      <LikeCount count={data.likeCount} />\n      <LikeButton value={data.doesViewerLike} onChange={onLikeButtonClicked} />\n    </>\n  )\n}\n")),(0,i.mdx)("p",null,"To do that, we add a call to ",(0,i.mdx)("inlineCode",{parentName:"p"},"useMutation"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"// change-line\nimport {useMutation, useFragment} from 'react-relay';\n\nfunction StoryLikeButton({story}) {\n  const data = useFragment(StoryLikeButtonFragment, story);\n  // change-line\n  const [commitMutation, isMutationInFlight] = useMutation(StoryLikeButtonLikeMutation);\n  function onLikeButtonClicked() {\n    // change\n    commitMutation({\n      variables: {\n        id: data.id,\n        doesLike: !data.doesViewerLike,\n      },\n    })\n    // end-change\n  }\n  return (\n    <>\n      <LikeCount count={data.likeCount} />\n      <LikeButton value={data.doesViewerLike} onChange={onLikeButtonClicked} />\n    </>\n  )\n}\n")),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"useMutation")," hook returns a function ",(0,i.mdx)("inlineCode",{parentName:"p"},"commitMutation")," that we can call to tell the server to do stuff."),(0,i.mdx)("p",null,"We pass in an option called ",(0,i.mdx)("inlineCode",{parentName:"p"},"variables")," where we give values for the variables defined by the mutation, namely ",(0,i.mdx)("inlineCode",{parentName:"p"},"id")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"doesViewerLike"),". This tells the server which story we\u2019re talking about and whether the we are liking or un-liking it. The ",(0,i.mdx)("inlineCode",{parentName:"p"},"id")," of the story we\u2019ve read from the fragment, while whether we like it or unlike it comes from toggling whatever the current value that we rendered is."),(0,i.mdx)("p",null,"The hook also returns a boolean flag that tells us when the mutation is in flight. We can use that to make the user experience nicer by disabling the button while the mutation is happening:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"<LikeButton\n  value={data.doesViewerLike}\n  onChange={onLikeButtonClicked}\n  // change-line\n  disabled={isMutationInFlight}\n/>\n")),(0,i.mdx)("p",null,"With this in place, we should now be able to like a story!"),(0,i.mdx)("h2",{id:"how-relay-automatically-processes-mutation-responses"},"How Relay Automatically Processes Mutation Responses"),(0,i.mdx)("p",null,"But how did Relay know to update the story we clicked on? The server sent back a response with this form:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'{\n  "likeStory": {\n    "story": {\n      "id": "34a8c",\n      "likeCount": 47,\n      "doesViewerLike": true\n    }\n  }\n}\n')),(0,i.mdx)("p",null,"Whenever the response includes an object with an ",(0,i.mdx)("inlineCode",{parentName:"p"},"id")," field, Relay will check if the store already contains a record with a matching ID in the ",(0,i.mdx)("inlineCode",{parentName:"p"},"id")," field of that record. If there is a match, Relay will merge the other fields from the response into the existing record. That means that, in this simple case, we don\u2019t need to write any code to update the store."),(0,i.mdx)("hr",null),(0,i.mdx)("h2",{id:"using-fragments-in-the-mutation-response"},"Using Fragments in the Mutation Response"),(0,i.mdx)("p",null,"Remember that mutations are just like queries. In order to make sure that the mutation response always contains the data we want to render, instead of having a separate set of fields that has to be manually kept up to date, we can simply spread fragments into our mutation response:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"const StoryLikeButtonLikeMutation = graphql`\n  mutation StoryLikeButtonLikeMutation(\n    $id: ID,\n    $doesLike: Boolean,\n  ) {\n    likeStory(id: $id, doesLike: $doesLike) {\n      story {\n        // change-line\n        ...StoryLikeButtonFragment\n      }\n    }\n  }\n`;\n")),(0,i.mdx)("p",null,"Now if we add or remove data requirements, all of the necessary data (but no more) will be included with the mutation response. This is usually the smart way of writing mutation responses. You can spread in any fragment from any component, not just the component that triggers the mutation. This helps you keep your whole UI up to date."),(0,i.mdx)("hr",null),(0,i.mdx)("h2",{id:"improving-the-ux-with-an-optimistic-updater"},"Improving the UX with an Optimistic Updater"),(0,i.mdx)("p",null,"Mutations take time to perform, yet we always want the UI to update immediately in some way to give the user feedback that they\u2019ve taken an action. In the current example, the Like button is disabled while the mutation is happening, and then after the mutation is done, the UI is updated into the new state as Relay merges the updated data into its store and re-renders the affected components."),(0,i.mdx)("p",null,"Oftentimes the best feedback will be to simply pretend the operation is already completed: for example, if you press the Like button, that buttons immediately goes into the same highlighted state that it will stay in whenever you see something you\u2019ve already liked. Or take the example of posting a comment: We would like to immediately show your comment as having been posted. This is because mutations are usually fast and reliable enough that we don\u2019t need to bother the user with a separate loading state for them. However, sometimes mutations do end in failure. In that case, we\u2019d like to roll back the changes we made and return you to the state you were in before we tried the mutation: the comment we showed as being posted should go away, while the text of the comment should re-appear within the composer where you wrote it, so that the data isn\u2019t lost if you want to try posting again."),(0,i.mdx)("p",null,"Managing these so-called ",(0,i.mdx)("em",{parentName:"p"},"optimistic updates")," is complicated to do manually, but Relay has a robust system for applying and rolling back updates. You can even have multiple mutations in flight at the same time (say if the user clicks several buttons in sequence), and Relay will keep track of what changes need to be rolled back in case of a failure."),(0,i.mdx)("p",null,"Mutations proceed in three phases:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"First there\u2019s an ",(0,i.mdx)("em",{parentName:"li"},"optimistic update"),", where you update the local data store into whatever state you anticipate and want to show to the user immediately."),(0,i.mdx)("li",{parentName:"ul"},"Then you actually perform the mutation on the server. If it\u2019s successful, the server responds with updated information which can be used in the third step."),(0,i.mdx)("li",{parentName:"ul"},"When the mutation is done, you roll back the optimistic update. If the mutation failed, you\u2019re done \u2014 back to where you started. If the mutation succeeded, Relay merges simple changes into the store and then applies a ",(0,i.mdx)("em",{parentName:"li"},"concluding update")," that updates the local data store with the actual new information received from the server, plus whatever other changes you want to make.")),(0,i.mdx)("p",null,(0,i.mdx)("img",{alt:"Mutation flowchart",src:n(51273).Z,width:"1398",height:"2098"})),(0,i.mdx)("hr",null),(0,i.mdx)("p",null,"With this background knowledge in hand, let\u2019s go ahead and write an optimistic updater for our Like button so that it immediately updates to the new state when clicked."),(0,i.mdx)("h3",{id:"step-1--add-the-optimisticupdater-option-to-commitmutation"},"Step 1 \u2014 Add the optimisticUpdater option to commitMutation"),(0,i.mdx)("p",null,"Go to ",(0,i.mdx)("inlineCode",{parentName:"p"},"StoryLikeButton")," and add a new option to the call to ",(0,i.mdx)("inlineCode",{parentName:"p"},"commitMutation"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"function StoryLikeButton({story}) {\n  ...\n  function onLikeButtonClicked(newDoesLike) {\n    commitMutation({\n      variables: {\n        id: data.id,\n        doesViewerLike: newDoesLike,\n      },\n      // change\n      optimisticUpdater: store => {\n        // TODO fill in optimistic updater\n      },\n      // end-change\n    })\n  }\n  ...\n}\n")),(0,i.mdx)("p",null,"This callback receives a ",(0,i.mdx)("inlineCode",{parentName:"p"},"store")," argument which represents Relay\u2019s local data store. It has various methods for reading and writing local data. All of the writes that we make in the optimistic updater will be applied immediately when the mutation is dispatched, and then rolled back when it is complete."),(0,i.mdx)("h3",{id:"step-2--create-an-updatable-fragment"},"Step 2 \u2014 Create an Updatable Fragment"),(0,i.mdx)("p",null,"We can read and write data in the local store by writing a special kind of fragment called an ",(0,i.mdx)("em",{parentName:"p"},"updatable fragment.")," Unlike a regular fragment, it doesn\u2019t get spread into queries and sent to the server. Instead, it lets us read data out of the local store using the same GraphQL syntax we already know and love. Go ahead and add this fragment definition:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"function StoryLikeButton({story}) {\n  ...\n      optimisticUpdater: store => {\n        const fragment = graphql`\n          fragment StoryLikeButton_updatable on Story\n            // color1\n            @updatable\n          {\n            likeCount\n            doesViewerLike\n          }\n        `;\n      },\n  ...\n}\n")),(0,i.mdx)("p",null,"It\u2019s exactly like any other fragment but annotated with the ",(0,i.mdx)("span",{className:"color1"},"@updatable")," directive."),(0,i.mdx)("p",null,"Unlike normal fragments, updatable fragments are not spread into queries and do not select data to be fetched from the server. Instead, they select data that\u2019s already in the Relay local data store so that the data may be updated."),(0,i.mdx)("h3",{id:"step-3--call-readupdatablefragment"},"Step 3 \u2014 Call readUpdatableFragment"),(0,i.mdx)("p",null,"We pass this ",(0,i.mdx)("span",{className:"color2"},"fragment"),", along with the ",(0,i.mdx)("span",{className:"color3"},"original fragment ref")," that we received as a prop (which tells us ",(0,i.mdx)("em",{parentName:"p"},"which")," story we\u2019re liking), to ",(0,i.mdx)("inlineCode",{parentName:"p"},"store.readUpdatableFragment"),". It returns a ",(0,i.mdx)("span",{className:"color1"},"special object called ",(0,i.mdx)("inlineCode",{parentName:"p"},"updatableData")),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"function StoryLikeButton({story}) {\n  ...\n      optimisticUpdater: store => {\n        const fragment = graphql`\n          fragment StoryLikeButton_updatable on Story @updatable {\n            likeCount\n            doesViewerLike\n          }\n        `;\n        const {\n          // color1\n          updatableData\n        } = store.readUpdatableFragment(\n          // color2\n          fragment,\n          // color3\n          story\n        );\n      },\n  ...\n}\n")),(0,i.mdx)("h3",{id:"step-4--modify-the-updatable-data"},"Step 4 \u2014 Modify the Updatable Data"),(0,i.mdx)("p",null,"Now ",(0,i.mdx)("inlineCode",{parentName:"p"},"upatableData")," is an object representing our existing Story as it exists in the local store. We can read and write the fields listed in our fragment:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"function StoryLikeButton({story}) {\n  ...\n      optimisticUpdater: store => {\n        const fragment = graphql`\n          fragment StoryLikeButton_updatable on Story @updatable {\n            likeCount\n            doesViewerLike\n          }\n        `;\n        const {updatableData} = store.readUpdatableFragment(fragment, story);\n        // change\n        const alreadyLikes = updatableData.doesViewerLike;\n        updatableData.doesViewerLike = !alreadyLikes;\n        updatableData.likeCount += (alreadyLikes ? -1 : 1);\n        // end-change\n      },\n  ...\n}\n")),(0,i.mdx)("p",null,"In this example, we toggle ",(0,i.mdx)("inlineCode",{parentName:"p"},"doesViewerLike")," (so that clicking the button when you already like the story makes you un-like it) and increment or decrement the like count accordingly."),(0,i.mdx)("p",null,"Relay records the changes we made to ",(0,i.mdx)("inlineCode",{parentName:"p"},"updatableData")," and will roll them back once the mutation is complete."),(0,i.mdx)("p",null,"Now when you click the Like button, you should see the UI immediately update."),(0,i.mdx)("hr",null),(0,i.mdx)("h2",{id:"adding-comments--mutations-on-connections"},"Adding Comments \u2014 Mutations on Connections"),(0,i.mdx)("p",null,"The only thing that Relay can do completely automatically is what we\u2019ve seen already: merge nodes in the mutation response with existing nodes that share the same ID in the store. For anything else, we have to give Relay some more information."),(0,i.mdx)("p",null,"Let\u2019s look at the case of Connections. We\u2019ll implement the ability to post a new comment on a story."),(0,i.mdx)("p",null,"The server\u2019s mutation response only includes the newly-created comment. We have to tell Relay how to insert that story into the Connection between a story and its comments."),(0,i.mdx)("p",null,"Head back over to ",(0,i.mdx)("inlineCode",{parentName:"p"},"StoryCommentsSection")," and add a component for posting a new comment, remembering to spread its fragment into our fragment:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"// change-line\nimport StoryCommentsComposer from './StoryCommentsComposer';\n\nconst StoryCommentsSectionFragment = graphql`\n  fragment StoryCommentsSectionFragment on Story\n    ...\n  {\n    comments(after: $cursor, first: $count)\n      @connection(key: \"StoryCommentsSectionFragment_comments\")\n    {\n      ...\n    }\n    // change-line\n    ...StoryCommentsComposerFragment\n  }\n`\n\nfunction StoryCommentsSection({story}) {\n  ...\n  return (\n    <>\n      // change-line\n      <StoryCommentsComposer story={data} />\n      ...\n    </>\n  );\n}\n")),(0,i.mdx)("p",null,"We should now see a composer at the top of the comments section:"),(0,i.mdx)("p",null,(0,i.mdx)("img",{alt:"Comments composer screenshot",src:n(26297).Z,width:"1200",height:"462"})),(0,i.mdx)("p",null,"Now take a look inside ",(0,i.mdx)("inlineCode",{parentName:"p"},"StoryCommentsComposer.js"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"function StoryCommentsComposer({story}) {\n  const data = useFragment(StoryCommentsComposerFragment, story);\n  const [text, setText] = useState('');\n  function onPost() {\n   // TODO post the comment here\n  }\n  return (\n    <div className=\"commentsComposer\">\n      <TextComposer text={text} onChange={setText} onReturn={onPost} />\n      <PostButton onClick={onPost} />\n    </div>\n  );\n}\n")),(0,i.mdx)("h3",{id:"step-1--define-the-comment-posting-mutation"},"Step 1 \u2014 Define the Comment Posting Mutation"),(0,i.mdx)("p",null,"Just like before, we need to define a mutation. It will send to the server the story ID and the text of the comment to be added:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"const StoryCommentsComposerPostMutation = graphql`\n  mutation StoryCommentsComposerPostMutation(\n    $id: ID!,\n    $text: String!,\n  ) {\n    postStoryComment(id: $id, text: $text) {\n      commentEdge {\n        node {\n          id\n          text\n        }\n      }\n    }\n  }\n`;\n")),(0,i.mdx)("p",null,"Here, the schema allows us to select as part of the mutation response the newly-created edge to the newly-created comment. We select it and will use it to update the local store by inserting this edge into the Connection."),(0,i.mdx)("h3",{id:"step-2--call-commitmutation-to-post-it"},"Step 2 \u2014 Call commitMutation to post it"),(0,i.mdx)("p",null,"Now we use the ",(0,i.mdx)("inlineCode",{parentName:"p"},"useMutation")," hook to get access to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"commitMutation")," callback, and call it in ",(0,i.mdx)("inlineCode",{parentName:"p"},"onPost"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"function StoryCommentsComposer({story}) {\n  const data = useFragment(StoryCommentsComposerFragment, story);\n  const [text, setText] = useState('');\n  // change-line\n  const [commitMutation, isMutationInFlight] = useMutation(StoryCommentsComposerPostMutation);\n  function onPost() {\n    // change\n    setText(''); // Reset the UI\n    commitMutation({\n      variables: {\n        id: data.id,\n        text,\n      },\n    })\n    // end-change\n  }\n  ...\n}\n")),(0,i.mdx)("h3",{id:"step-3--add-a-declarative-connection-handler"},"Step 3 \u2014 Add a Declarative Connection Handler"),(0,i.mdx)("p",null,"At this point, we can find from the network logs that clicking Post will send a mutation request to the server \u2014 you can even see that the comment has been posted since it appears if you refresh the page. However, nothing happens in the UI. We need to tell Relay to append the newly-created comment to the Connection that goes from the story to its comments."),(0,i.mdx)("p",null,"You\u2019ll notice that in the mutation response that we wrote above we select ",(0,i.mdx)("inlineCode",{parentName:"p"},"commentEdge"),". This is the edge to the newly-created comment. We just need to tell Relay what Connections to add that edge to. Relay provides directives called ",(0,i.mdx)("inlineCode",{parentName:"p"},"@appendEdge"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"@prependEdge"),", and ",(0,i.mdx)("inlineCode",{parentName:"p"},"@deleteEdge")," that you put on the edge in the mutation response. Then when you run the mutation, you pass in the IDs of the Connections that you want to modify. Relay will append, prepend, or delete the edge from those connections as you specify."),(0,i.mdx)("p",null,"We want our newly-created comment to appear at the top of the list, so we\u2019ll use ",(0,i.mdx)("inlineCode",{parentName:"p"},"@prependEdge"),". Make the following additions to the mutation definition:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"  mutation StoryCommentsComposerPostMutation(\n    $id: ID!,\n    $text: String!,\n    // change-line\n    $connections: [ID!]!,\n  ) {\n    postStoryComment(id: $id, text: $text) {\n      commentEdge\n        // change-line\n        @prependEdge(connections: $connections)\n      {\n        node {\n          id\n          text\n        }\n      }\n    }\n  }\n")),(0,i.mdx)("p",null,"We\u2019ve added a variable called ",(0,i.mdx)("inlineCode",{parentName:"p"},"connections")," to the mutation. We\u2019ll use this to pass in the Connections we want to update."),(0,i.mdx)("admonition",{type:"note"},(0,i.mdx)("p",{parentName:"admonition"},"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"$connections")," variable is only used as an argument to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"@prependEdge")," directive, which is processed on the client by Relay. Because ",(0,i.mdx)("inlineCode",{parentName:"p"},"$connections")," is not passed as an argument to any ",(0,i.mdx)("em",{parentName:"p"},"field"),", it is not sent to the server.")),(0,i.mdx)("h3",{id:"step-4--pass-in-the-connection-id-as-a-mutation-variable"},"Step 4 \u2014 Pass in the Connection ID as a Mutation Variable"),(0,i.mdx)("p",null,"We need to identify the Connection to add the new edge to. A Connections is identified with two pieces of information:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Which node it\u2019s off of \u2014 in this case, the Story we\u2019re posting a comment to."),(0,i.mdx)("li",{parentName:"ul"},"The ",(0,i.mdx)("em",{parentName:"li"},"key")," provided in the ",(0,i.mdx)("inlineCode",{parentName:"li"},"@connection")," directive, which lets us distinguish connections in case more than one connection is off of the same node.")),(0,i.mdx)("p",null,"We pass this information in to the mutation variables using a special API provided by Relay:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"// change-line\nimport {useFragment, useMutation, ConnectionHandler} from 'react-relay';\n\n...\n\nexport default function StoryCommentsComposer({story}: Props) {\n  ...\n  function onPost() {\n    setText('');\n    // change\n    const connectionID = ConnectionHandler.getConnectionID(\n      data.id,\n      'StoryCommentsSectionFragment_comments',\n    );\n    // end-change\n    commitMutation({\n      variables: {\n        id: data.id,\n        text,\n        // change-line\n        connections: [connectionID],\n      },\n    })\n  }\n  ...\n}\n")),(0,i.mdx)("p",null,"The string ",(0,i.mdx)("inlineCode",{parentName:"p"},'"StoryCommentsSectionFragment_comments"')," that we pass to ",(0,i.mdx)("inlineCode",{parentName:"p"},"getConnectionID")," is the identifier that we used when fetching the connection in ",(0,i.mdx)("inlineCode",{parentName:"p"},"StoryCommentSection")," \u2014 just as a reminder, here's what that looked like:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'const StoryCommentsSectionFragment = graphql`\n  fragment StoryCommentsSectionFragment on Story\n  ...\n  {\n    comments(after: $cursor, first: $count)\n     @connection(key: "StoryCommentsSectionFragment_comments")\n    {\n      ...\n  }\n`;\n')),(0,i.mdx)("p",null,"Meanwhile, the argument ",(0,i.mdx)("inlineCode",{parentName:"p"},"data.id")," is the ID of the specific story that we\u2019re connecting off of."),(0,i.mdx)("p",null,"With this change, we should see the comment appear in the list of comments once the mutation is complete."),(0,i.mdx)("hr",null),(0,i.mdx)("h2",{id:"summary"},"Summary"),(0,i.mdx)("p",null,"Mutations let us ask the server to make changes."),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Just like Queries, Mutations are composed of fields, accept variables, and pass those variables as arguments to fields."),(0,i.mdx)("li",{parentName:"ul"},"The fields that are selected by a Mutation constitute the ",(0,i.mdx)("em",{parentName:"li"},"mutation response")," which we can use to update the Store."),(0,i.mdx)("li",{parentName:"ul"},"Relay automatically merges nodes in the response to nodes in the Store with matching IDs."),(0,i.mdx)("li",{parentName:"ul"},"The ",(0,i.mdx)("inlineCode",{parentName:"li"},"@appendEdge"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"@prependEdge"),", and ",(0,i.mdx)("inlineCode",{parentName:"li"},"@deleteEdge")," directives let us insert and remove items from the mutation response into Connections in the store."),(0,i.mdx)("li",{parentName:"ul"},"Updaters let us manually manipulate the store."),(0,i.mdx)("li",{parentName:"ul"},"Optimistic updaters run before the mutation begins and are rolled back when it is done.")))}h.isMDXComponent=!0},26297:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/mutations-comments-composer-screenshot-a6d04dbbdaf9769f80c8f132f3358faa.png"},51273:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/mutations-lifecycle-e7492d8faa5f6a7658b90dc6ceffb42e.png"},70040:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/mutations-like-button-e1ff48a46424ab56ae8926749b065a8f.png"}}]);