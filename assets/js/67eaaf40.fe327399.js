"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["82681"],{31876(e,n,t){t.r(n),t.d(n,{metadata:()=>r,default:()=>c,frontMatter:()=>o,contentTitle:()=>i,toc:()=>d,assets:()=>l});var r=JSON.parse('{"id":"tutorial/queries-1","title":"Query Basics","description":"In this section:","source":"@site/versioned_docs/version-v19.0.0/tutorial/queries-1.md","sourceDirName":"tutorial","slug":"/tutorial/queries-1","permalink":"/docs/v19.0.0/tutorial/queries-1","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v19.0.0/tutorial/queries-1.md","tags":[],"version":"v19.0.0","frontMatter":{},"sidebar":"docs","previous":{"title":"GraphQL and Relay","permalink":"/docs/v19.0.0/tutorial/graphql"},"next":{"title":"Fragments","permalink":"/docs/v19.0.0/tutorial/fragments-1"}}'),s=t(74848),a=t(28453);let o={},i="Query Basics",l={},d=[{value:"Relay and the Type System",id:"relay-and-the-type-system",level:2},{value:"Summary",id:"summary",level:2}];function h(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{Details:r}=n;return r||function(e,n){throw Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"query-basics",children:"Query Basics"})}),"\n",(0,s.jsx)(n.p,{children:"In this section:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"We\u2019ll take a React component that displays hard-coded placeholder data and modify it so that it fetches its data using a GraphQL query."}),"\n",(0,s.jsx)(n.li,{children:"We\u2019ll learn how to use the TypeScript types that Relay generates from your GraphQL to ensure type safety."}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"With Relay, you fetch data using GraphQL Queries. A Query specifies a part of the GraphQL graph for your app to fetch, starting from some root node and traversing from node to node to retrieve a particular set of data in the shape of a tree."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"A query selects a particular subgraph",src:t(10872).A+"",width:"1516",height:"1688"})}),"\n",(0,s.jsx)(n.p,{children:"Right now, our example app doesn\u2019t fetch any data, it just renders some placeholder data that\u2019s hard-coded into the React components. Let\u2019s modify it to fetch some data using Relay."}),"\n",(0,s.jsxs)(n.p,{children:["Open up the file called ",(0,s.jsx)(n.code,{children:"Newsfeed.tsx"}),". (All of the components in the tutorial are in ",(0,s.jsx)(n.code,{children:"src/components"}),".) In it you should see a ",(0,s.jsx)(n.code,{children:"<Newsfeed>"})," component where the data is hard-coded:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'export default function Newsfeed() {\n  const story = {\n    title: "Placeholder Story",\n    summary:\n      "Placeholder data, to be replaced with data fetched via GraphQL",\n    poster: {\n      name: "Placeholder Person",\n      profilePicture: {\n        url: "/assets/cat_avatar.png",\n      },\n    },\n    thumbnail: {\n      url: "/assets/placeholder.jpeg",\n    },\n  };\n  return (\n    <div className="newsfeed">\n      <Story story={story} />\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"We\u2019re going to replace this placeholder data with data fetched from the server.  First we need to define a GraphQL query. Add the following declaration above the Newsfeed component:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"import { graphql } from 'relay-runtime';\n\n// color1\nconst NewsfeedQuery = graphql`\n  // color2\n  query NewsfeedQuery {\n    topStory {\n      // color3\n      title\n      // color3\n      summary\n      // color4\n      poster {\n        name\n        profilePicture {\n          url\n        }\n      }\n      thumbnail {\n        url\n      }\n    }\n  }\n`;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Let\u2019s break this down:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["To embed GraphQL within JavaScript, we put a string literal ",(0,s.jsxs)("span",{className:"color1",children:["marked with the ",(0,s.jsx)("code",{children:"graphql``"})," tag"]}),". This tag allows the Relay compiler to find and compile the GraphQL within a JavaScript codebase."]}),"\n",(0,s.jsxs)(n.li,{children:["Our GraphQL string consists of a ",(0,s.jsx)("span",{className:"color2",children:"query declaration"})," with the keyword ",(0,s.jsx)(n.code,{children:"query"})," and then a query name. Note that the query name ",(0,s.jsx)(n.strong,{children:"must"})," begin with the module name (in this case ",(0,s.jsx)("code",{children:"Newsfeed"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["Inside the query declaration are ",(0,s.jsx)(n.em,{children:"fields"}),", which specify what information to query for*:*","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Some fields are ",(0,s.jsx)(n.em,{children:(0,s.jsx)("span",{className:"color3",children:"scalar fields"})})," that retrieve a string, number, or other unit of information."]}),"\n",(0,s.jsxs)(n.li,{children:["Other fields are ",(0,s.jsx)(n.em,{children:(0,s.jsx)("span",{className:"color4",children:"edges"})})," that let us traverse from one node in the graph to another. When a field is an edge, it\u2019s followed by another block ",(0,s.jsx)(n.code,{children:"{ }"})," containing fields for the node at the other end of the edge. Here, the ",(0,s.jsx)(n.code,{children:"poster"})," field is an edge that goes from a Story to a Person who posted it. Once we\u2019ve traversed to the Person, we can include fields about the Person such as their ",(0,s.jsx)(n.code,{children:"name"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This illustrates the part of the graph that this query is asking for:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Parts of the GraphQL query",src:t(81294).A+"",width:"1128",height:"1296"})}),"\n",(0,s.jsx)(n.p,{children:"Now that we\u2019ve defined the query, we need to do two things."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Run the Relay compiler so that it knows about the new Graphql query. (",(0,s.jsx)(n.code,{children:"npm run relay"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"Modify our React component to fetch it and to use the data returned by the server."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If you open ",(0,s.jsx)(n.code,{children:"package.json"})," you will find the script ",(0,s.jsx)(n.code,{children:"relay"})," is hooked up to run the Relay compiler. This is what ",(0,s.jsx)(n.code,{children:"npm run relay"})," does. Once the compiler successfully updates/generated the new compiled query you will be able to find it in the ",(0,s.jsx)(n.code,{children:"__generated__"})," folder under ",(0,s.jsx)(n.code,{children:"src/components/"})," as ",(0,s.jsx)(n.code,{children:"NewsfeedQuery.graphql.ts"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Next, turn back to the ",(0,s.jsx)(n.code,{children:"Newsfeed"})," component and start by deleting the placeholder data. Then, replace it with this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'import { useLazyLoadQuery } from "react-relay";\n\nexport default function Newsfeed({}) {\n  const data = useLazyLoadQuery(\n    // color1\n    NewsfeedQuery,\n    // color2\n    {},\n  );\n  const story = data.topStory;\n  // As before:\n  return (\n    <div className="newsfeed">\n      <Story story={story} />\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useLazyLoadQuery"})," hook fetches and returns the data. It takes two arguments:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)("span",{className:"color1",children:"GraphQL query"})," that we defined before."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)("span",{className:"color2",children:"Variables"})," that are passed to the server with the query. This query doesn\u2019t declare any variables, so it\u2019s an empty object."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The object that ",(0,s.jsx)(n.code,{children:"useLazyLoadQuery"})," returns has the same shape as the query. For instance, if printed in JSON format it might look like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n  topStory: {\n    title: "Local Yak Named Yak of the Year",\n    summary: "The annual Yak of the Year awards ceremony ...",\n    poster: {\n      name: "Baller Bovine Board",\n      profilePicture: {\n        url: \'/images/baller_bovine_board.jpg\',\n      },\n    },\n    thumbnail: {\n      url: \'/images/max_the_yak.jpg\',\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Notice that each field selected by the GraphQL query corresponds to a property in the JSON response."}),"\n",(0,s.jsx)(n.p,{children:"At this point, you should see a story fetched from the server:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Screenshot",src:t(42276).A+"",width:"1406",height:"1594"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The server's responses are artificially slowed down to make loading states perceptible, which will come in handy when we add more interactivity to the app. If you want to remove the delay, open ",(0,s.jsx)(n.code,{children:"server/index.js"})," and remove the call to ",(0,s.jsx)(n.code,{children:"sleep()"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useLazyLoadQuery"})," hook fetches the data when the component is first rendered. Relay also has APIs for pre-fetching the data before your app has even loaded \u2014 these are covered later. In any case, Relay uses Suspense to show a loading indicator until the data is available."]}),"\n",(0,s.jsx)(n.p,{children:"This is Relay in its most basic form: fetching the results of a GraphQL query when a component is rendered. As the tutorial progresses, we\u2019ll see how Relay\u2019s features fit together to make your app more maintainable \u2014 starting with a look at how Relay generates TypeScript types corresponding to each query."}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"Deep dive: Suspense for Data Loading"}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Suspense"})," is a new API in React that lets React wait while data is loaded before it renders components that need that data. When a component needs to load data before rendering, React shows a loading indicator. You control the loading indicator's location and style using a special component called ",(0,s.jsx)(n.code,{children:"Suspense"}),"."]}),(0,s.jsxs)(n.p,{children:["Right now, there's a ",(0,s.jsx)(n.code,{children:"Suspense"})," component inside ",(0,s.jsx)(n.code,{children:"App.tsx"}),", which is what shows the spinner while ",(0,s.jsx)(n.code,{children:"useLazyLoadQuery"})," is loading data."]}),(0,s.jsx)(n.p,{children:"We'll look at Suspense in more detail in later sections when we add some more interactivity to the app."})]}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"Deep dive: Queries are Static"}),(0,s.jsx)(n.p,{children:"All of the GraphQL strings in a Relay app are pre-processed by the Relay compiler and removed from the resulting bundled code. This means you can\u2019t construct GraphQL queries at runtime \u2014 they have to be static string literals so that they\u2019re known at compile time. But it comes with major advantages."}),(0,s.jsx)(n.p,{children:"First, it allows Relay to generate type definitions for the results of the query, making your code more type-safe."}),(0,s.jsx)(n.p,{children:"Second, Relay replaces the GraphQL string literal with an object that tells Relay what to do. This is much faster than using the GraphQL strings directly at runtime."}),(0,s.jsxs)(n.p,{children:["Also, Relay\u2019s compiler can be configured to ",(0,s.jsx)(n.a,{href:"/docs/guides/persisted-queries/",children:"save queries to the server"})," when you build your app, so that at runtime the client need only send a query ID instead of the query itself. This saves bundle size and network bandwidth, and can prevent attackers from writing malicious queries since only those your app was built with need be available."]}),(0,s.jsx)(n.p,{children:"So when you have a GraphQL tagged string literal in your program..."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const MyQuery = graphql`\n  query MyQuery {\n    viewer {\n      name\n    }\n  }\n`;\n"})}),(0,s.jsxs)(n.p,{children:["... the JavaScript variable ",(0,s.jsx)(n.code,{children:"MyQuery"})," is actually assigned to an object that looks something like this:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'const MyQuery = {\n  kind: "query",\n  selections: [\n    {\n      name: "viewer",\n      kind: "LinkedField",\n      selections: [\n        name: "name",\n        kind: "ScalarField",\n      ],\n    }\n  ]\n};\n'})}),(0,s.jsxs)(n.p,{children:["along with various other properties and information. These data structures are carefully designed to allow the JIT to run Relay\u2019s payload processing code very quickly. If you\u2019re curious, you can use the ",(0,s.jsx)(n.a,{href:"/compiler-explorer",children:"Relay Compiler Explorer"})," to play with it."]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"relay-and-the-type-system",children:"Relay and the Type System"}),"\n",(0,s.jsx)(n.p,{children:"You might notice that TypeScript reports an error with this code as we\u2019ve written it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const story = data.topStory;\n                   ^^^^^^^^\nProperty 'topStory' does not exist on type 'unknown'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To fix this, we need to annotate the call to ",(0,s.jsx)(n.code,{children:"useLazyLoadQuery"})," with types that Relay generates. That way, TypeScript will know what type ",(0,s.jsx)(n.code,{children:"data"})," should have based on the fields we\u2019ve selected in our query. Add the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// change-line\nimport type {NewsfeedQuery as NewsfeedQueryType} from './__generated__/NewsfeedQuery.graphql';\n\nfunction Newsfeed({}) {\n  const data = useLazyLoadQuery\n  // change-line\n  <NewsfeedQueryType>\n  (NewsfeedQuery, {});\n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If we look inside ",(0,s.jsx)(n.code,{children:"__generated__/NewsfeedQuery.graphql"})," we\u2019ll see the following type definition \u2014 with the annotation we\u2019ve just added, TypeScript knows that ",(0,s.jsx)(n.code,{children:"data"})," should have this type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"export type NewsfeedQuery$data = {\n  readonly topStory: {\n    readonly poster: {\n      readonly name: string | null;\n      readonly profilePicture: {\n        readonly url: string;\n      } | null;\n    };\n    readonly summary: string | null;\n    readonly thumbnail: {\n      readonly url: string;\n    } | null;\n    readonly title: string;\n  } | null;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The Relay compiler generates TypeScript types corresponding to every piece of GraphQL that you have in your app within a ",(0,s.jsx)("code",{children:"graphql``"})," literal. As long as ",(0,s.jsx)("code",{children:"npm run dev"})," is running, the Relay compiler will automatically regenerate these files whenever you save one of your JavaScript source files, so you don\u2019t need to refresh anything to keep them up to date."]}),"\n",(0,s.jsxs)(n.p,{children:["Using Relay\u2019s generated types makes your app safer and more maintainable. In addition to TypeScript, Relay supports the Flow type system if you want to use that instead. When using Flow, the extra annotation on ",(0,s.jsx)(n.code,{children:"useLazyLoadQuery"})," is not needed, because Flow directly understands the contents of the ",(0,s.jsx)("code",{children:"graphql``"})," tagged literal."]}),"\n",(0,s.jsx)(n.p,{children:"We\u2019ll revisit types throughout this tutorial. But next, we'll look at an even more important way that Relay helps us with maintainability."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Queries are the foundation of fetching GraphQL data. We\u2019ve seen:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["How to define a GraphQL query within our app using the ",(0,s.jsx)("code",{children:"graphql``"})," tagged literal."]}),"\n",(0,s.jsxs)(n.li,{children:["How to use the ",(0,s.jsx)(n.code,{children:"useLazyLoadQuery"})," hook to fetch the results of a query when a component renders."]}),"\n",(0,s.jsx)(n.li,{children:"How to import Relay's generated types for type safety."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In the next section, we\u2019ll look at Fragments, one of the most core and distinctive aspects of Relay. Fragments let each individual component define its own data requirements, while retaining the performance advantages of issuing a single query to the server."})]})}function c(e={}){let{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},42276(e,n,t){t.d(n,{A:()=>r});let r=t.p+"assets/images/queries-basic-screenshot-cdac7c0e384df7a0dbddaf1e3d3f3de2.png"},81294(e,n,t){t.d(n,{A:()=>r});let r=t.p+"assets/images/query-breakdown-56a29935576fa45104147bef7da35749.png"},10872(e,n,t){t.d(n,{A:()=>r});let r=t.p+"assets/images/query-upon-graph-2209e828b9ce0ddc492555bb7a0a5a3c.png"},28453(e,n,t){t.d(n,{R:()=>o,x:()=>i});var r=t(96540);let s={},a=r.createContext(s);function o(e){let n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);