"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["50292"],{31744(e,r,n){n.r(r),n.d(r,{metadata:()=>l,default:()=>h,frontMatter:()=>t,contentTitle:()=>i,toc:()=>d,assets:()=>a});var l=JSON.parse('{"id":"guides/relay-resolvers/errors","title":"Error Handling","description":"How Relay handles errors thrown by resolvers","source":"@site/docs/guides/relay-resolvers/errors.mdx","sourceDirName":"guides/relay-resolvers","slug":"/guides/relay-resolvers/errors/","permalink":"/docs/next/guides/relay-resolvers/errors/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/docs/guides/relay-resolvers/errors.mdx","tags":[],"version":"current","frontMatter":{"id":"errors","title":"Error Handling","slug":"/guides/relay-resolvers/errors/","description":"How Relay handles errors thrown by resolvers"},"sidebar":"docs","previous":{"title":"Suspense","permalink":"/docs/next/guides/relay-resolvers/suspense/"},"next":{"title":"Descriptions","permalink":"/docs/next/guides/relay-resolvers/descriptions/"}}'),o=n(74848),s=n(28453);let t={id:"errors",title:"Error Handling",slug:"/guides/relay-resolvers/errors/",description:"How Relay handles errors thrown by resolvers"},i,a={},d=[{value:"Support for Semantic Nullability",id:"support-for-semantic-nullability",level:2}];function c(e){let r={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(r.p,{children:["Just like GraphQL servers, Relay Resolvers support field-level error handling. If an individual resolver throws an error, when that field is read, Relay will log that error to the environment's user-provided ",(0,o.jsx)(r.code,{children:"relayFieldLogger"})," logger, and the field will become null."]}),"\n",(0,o.jsx)(r.p,{children:"This provides important symmetry with GraphQL servers. Resolvers are designed to enable a smooth migration path to allow teams to start with fields defined client-side using Resolvers and then eventually migrate them to a server."}),"\n",(0,o.jsx)(r.p,{children:"If a resolver throws an error, Relay will log the error to the user-provided error logger, and will return null for the field which the resolver defines. To enable this behavior at runtime, the Relay compiler will not allow resolver fields to be typed as non-nullable."}),"\n",(0,o.jsxs)(r.p,{children:["The object passed to the ",(0,o.jsx)(r.code,{children:"relayFieldLogger"})," will have the following shape:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-ts",children:"type ResolverErrorEvent = {\n  kind: 'relay_resolver.error',\n  // The name of the fragment/query in which the field was read\n  owner: string,\n  // The path from the owner root to the field which threw the error\n  fieldPath: string,\n  // The error thrown by the resolver\n  error: Error,\n}\n"})}),"\n",(0,o.jsx)(r.p,{children:"An example logger might look like:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-ts",children:'function fieldLogger(event) {\n  if(event.kind === "relay_resolver.error") {\n    // Log this somewhere!\n    console.warn(`Resolver error encountered in ${event.owner}.${event.fieldPath}`)\n    console.warn(event.error)\n  }\n}\n\nconst environment = new Environment({\n  network: Network.create(/* your fetch function here */),\n  store: new RelayModernStore(new RecordSource()),\n  relayFieldLogger: fieldLogger\n});\n'})}),"\n",(0,o.jsx)(r.admonition,{type:"note",children:(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.a,{href:"/docs/next/guides/relay-resolvers/live-fields/",children:"Live Resolvers"})," can potentially throw errors when they are first evaluated or when their ",(0,o.jsx)(r.code,{children:".read()"})," method is called. Both types of errors will be handled identically by Relay."]})}),"\n",(0,o.jsx)(r.h2,{id:"support-for-semantic-nullability",children:"Support for Semantic Nullability"}),"\n",(0,o.jsxs)(r.p,{children:["Relay resolver fields can be specified as ",(0,o.jsx)(r.a,{href:"../../semantic-nullability/",children:"semantically non-null"})," just like server schema fields. Developers can add the directive ",(0,o.jsx)(r.code,{children:"@semanticNonNull"})," in the docblock of a relay resolver in order to indicate that the field is non-nullable in the semantic sense, but that the client should still be prepared to handle errors."]}),"\n",(0,o.jsx)(r.p,{children:"For example:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-ts",children:"/**\n * @RelayResolver RelayExample.semantic_non_null_field: String @semanticNonNull\n */\nexport function semantic_non_null_field(\n  model: RelayExampleModel,\n): string {\n  return model.someField ?? 'field was null, this is the default';\n}\n"})})]})}function h(e={}){let{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453(e,r,n){n.d(r,{R:()=>t,x:()=>i});var l=n(96540);let o={},s=l.createContext(o);function t(e){let r=l.useContext(s);return l.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),l.createElement(s.Provider,{value:r},e.children)}}}]);