"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[58790],{23143:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"guides/relay-resolvers/derived-fields","title":"Derived Fields","description":"Defining field which are a pure function of other fields","source":"@site/versioned_docs/version-v17.0.0/guides/relay-resolvers/derived-fields.md","sourceDirName":"guides/relay-resolvers","slug":"/guides/relay-resolvers/derived-fields/","permalink":"/docs/v17.0.0/guides/relay-resolvers/derived-fields/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v17.0.0/guides/relay-resolvers/derived-fields.md","tags":[],"version":"v17.0.0","frontMatter":{"id":"derived-fields","title":"Derived Fields","slug":"/guides/relay-resolvers/derived-fields/","description":"Defining field which are a pure function of other fields"},"sidebar":"docs","previous":{"title":"Field Arguments","permalink":"/docs/v17.0.0/guides/relay-resolvers/field-arguments/"},"next":{"title":"Live Fields","permalink":"/docs/v17.0.0/guides/relay-resolvers/live-fields/"}}');var i=r(74848),o=r(28453);const s={id:"derived-fields",title:"Derived Fields",slug:"/guides/relay-resolvers/derived-fields/",description:"Defining field which are a pure function of other fields"},a=void 0,l={},d=[{value:"Defining a Derived Resolver",id:"defining-a-derived-resolver",level:2},{value:"Composition",id:"composition",level:2},{value:"Passing Arguments to your @rootFragment",id:"passing-arguments-to-your-rootfragment",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"In addition to modeling client state, Relay Resolvers also allow you to define fields which are a pure function of other fields. These fields are called derived fields and can be defined on any type no matter if it's defined on the server or client."}),"\n",(0,i.jsxs)(n.p,{children:["For globally relevant data, resolvers have a few advantages of alternative solutions like ",(0,i.jsx)(n.a,{href:"https://react.dev/learn/reusing-logic-with-custom-hooks",children:"React Hooks"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Global memoization"})," - Relay Resolvers automatically memoize derived fields. Unlike hooks, this cache is shared by all components in your application, so if two sibling components both read the same field, the computation will only be performed once."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Efficient updates"})," - If your derived resolver recomputes but derives the same value, Relay can avoid rerendering components that read the field."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Composable"})," - Derived fields can be composed with other derived fields, allowing you to build up complex, but explicit computation graphs."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Discoverable"})," - Values in the graph are discoverable via the GraphQL schema and thus are more likely to be discovered and reused instead of reinvented."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Documented"})," - GraphQL's field documentation and structured deprecation model make it easy to understand the purpose of a field and its intended use."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"defining-a-derived-resolver",children:"Defining a Derived Resolver"}),"\n",(0,i.jsx)(n.p,{children:'Derived resolvers look like any other resolver except that they read GraphQL data instead of being computed from a parent model type. Derived resolvers read GraphQL data by defining a "root fragment" which is a GraphQL fragment defined on the parent type of the field.'}),"\n",(0,i.jsxs)(n.p,{children:["The root fragment is defined using the ",(0,i.jsx)(n.code,{children:"@rootFragment"})," docblock tag followed by the name of the fragment. This tells Relay to pass the resolver function a fragment key for that fragment. The fragment data may then be read using ",(0,i.jsx)(n.code,{children:"readFragment"})," imported from ",(0,i.jsx)(n.code,{children:"relay-runtime"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import {readFragment} from 'relay-runtime';\n\n/**\n * @RelayResolver User.fullName: String\n * @rootFragment UserFullNameFragment\n */\nexport function fullName(key: UserFullNameFragment$key): string {\n  const user = readFragment(graphql`\n    fragment UserFullNameFragment on User {\n        firstName\n        lastName\n    }\n  `, key);\n  return `${user.firstName} ${user.lastName}`;\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Relay will track all the values read from the fragment and automatically recompute the resolver when any of those values change."})}),"\n",(0,i.jsx)(n.h2,{id:"composition",children:"Composition"}),"\n",(0,i.jsx)(n.p,{children:"One powerful feature of derived resolvers is that they can read other Relay Resolver fields. This means you can define a derived resolver that combines server data, client data and even other derived resolvers. This allows you to build up complex, but explicit, computation graphs."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"/**\n * @RelayResolver CheckoutItem.isValid: Boolean\n * @rootFragment CheckoutItemFragment\n */\nexport function isValid(key): boolean {\n  const item = readFragment(graphql`\n    fragment CheckoutItemFragment on CheckoutItem {\n      product {\n        price\n      }\n      quantity\n    }\n  `, key);\n  return item.product.price * item.quantity > 0;\n}\n\n/**\n * @RelayResolver ShoppingCart.canCheckout: Boolean\n * @rootFragment ShoppingCartFragment\n */\nexport function canCheckout(key): boolean {\n  const cart = readFragment(graphql`\n    fragment ShoppingCartFragment on ShoppingCart {\n      items {\n        isValid\n      }\n    }\n  `, key);\n  return cart.items.every(item => item.isValid);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"passing-arguments-to-your-rootfragment",children:"Passing Arguments to your @rootFragment"}),"\n",(0,i.jsxs)(n.p,{children:["If a field in a derived resolver's root fragment requires arguments, you can pass them by adding an ",(0,i.jsx)(n.code,{children:"@arguments"})," tag to the docblock tag. The ",(0,i.jsx)(n.code,{children:"@argument"})," tag takes the name of the argument and the type of the argument. The argument type must be a valid GraphQL input type. For more information about arguments and Resolvers see ",(0,i.jsx)(n.a,{href:"/docs/v17.0.0/guides/relay-resolvers/field-arguments/",children:"Field Arguments"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var t=r(96540);const i={},o=t.createContext(i);function s(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);