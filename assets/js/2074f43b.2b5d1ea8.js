"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["90422"],{46182(e,t,n){n.r(t),n.d(t,{metadata:()=>r,default:()=>p,frontMatter:()=>c,contentTitle:()=>u,toc:()=>h,assets:()=>d});var r=JSON.parse('{"id":"guides/relay-resolvers/live-fields","title":"Live Fields","description":"Modeling data that changes over time in Relay Resolvers","source":"@site/docs/guides/relay-resolvers/live-fields.mdx","sourceDirName":"guides/relay-resolvers","slug":"/guides/relay-resolvers/live-fields/","permalink":"/docs/next/guides/relay-resolvers/live-fields/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/docs/guides/relay-resolvers/live-fields.mdx","tags":[],"version":"current","frontMatter":{"id":"live-fields","title":"Live Fields","slug":"/guides/relay-resolvers/live-fields/","description":"Modeling data that changes over time in Relay Resolvers"},"sidebar":"docs","previous":{"title":"Derived Fields","permalink":"/docs/next/guides/relay-resolvers/derived-fields/"},"next":{"title":"Suspense","permalink":"/docs/next/guides/relay-resolvers/suspense/"}}'),a=n(74848),s=n(28453),l=n(17352),i=n(78010),o=n(57250);let c={id:"live-fields",title:"Live Fields",slug:"/guides/relay-resolvers/live-fields/",description:"Modeling data that changes over time in Relay Resolvers"},u,d={},h=[{value:"@live",id:"live",level:2},{value:"The LiveState Type",id:"the-livestate-type",level:2},{value:"Creating a LiveState Object",id:"creating-a-livestate-object",level:2},{value:"Batching",id:"batching",level:2}];function v(e){let t={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["One critical difference between client state and server state is that as client state changes over time, those changes will need to be reflected in your UI. To address this, Relay Resolvers support the ability to be marked as ",(0,a.jsx)(t.code,{children:"@live"}),". Live resolvers are expected to return a ",(0,a.jsx)(t.code,{children:"LiveState"})," shaped object which includes methods which allow Relay to both ",(0,a.jsx)(t.code,{children:"read()"})," the current value and also to ",(0,a.jsx)(t.code,{children:"subscribe()"})," to changes to the value."]}),"\n",(0,a.jsxs)(t.p,{children:["As this value changes over time, Relay will automatically recompute any ",(0,a.jsx)(t.a,{href:"/docs/next/guides/relay-resolvers/derived-fields/",children:"derived fields"})," that depend on this field (including transitive dependencies if the changes cascade), and also efficiently trigger the update of any components/subscribers which have read fields that updated as a result of this change."]}),"\n",(0,a.jsx)(t.h2,{id:"live",children:"@live"}),"\n",(0,a.jsxs)(i.default,{groupId:"resolver",defaultValue:"Docblock",values:(0,l.fbContent)({internal:[{label:"Docblock",value:"Docblock"},{label:"Flow",value:"Flow"}],external:[{label:"Docblock",value:"Docblock"}]}),children:[(0,a.jsxs)(o.default,{value:"Docblock",children:[(0,a.jsxs)(t.p,{children:["To mark a resolver as live, add the ",(0,a.jsx)(t.code,{children:"@live"})," docblock tag to the resolver definition. For example:"]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"import type { LiveState } from 'relay-runtime';\n\n/**\n * @RelayResolver Query.counter: Int\n * @live\n */\nexport function counter(): LiveState<number> {\n  return {\n    read: () => store.getState().counter,\n    subscribe: (callback) => {\n      return store.subscribe(callback);\n    },\n  };\n}\n"})})]}),(0,a.jsx)(o.default,{value:"Flow",children:(0,a.jsxs)(l.FbInternalOnly,{children:[(0,a.jsxs)(t.p,{children:["live is determined by the usage of ",(0,a.jsx)(t.code,{children:"LiveState"})," in the Flow return type"]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"import type { LiveState } from 'relay-runtime';\n\n/**\n * @RelayResolver\n */\nexport function counter(): LiveState<number> {\n  return {\n    read: () => store.getState().counter,\n    subscribe: (callback) => {\n      return store.subscribe(callback);\n    },\n  };\n}\n"})})]})})]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["Both field resolvers and strong model resolvers, which map an ID to a model, may be annotated as ",(0,a.jsx)(t.code,{children:"@live"}),"."]})}),"\n",(0,a.jsx)(t.h2,{id:"the-livestate-type",children:"The LiveState Type"}),"\n",(0,a.jsxs)(t.p,{children:["The return type of a Live Resolver is known as a ",(0,a.jsx)(t.code,{children:"LiveState"}),". It is conceptually similar to an observable or a signal, if you are familiar with those concepts. Unlike an observable, when a ",(0,a.jsx)(t.code,{children:"LiveState"})," notifies its subscriber of an update, it does not include the new value. Instead, the subscriber (Relay) is expected to call ",(0,a.jsx)(t.code,{children:"read()"})," to get the new value."]}),"\n",(0,a.jsx)(t.p,{children:"While over-notification (subscription notifications when the read value has not actually changed) is supported, for performance reasons, it is recommended that the provider of the LiveState value confirms that the value has indeed change before notifying Relay of the change."}),"\n",(0,a.jsx)(t.p,{children:"The type of a LiveState is defined as follows:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"export type LiveState<T> = {\n  /**\n   * Returns the current value of the live state.\n   */\n  read(): T,\n  /**\n   * Subscribes to changes in the live state. The state provider should\n   * call the callback when the value of the live state changes.\n   */\n  subscribe(cb: () => void): () => void,\n};\n"})}),"\n",(0,a.jsx)(t.h2,{id:"creating-a-livestate-object",children:"Creating a LiveState Object"}),"\n",(0,a.jsxs)(t.p,{children:["In most cases, you will want to define a helper function that reads your reactive data store and returns a ",(0,a.jsx)(t.code,{children:"LiveState"})," object. For example, you for a Redux store you might write a wrapper that exposes a ",(0,a.jsx)(t.code,{children:"LiveState"})," for a given selector:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"type Selector<T> = (state: State) => T;\n\nfunction selectorAsLiveState<T>(selector: Selector<T>): LiveState<T> {\n  let currentValue = selector(store.getState());\n  return {\n    read: () => currentValue,\n    subscribe: (cb) => {\n      return store.subscribe(() => {\n        const newValue = selector(store.getState());\n        if (newValue === currentValue) {\n          return;\n        }\n        currentValue = newValue;\n        cb();\n      });\n      return unsubscribe;\n    },\n  };\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"A Live Resolver that uses this helper might look like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"/**\n * @RelayResolver Query.counter: Int\n * @live\n */\nexport function counter(): LiveState<number> {\n  return selectorAsLiveState(getCounter);\n}\n\nfunction getCounter(state) {\n  return state.counter;\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"batching",children:"Batching"}),"\n",(0,a.jsxs)(t.p,{children:["When state changes in your data layer, it's possible that one change could result in notifying many ",(0,a.jsx)(t.code,{children:"@live"})," resolver subscriptions about updates. By default each of these updates will require Relay to do work to determine which components need to be updated. This can lead to significant duplicate work being performed."]}),"\n",(0,a.jsxs)(t.p,{children:["When possible, it is recommended that you batch updates to ",(0,a.jsx)(t.code,{children:"@live"})," resolvers. This can be done by wrapping your state updates in a ",(0,a.jsx)(t.code,{children:"batchLiveStateUpdates()"})," call on your ",(0,a.jsx)(t.code,{children:"RelayStore"})," instance."]}),"\n",(0,a.jsx)(t.p,{children:"A typical use with a Redux store might look like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const store = createStore(reducer);\nconst originalDispatch = store.dispatch;\n\nfunction wrapped(action) {\n  relayStore.batchLiveStateUpdates(() => {\n    originalDispatch(action);\n  })\n}\n\nstore.dispatch = wrapped;\n"})})]})}function p(e={}){let{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(v,{...e})}):v(e)}},57250(e,t,n){n.r(t),n.d(t,{default:()=>s});var r=n(74848);n(96540);var a=n(18215);function s({children:e,hidden:t,className:n}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,a.A)("tabItem_Ymn6",n),hidden:t,children:e})}},78010(e,t,n){n.r(t),n.d(t,{default:()=>x});var r=n(74848),a=n(96540),s=n(18215),l=n(88287),i=n(28584),o=n(99770),c=n(99989),u=n(96629),d=n(80618),h=n(41367);function v(e){return a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){let{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p({value:e,tabValues:t}){return t.some(t=>t.value===e)}var f=n(19863);function b({className:e,block:t,selectedValue:n,selectValue:a,tabValues:l}){let o=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.a_)(),u=e=>{let t=e.currentTarget,r=l[o.indexOf(t)].value;r!==n&&(c(t),a(r))},d=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{let n=o.indexOf(e.currentTarget)+1;t=o[n]??o[0];break}case"ArrowLeft":{let n=o.indexOf(e.currentTarget)-1;t=o[n]??o[o.length-1]}}t?.focus()};return(0,r.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":t},e),children:l.map(({value:e,label:t,attributes:a})=>(0,r.jsx)("li",{role:"tab",tabIndex:n===e?0:-1,"aria-selected":n===e,ref:e=>{o.push(e)},onKeyDown:d,onClick:u,...a,className:(0,s.A)("tabs__item","tabItem_LNqP",a?.className,{"tabs__item--active":n===e}),children:t??e},e))})}function m({lazy:e,children:t,selectedValue:n}){let l=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){let e=l.find(e=>e.props.value===n);return e?(0,a.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,r.jsx)("div",{className:"margin-top--md",children:l.map((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==n}))})}function g(e){let t=function(e){let t,{defaultValue:n,queryString:r=!1,groupId:s}=e,l=function(e){let{values:t,children:n}=e;return(0,a.useMemo)(()=>{let e=t??v(n).map(({props:{value:e,label:t,attributes:n,default:r}})=>({value:e,label:t,attributes:n,default:r})),r=(0,d.XI)(e,(e,t)=>e.value===t.value);if(r.length>0)throw Error(`Docusaurus error: Duplicate values "${r.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`);return e},[t,n])}(e),[i,f]=(0,a.useState)(()=>(function({defaultValue:e,tabValues:t}){if(0===t.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:t}))throw Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}let n=t.find(e=>e.default)??t[0];if(!n)throw Error("Unexpected error: 0 tabValues");return n.value})({defaultValue:n,tabValues:l})),[b,m]=function({queryString:e=!1,groupId:t}){let n=(0,o.W6)(),r=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,u.aZ)(r),(0,a.useCallback)(e=>{if(!r)return;let t=new URLSearchParams(n.location.search);t.set(r,e),n.replace({...n.location,search:t.toString()})},[r,n])]}({queryString:r,groupId:s}),[g,x]=function({groupId:e}){let t=e?`docusaurus.tab.${e}`:null,[n,r]=(0,h.Dv)(t);return[n,(0,a.useCallback)(e=>{t&&r.set(e)},[t,r])]}({groupId:s}),y=p({value:t=b??g,tabValues:l})?t:null;return(0,c.A)(()=>{y&&f(y)},[y]),{selectedValue:i,selectValue:(0,a.useCallback)(e=>{if(!p({value:e,tabValues:l}))throw Error(`Can't select invalid tab value=${e}`);f(e),m(e),x(e)},[m,x,l]),tabValues:l}}(e);return(0,r.jsxs)("div",{className:(0,s.A)(l.G.tabs.container,"tabs-container","tabList__CuJ"),children:[(0,r.jsx)(b,{...t,...e}),(0,r.jsx)(m,{...t,...e})]})}function x(e){let t=(0,f.default)();return(0,r.jsx)(g,{...e,children:v(e.children)},String(t))}},28453(e,t,n){n.d(t,{R:()=>l,x:()=>i});var r=n(96540);let a={},s=r.createContext(a);function l(e){let t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);