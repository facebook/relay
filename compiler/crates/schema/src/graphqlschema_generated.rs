/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// automatically generated by the FlatBuffers compiler by running `flatc --rust graphqlschema.fbs`,
// do not modify

#[allow(unused_imports, dead_code)]
pub mod graphqlschema {
    use std::cmp::Ordering;
    use std::mem;

    use self::flatbuffers::EndianScalar;
    use flatbuffers;

    #[allow(non_camel_case_types)]
    #[repr(i8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum FBConstValueKind {
        Null = 0,
        String = 1,
        Bool = 2,
        Int = 3,
        Float = 4,
        Enum = 5,
        List = 6,
        Object = 7,
    }

    pub const ENUM_MIN_FBCONST_VALUE_KIND: i8 = 0;
    pub const ENUM_MAX_FBCONST_VALUE_KIND: i8 = 7;

    impl<'a> flatbuffers::Follow<'a> for FBConstValueKind {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for FBConstValueKind {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = i8::to_le(self as i8);
            let p = &n as *const i8 as *const FBConstValueKind;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = i8::from_le(self as i8);
            let p = &n as *const i8 as *const FBConstValueKind;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for FBConstValueKind {
        type Output = FBConstValueKind;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<FBConstValueKind>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_FBCONST_VALUE_KIND: [FBConstValueKind; 8] = [
        FBConstValueKind::Null,
        FBConstValueKind::String,
        FBConstValueKind::Bool,
        FBConstValueKind::Int,
        FBConstValueKind::Float,
        FBConstValueKind::Enum,
        FBConstValueKind::List,
        FBConstValueKind::Object,
    ];

    #[allow(non_camel_case_types)]
    pub const ENUM_NAMES_FBCONST_VALUE_KIND: [&str; 8] = [
        "Null", "String", "Bool", "Int", "Float", "Enum", "List", "Object",
    ];

    pub fn enum_name_fbconst_value_kind(e: FBConstValueKind) -> &'static str {
        let index = e as i8;
        ENUM_NAMES_FBCONST_VALUE_KIND[index as usize]
    }

    #[allow(non_camel_case_types)]
    #[repr(i8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum FBTypeKind {
        Scalar = 0,
    }

    pub const ENUM_MIN_FBTYPE_KIND: i8 = 0;
    pub const ENUM_MAX_FBTYPE_KIND: i8 = 0;

    impl<'a> flatbuffers::Follow<'a> for FBTypeKind {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for FBTypeKind {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = i8::to_le(self as i8);
            let p = &n as *const i8 as *const FBTypeKind;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = i8::from_le(self as i8);
            let p = &n as *const i8 as *const FBTypeKind;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for FBTypeKind {
        type Output = FBTypeKind;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<FBTypeKind>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_FBTYPE_KIND: [FBTypeKind; 1] = [FBTypeKind::Scalar];

    #[allow(non_camel_case_types)]
    pub const ENUM_NAMES_FBTYPE_KIND: [&str; 1] = ["Scalar"];

    pub fn enum_name_fbtype_kind(e: FBTypeKind) -> &'static str {
        let index = e as i8;
        ENUM_NAMES_FBTYPE_KIND[index as usize]
    }

    pub enum FBConstValueOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FBConstValue<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FBConstValue<'a> {
        type Inner = FBConstValue<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FBConstValue<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FBConstValue { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FBConstValueArgs<'args>,
        ) -> flatbuffers::WIPOffset<FBConstValue<'bldr>> {
            let mut builder = FBConstValueBuilder::new(_fbb);
            if let Some(x) = args.object_value {
                builder.add_object_value(x);
            }
            if let Some(x) = args.list_value {
                builder.add_list_value(x);
            }
            if let Some(x) = args.enum_value {
                builder.add_enum_value(x);
            }
            if let Some(x) = args.float_value {
                builder.add_float_value(x);
            }
            if let Some(x) = args.int_value {
                builder.add_int_value(x);
            }
            if let Some(x) = args.string_value {
                builder.add_string_value(x);
            }
            builder.add_bool_value(args.bool_value);
            builder.add_kind(args.kind);
            builder.finish()
        }

        pub const VT_KIND: flatbuffers::VOffsetT = 4;
        pub const VT_STRING_VALUE: flatbuffers::VOffsetT = 6;
        pub const VT_BOOL_VALUE: flatbuffers::VOffsetT = 8;
        pub const VT_INT_VALUE: flatbuffers::VOffsetT = 10;
        pub const VT_FLOAT_VALUE: flatbuffers::VOffsetT = 12;
        pub const VT_ENUM_VALUE: flatbuffers::VOffsetT = 14;
        pub const VT_LIST_VALUE: flatbuffers::VOffsetT = 16;
        pub const VT_OBJECT_VALUE: flatbuffers::VOffsetT = 18;

        #[inline]
        pub fn kind(&self) -> FBConstValueKind {
            self._tab
                .get::<FBConstValueKind>(FBConstValue::VT_KIND, Some(FBConstValueKind::Null))
                .unwrap()
        }
        #[inline]
        pub fn string_value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FBConstValue::VT_STRING_VALUE, None)
        }
        #[inline]
        pub fn bool_value(&self) -> bool {
            self._tab
                .get::<bool>(FBConstValue::VT_BOOL_VALUE, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn int_value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FBConstValue::VT_INT_VALUE, None)
        }
        #[inline]
        pub fn float_value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FBConstValue::VT_FLOAT_VALUE, None)
        }
        #[inline]
        pub fn enum_value(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FBConstValue::VT_ENUM_VALUE, None)
        }
        #[inline]
        pub fn list_value(&self) -> Option<FBListValue<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<FBListValue<'a>>>(
                    FBConstValue::VT_LIST_VALUE,
                    None,
                )
        }
        #[inline]
        pub fn object_value(&self) -> Option<FBObjectValue<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<FBObjectValue<'a>>>(
                    FBConstValue::VT_OBJECT_VALUE,
                    None,
                )
        }
    }

    pub struct FBConstValueArgs<'a> {
        pub kind: FBConstValueKind,
        pub string_value: Option<flatbuffers::WIPOffset<&'a str>>,
        pub bool_value: bool,
        pub int_value: Option<flatbuffers::WIPOffset<&'a str>>,
        pub float_value: Option<flatbuffers::WIPOffset<&'a str>>,
        pub enum_value: Option<flatbuffers::WIPOffset<&'a str>>,
        pub list_value: Option<flatbuffers::WIPOffset<FBListValue<'a>>>,
        pub object_value: Option<flatbuffers::WIPOffset<FBObjectValue<'a>>>,
    }
    impl<'a> Default for FBConstValueArgs<'a> {
        #[inline]
        fn default() -> Self {
            FBConstValueArgs {
                kind: FBConstValueKind::Null,
                string_value: None,
                bool_value: false,
                int_value: None,
                float_value: None,
                enum_value: None,
                list_value: None,
                object_value: None,
            }
        }
    }
    pub struct FBConstValueBuilder<'a, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FBConstValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_kind(&mut self, kind: FBConstValueKind) {
            self.fbb_.push_slot::<FBConstValueKind>(
                FBConstValue::VT_KIND,
                kind,
                FBConstValueKind::Null,
            );
        }
        #[inline]
        pub fn add_string_value(&mut self, string_value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                FBConstValue::VT_STRING_VALUE,
                string_value,
            );
        }
        #[inline]
        pub fn add_bool_value(&mut self, bool_value: bool) {
            self.fbb_
                .push_slot::<bool>(FBConstValue::VT_BOOL_VALUE, bool_value, false);
        }
        #[inline]
        pub fn add_int_value(&mut self, int_value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                FBConstValue::VT_INT_VALUE,
                int_value,
            );
        }
        #[inline]
        pub fn add_float_value(&mut self, float_value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                FBConstValue::VT_FLOAT_VALUE,
                float_value,
            );
        }
        #[inline]
        pub fn add_enum_value(&mut self, enum_value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                FBConstValue::VT_ENUM_VALUE,
                enum_value,
            );
        }
        #[inline]
        pub fn add_list_value(&mut self, list_value: flatbuffers::WIPOffset<FBListValue<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<FBListValue<'_>>>(
                    FBConstValue::VT_LIST_VALUE,
                    list_value,
                );
        }
        #[inline]
        pub fn add_object_value(
            &mut self,
            object_value: flatbuffers::WIPOffset<FBObjectValue<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<FBObjectValue<'_>>>(
                    FBConstValue::VT_OBJECT_VALUE,
                    object_value,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FBConstValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FBConstValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FBConstValue<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FBListValueOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FBListValue<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FBListValue<'a> {
        type Inner = FBListValue<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FBListValue<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FBListValue { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FBListValueArgs<'args>,
        ) -> flatbuffers::WIPOffset<FBListValue<'bldr>> {
            let mut builder = FBListValueBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBConstValue<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBConstValue<'a>>>,
            >>(FBListValue::VT_VALUES, None)
        }
    }

    pub struct FBListValueArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBConstValue<'a>>>,
            >,
        >,
    }
    impl<'a> Default for FBListValueArgs<'a> {
        #[inline]
        fn default() -> Self {
            FBListValueArgs { values: None }
        }
    }
    pub struct FBListValueBuilder<'a, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FBListValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<FBConstValue<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FBListValue::VT_VALUES, values);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBListValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FBListValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FBListValue<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FBObjectFieldOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FBObjectField<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FBObjectField<'a> {
        type Inner = FBObjectField<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FBObjectField<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FBObjectField { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FBObjectFieldArgs<'args>,
        ) -> flatbuffers::WIPOffset<FBObjectField<'bldr>> {
            let mut builder = FBObjectFieldBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FBObjectField::VT_NAME, None)
        }
        #[inline]
        pub fn value(&self) -> Option<FBConstValue<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<FBConstValue<'a>>>(
                    FBObjectField::VT_VALUE,
                    None,
                )
        }
    }

    pub struct FBObjectFieldArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: Option<flatbuffers::WIPOffset<FBConstValue<'a>>>,
    }
    impl<'a> Default for FBObjectFieldArgs<'a> {
        #[inline]
        fn default() -> Self {
            FBObjectFieldArgs {
                name: None,
                value: None,
            }
        }
    }
    pub struct FBObjectFieldBuilder<'a, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FBObjectFieldBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FBObjectField::VT_NAME, name);
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<FBConstValue<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<FBConstValue<'_>>>(
                    FBObjectField::VT_VALUE,
                    value,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FBObjectFieldBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FBObjectFieldBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FBObjectField<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FBObjectValueOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FBObjectValue<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FBObjectValue<'a> {
        type Inner = FBObjectValue<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FBObjectValue<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FBObjectValue { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FBObjectValueArgs<'args>,
        ) -> flatbuffers::WIPOffset<FBObjectValue<'bldr>> {
            let mut builder = FBObjectValueBuilder::new(_fbb);
            if let Some(x) = args.fields {
                builder.add_fields(x);
            }
            builder.finish()
        }

        pub const VT_FIELDS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn fields(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBObjectField<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBObjectField<'a>>>,
            >>(FBObjectValue::VT_FIELDS, None)
        }
    }

    pub struct FBObjectValueArgs<'a> {
        pub fields: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBObjectField<'a>>>,
            >,
        >,
    }
    impl<'a> Default for FBObjectValueArgs<'a> {
        #[inline]
        fn default() -> Self {
            FBObjectValueArgs { fields: None }
        }
    }
    pub struct FBObjectValueBuilder<'a, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FBObjectValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_fields(
            &mut self,
            fields: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<FBObjectField<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FBObjectValue::VT_FIELDS, fields);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FBObjectValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FBObjectValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FBObjectValue<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FBTypeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FBType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FBType<'a> {
        type Inner = FBType<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FBType<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FBType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FBTypeArgs,
        ) -> flatbuffers::WIPOffset<FBType<'bldr>> {
            let mut builder = FBTypeBuilder::new(_fbb);
            builder.add_scalar_id(args.scalar_id);
            builder.add_kind(args.kind);
            builder.finish()
        }

        pub const VT_KIND: flatbuffers::VOffsetT = 4;
        pub const VT_SCALAR_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn kind(&self) -> FBTypeKind {
            self._tab
                .get::<FBTypeKind>(FBType::VT_KIND, Some(FBTypeKind::Scalar))
                .unwrap()
        }
        #[inline]
        pub fn scalar_id(&self) -> u32 {
            self._tab.get::<u32>(FBType::VT_SCALAR_ID, Some(0)).unwrap()
        }
    }

    pub struct FBTypeArgs {
        pub kind: FBTypeKind,
        pub scalar_id: u32,
    }
    impl<'a> Default for FBTypeArgs {
        #[inline]
        fn default() -> Self {
            FBTypeArgs {
                kind: FBTypeKind::Scalar,
                scalar_id: 0,
            }
        }
    }
    pub struct FBTypeBuilder<'a, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FBTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_kind(&mut self, kind: FBTypeKind) {
            self.fbb_
                .push_slot::<FBTypeKind>(FBType::VT_KIND, kind, FBTypeKind::Scalar);
        }
        #[inline]
        pub fn add_scalar_id(&mut self, scalar_id: u32) {
            self.fbb_
                .push_slot::<u32>(FBType::VT_SCALAR_ID, scalar_id, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FBTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FBType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FBArgumentValueOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FBArgumentValue<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FBArgumentValue<'a> {
        type Inner = FBArgumentValue<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FBArgumentValue<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FBArgumentValue { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FBArgumentValueArgs<'args>,
        ) -> flatbuffers::WIPOffset<FBArgumentValue<'bldr>> {
            let mut builder = FBArgumentValueBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FBArgumentValue::VT_NAME, None)
        }
        #[inline]
        pub fn value(&self) -> Option<FBConstValue<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<FBConstValue<'a>>>(
                    FBArgumentValue::VT_VALUE,
                    None,
                )
        }
    }

    pub struct FBArgumentValueArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: Option<flatbuffers::WIPOffset<FBConstValue<'a>>>,
    }
    impl<'a> Default for FBArgumentValueArgs<'a> {
        #[inline]
        fn default() -> Self {
            FBArgumentValueArgs {
                name: None,
                value: None,
            }
        }
    }
    pub struct FBArgumentValueBuilder<'a, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FBArgumentValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FBArgumentValue::VT_NAME, name);
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<FBConstValue<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<FBConstValue<'_>>>(
                    FBArgumentValue::VT_VALUE,
                    value,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FBArgumentValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FBArgumentValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FBArgumentValue<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FBDirectiveValueOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FBDirectiveValue<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FBDirectiveValue<'a> {
        type Inner = FBDirectiveValue<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FBDirectiveValue<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FBDirectiveValue { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FBDirectiveValueArgs<'args>,
        ) -> flatbuffers::WIPOffset<FBDirectiveValue<'bldr>> {
            let mut builder = FBDirectiveValueBuilder::new(_fbb);
            if let Some(x) = args.arguments {
                builder.add_arguments(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_ARGUMENTS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FBDirectiveValue::VT_NAME, None)
        }
        #[inline]
        pub fn arguments(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBArgumentValue<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBArgumentValue<'a>>>,
            >>(FBDirectiveValue::VT_ARGUMENTS, None)
        }
    }

    pub struct FBDirectiveValueArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub arguments: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBArgumentValue<'a>>>,
            >,
        >,
    }
    impl<'a> Default for FBDirectiveValueArgs<'a> {
        #[inline]
        fn default() -> Self {
            FBDirectiveValueArgs {
                name: None,
                arguments: None,
            }
        }
    }
    pub struct FBDirectiveValueBuilder<'a, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FBDirectiveValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FBDirectiveValue::VT_NAME, name);
        }
        #[inline]
        pub fn add_arguments(
            &mut self,
            arguments: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<FBArgumentValue<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                FBDirectiveValue::VT_ARGUMENTS,
                arguments,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FBDirectiveValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FBDirectiveValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FBDirectiveValue<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FBScalarOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FBScalar<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FBScalar<'a> {
        type Inner = FBScalar<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FBScalar<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FBScalar { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FBScalarArgs<'args>,
        ) -> flatbuffers::WIPOffset<FBScalar<'bldr>> {
            let mut builder = FBScalarBuilder::new(_fbb);
            if let Some(x) = args.directives {
                builder.add_directives(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_is_extension(args.is_extension);
            builder.finish()
        }

        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_IS_EXTENSION: flatbuffers::VOffsetT = 6;
        pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FBScalar::VT_NAME, None)
        }
        #[inline]
        pub fn is_extension(&self) -> bool {
            self._tab
                .get::<bool>(FBScalar::VT_IS_EXTENSION, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn directives(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>>
        {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>,
            >>(FBScalar::VT_DIRECTIVES, None)
        }
    }

    pub struct FBScalarArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub is_extension: bool,
        pub directives: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBDirectiveValue<'a>>>,
            >,
        >,
    }
    impl<'a> Default for FBScalarArgs<'a> {
        #[inline]
        fn default() -> Self {
            FBScalarArgs {
                name: None,
                is_extension: false,
                directives: None,
            }
        }
    }
    pub struct FBScalarBuilder<'a, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FBScalarBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FBScalar::VT_NAME, name);
        }
        #[inline]
        pub fn add_is_extension(&mut self, is_extension: bool) {
            self.fbb_
                .push_slot::<bool>(FBScalar::VT_IS_EXTENSION, is_extension, false);
        }
        #[inline]
        pub fn add_directives(
            &mut self,
            directives: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<FBDirectiveValue<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FBScalar::VT_DIRECTIVES, directives);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBScalarBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FBScalarBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FBScalar<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FBTypeMapOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FBTypeMap<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FBTypeMap<'a> {
        type Inner = FBTypeMap<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FBTypeMap<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FBTypeMap { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FBTypeMapArgs<'args>,
        ) -> flatbuffers::WIPOffset<FBTypeMap<'bldr>> {
            let mut builder = FBTypeMapBuilder::new(_fbb);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn name(&self) -> &'a str {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FBTypeMap::VT_NAME, None)
                .unwrap()
        }
        #[inline]
        pub fn key_compare_less_than(&self, o: &FBTypeMap<'_>) -> bool {
            self.name() < o.name()
        }

        #[inline]
        pub fn key_compare_with_value(&self, val: &str) -> ::std::cmp::Ordering {
            let key = self.name();
            key.cmp(&val)
        }
        #[inline]
        pub fn value(&self) -> Option<FBType<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<FBType<'a>>>(FBTypeMap::VT_VALUE, None)
        }
    }

    pub struct FBTypeMapArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: Option<flatbuffers::WIPOffset<FBType<'a>>>,
    }
    impl<'a> Default for FBTypeMapArgs<'a> {
        #[inline]
        fn default() -> Self {
            FBTypeMapArgs {
                name: None, // required field
                value: None,
            }
        }
    }
    pub struct FBTypeMapBuilder<'a, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FBTypeMapBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FBTypeMap::VT_NAME, name);
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<FBType<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<FBType<'_>>>(FBTypeMap::VT_VALUE, value);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBTypeMapBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FBTypeMapBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FBTypeMap<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, FBTypeMap::VT_NAME, "name");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum FBSchemaOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct FBSchema<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FBSchema<'a> {
        type Inner = FBSchema<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> FBSchema<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FBSchema { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FBSchemaArgs<'args>,
        ) -> flatbuffers::WIPOffset<FBSchema<'bldr>> {
            let mut builder = FBSchemaBuilder::new(_fbb);
            if let Some(x) = args.scalars {
                builder.add_scalars(x);
            }
            if let Some(x) = args.types {
                builder.add_types(x);
            }
            builder.finish()
        }

        pub const VT_TYPES: flatbuffers::VOffsetT = 4;
        pub const VT_SCALARS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn types(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBTypeMap<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBTypeMap<'a>>>,
            >>(FBSchema::VT_TYPES, None)
        }
        #[inline]
        pub fn scalars(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBScalar<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FBScalar<'a>>>,
            >>(FBSchema::VT_SCALARS, None)
        }
    }

    pub struct FBSchemaArgs<'a> {
        pub types: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBTypeMap<'a>>>,
            >,
        >,
        pub scalars: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FBScalar<'a>>>,
            >,
        >,
    }
    impl<'a> Default for FBSchemaArgs<'a> {
        #[inline]
        fn default() -> Self {
            FBSchemaArgs {
                types: None,
                scalars: None,
            }
        }
    }
    pub struct FBSchemaBuilder<'a, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FBSchemaBuilder<'a, 'b> {
        #[inline]
        pub fn add_types(
            &mut self,
            types: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<FBTypeMap<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FBSchema::VT_TYPES, types);
        }
        #[inline]
        pub fn add_scalars(
            &mut self,
            scalars: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<FBScalar<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(FBSchema::VT_SCALARS, scalars);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FBSchemaBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FBSchemaBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FBSchema<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    #[inline]
    pub fn get_root_as_fbschema<'a>(buf: &'a [u8]) -> FBSchema<'a> {
        flatbuffers::get_root::<FBSchema<'a>>(buf)
    }

    #[inline]
    pub fn get_size_prefixed_root_as_fbschema<'a>(buf: &'a [u8]) -> FBSchema<'a> {
        flatbuffers::get_size_prefixed_root::<FBSchema<'a>>(buf)
    }

    #[inline]
    pub fn finish_fbschema_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<FBSchema<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_fbschema_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<FBSchema<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod graphqlschema
