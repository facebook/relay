// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Snapshot tests for useAnyDirectory matches expected output: refetchable-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment RefetchableFragment on Node
  @refetchable(queryName: "RefetchableFragmentQuery") {
  id
  fragAndField: profilePicture {
    uri
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// RefetchableFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type RefetchableFragment$ref: FragmentReference;
declare export opaque type RefetchableFragment$fragmentType: RefetchableFragment$ref;
export type RefetchableFragment = {|
  +id: string,
  +fragAndField: ?{|
    +uri: ?string
  |},
  +$refType: RefetchableFragment$ref,
|};
export type RefetchableFragment$data = RefetchableFragment;
export type RefetchableFragment$key = {
  +$data?: RefetchableFragment$data,
  +$fragmentRefs: RefetchableFragment$ref,
  ...
};

// RefetchableFragmentQuery.graphql
type RefetchableFragment$ref = any;
export type RefetchableFragmentQueryVariables = {|
  id: string
|};
export type RefetchableFragmentQueryResponse = {|
  +node: ?{|
    +$fragmentRefs: RefetchableFragment$ref
  |}
|};
export type RefetchableFragmentQuery = {|
  variables: RefetchableFragmentQueryVariables,
  response: RefetchableFragmentQueryResponse,
|};
`;

exports[`Snapshot tests for useHaste matches expected output: conditional.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment ConditionField on Node {
  id @include(if: $condition)
}

fragment NestedCondition on Node {
  ... @include(if: $condition) {
    id
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ConditionField.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type ConditionField$ref: FragmentReference;
declare export opaque type ConditionField$fragmentType: ConditionField$ref;
export type ConditionField = {|
  +id?: string,
  +$refType: ConditionField$ref,
|};
export type ConditionField$data = ConditionField;
export type ConditionField$key = {
  +$data?: ConditionField$data,
  +$fragmentRefs: ConditionField$ref,
  ...
};

// NestedCondition.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type NestedCondition$ref: FragmentReference;
declare export opaque type NestedCondition$fragmentType: NestedCondition$ref;
export type NestedCondition = {|
  +id?: string,
  +$refType: NestedCondition$ref,
|};
export type NestedCondition$data = NestedCondition;
export type NestedCondition$key = {
  +$data?: NestedCondition$data,
  +$fragmentRefs: NestedCondition$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: fragment-spread.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment FragmentSpread on Node {
  id
  ...OtherFragment
  justFrag: profilePicture {
    ...PictureFragment
  }
  fragAndField: profilePicture {
    uri
    ...PictureFragment
  }
  ... on User {
    ...UserFrag1
    ...UserFrag2
  }
}

fragment ConcreateTypes on Viewer {
  actor {
    __typename
    ... on Page {
      id
      ...PageFragment
    }
    ... on User {
      name
    }
  }
}

fragment PictureFragment on Image {
  __typename
}

fragment OtherFragment on Node {
  __typename
}

fragment PageFragment on Page {
  __typename
}

fragment UserFrag1 on User {
  __typename
}

fragment UserFrag2 on User {
  __typename
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// FragmentSpread.graphql
import type { OtherFragment$ref } from "OtherFragment.graphql";
import type { PictureFragment$ref } from "PictureFragment.graphql";
import type { UserFrag1$ref } from "UserFrag1.graphql";
import type { UserFrag2$ref } from "UserFrag2.graphql";
import type { FragmentReference } from "relay-runtime";
declare export opaque type FragmentSpread$ref: FragmentReference;
declare export opaque type FragmentSpread$fragmentType: FragmentSpread$ref;
export type FragmentSpread = {|
  +id: string,
  +justFrag: ?{|
    +$fragmentRefs: PictureFragment$ref
  |},
  +fragAndField: ?{|
    +uri: ?string,
    +$fragmentRefs: PictureFragment$ref,
  |},
  +$fragmentRefs: OtherFragment$ref & UserFrag1$ref & UserFrag2$ref,
  +$refType: FragmentSpread$ref,
|};
export type FragmentSpread$data = FragmentSpread;
export type FragmentSpread$key = {
  +$data?: FragmentSpread$data,
  +$fragmentRefs: FragmentSpread$ref,
  ...
};

// ConcreateTypes.graphql
import type { PageFragment$ref } from "PageFragment.graphql";
import type { FragmentReference } from "relay-runtime";
declare export opaque type ConcreateTypes$ref: FragmentReference;
declare export opaque type ConcreateTypes$fragmentType: ConcreateTypes$ref;
export type ConcreateTypes = {|
  +actor: ?({|
    +__typename: "Page",
    +id: string,
    +$fragmentRefs: PageFragment$ref,
  |} | {|
    +__typename: "User",
    +name: ?string,
  |} | {|
    // This will never be '%other', but we need some
    // value in case none of the concrete values match.
    +__typename: "%other"
  |}),
  +$refType: ConcreateTypes$ref,
|};
export type ConcreateTypes$data = ConcreateTypes;
export type ConcreateTypes$key = {
  +$data?: ConcreateTypes$data,
  +$fragmentRefs: ConcreateTypes$ref,
  ...
};

// PictureFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type PictureFragment$ref: FragmentReference;
declare export opaque type PictureFragment$fragmentType: PictureFragment$ref;
export type PictureFragment = {|
  +__typename: "Image",
  +$refType: PictureFragment$ref,
|} | {|
  // This will never be '%other', but we need some
  // value in case none of the concrete values match.
  +__typename: "%other",
  +$refType: PictureFragment$ref,
|};
export type PictureFragment$data = PictureFragment;
export type PictureFragment$key = {
  +$data?: PictureFragment$data,
  +$fragmentRefs: PictureFragment$ref,
  ...
};

// OtherFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type OtherFragment$ref: FragmentReference;
declare export opaque type OtherFragment$fragmentType: OtherFragment$ref;
export type OtherFragment = {|
  +__typename: string,
  +$refType: OtherFragment$ref,
|};
export type OtherFragment$data = OtherFragment;
export type OtherFragment$key = {
  +$data?: OtherFragment$data,
  +$fragmentRefs: OtherFragment$ref,
  ...
};

// PageFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type PageFragment$ref: FragmentReference;
declare export opaque type PageFragment$fragmentType: PageFragment$ref;
export type PageFragment = {|
  +__typename: "Page",
  +$refType: PageFragment$ref,
|} | {|
  // This will never be '%other', but we need some
  // value in case none of the concrete values match.
  +__typename: "%other",
  +$refType: PageFragment$ref,
|};
export type PageFragment$data = PageFragment;
export type PageFragment$key = {
  +$data?: PageFragment$data,
  +$fragmentRefs: PageFragment$ref,
  ...
};

// UserFrag1.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type UserFrag1$ref: FragmentReference;
declare export opaque type UserFrag1$fragmentType: UserFrag1$ref;
export type UserFrag1 = {|
  +__typename: "User",
  +$refType: UserFrag1$ref,
|} | {|
  // This will never be '%other', but we need some
  // value in case none of the concrete values match.
  +__typename: "%other",
  +$refType: UserFrag1$ref,
|};
export type UserFrag1$data = UserFrag1;
export type UserFrag1$key = {
  +$data?: UserFrag1$data,
  +$fragmentRefs: UserFrag1$ref,
  ...
};

// UserFrag2.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type UserFrag2$ref: FragmentReference;
declare export opaque type UserFrag2$fragmentType: UserFrag2$ref;
export type UserFrag2 = {|
  +__typename: "User",
  +$refType: UserFrag2$ref,
|} | {|
  // This will never be '%other', but we need some
  // value in case none of the concrete values match.
  +__typename: "%other",
  +$refType: UserFrag2$ref,
|};
export type UserFrag2$data = UserFrag2;
export type UserFrag2$key = {
  +$data?: UserFrag2$data,
  +$fragmentRefs: UserFrag2$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: inline-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment InlineFragment on Node {
  id
  ... on Actor {
    id
    name
  }
  ... on User {
    message {
      text
    }
  }
}

fragment InlineFragmentWithOverlappingFields on Actor {
  ... on User {
    hometown {
      id
      name
    }
  }
  ... on Page {
    name
    hometown {
      id
      message {
        text
      }
    }
  }
}

fragment InlineFragmentConditionalID on Node {
  ... on Actor {
    id # nullable since it's conditional
    name
  }
}

fragment InlineFragmentKitchenSink on Story {
  actor {
    id
    profilePicture {
      uri
    }
    ... on User {
      id
      name
      ...SomeFragment
      profilePicture {
        width
      }
    }
    ... on Page {
      profilePicture {
        uri
        height
      }
    }
  }
}

fragment SomeFragment on User {
  __typename
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// InlineFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type InlineFragment$ref: FragmentReference;
declare export opaque type InlineFragment$fragmentType: InlineFragment$ref;
export type InlineFragment = {|
  +id: string,
  +name?: ?string,
  +message?: ?{|
    +text: ?string
  |},
  +$refType: InlineFragment$ref,
|};
export type InlineFragment$data = InlineFragment;
export type InlineFragment$key = {
  +$data?: InlineFragment$data,
  +$fragmentRefs: InlineFragment$ref,
  ...
};

// InlineFragmentWithOverlappingFields.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type InlineFragmentWithOverlappingFields$ref: FragmentReference;
declare export opaque type InlineFragmentWithOverlappingFields$fragmentType: InlineFragmentWithOverlappingFields$ref;
export type InlineFragmentWithOverlappingFields = {|
  +hometown?: ?{|
    +id: string,
    +name: ?string,
    +message?: ?{|
      +text: ?string
    |},
  |},
  +name?: ?string,
  +$refType: InlineFragmentWithOverlappingFields$ref,
|};
export type InlineFragmentWithOverlappingFields$data = InlineFragmentWithOverlappingFields;
export type InlineFragmentWithOverlappingFields$key = {
  +$data?: InlineFragmentWithOverlappingFields$data,
  +$fragmentRefs: InlineFragmentWithOverlappingFields$ref,
  ...
};

// InlineFragmentConditionalID.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type InlineFragmentConditionalID$ref: FragmentReference;
declare export opaque type InlineFragmentConditionalID$fragmentType: InlineFragmentConditionalID$ref;
export type InlineFragmentConditionalID = {|
  +id?: string,
  +name?: ?string,
  +$refType: InlineFragmentConditionalID$ref,
|};
export type InlineFragmentConditionalID$data = InlineFragmentConditionalID;
export type InlineFragmentConditionalID$key = {
  +$data?: InlineFragmentConditionalID$data,
  +$fragmentRefs: InlineFragmentConditionalID$ref,
  ...
};

// InlineFragmentKitchenSink.graphql
import type { SomeFragment$ref } from "SomeFragment.graphql";
import type { FragmentReference } from "relay-runtime";
declare export opaque type InlineFragmentKitchenSink$ref: FragmentReference;
declare export opaque type InlineFragmentKitchenSink$fragmentType: InlineFragmentKitchenSink$ref;
export type InlineFragmentKitchenSink = {|
  +actor: ?{|
    +id: string,
    +profilePicture: ?{|
      +uri: ?string,
      +width?: ?number,
      +height?: ?number,
    |},
    +name?: ?string,
    +$fragmentRefs: SomeFragment$ref,
  |},
  +$refType: InlineFragmentKitchenSink$ref,
|};
export type InlineFragmentKitchenSink$data = InlineFragmentKitchenSink;
export type InlineFragmentKitchenSink$key = {
  +$data?: InlineFragmentKitchenSink$data,
  +$fragmentRefs: InlineFragmentKitchenSink$ref,
  ...
};

// SomeFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type SomeFragment$ref: FragmentReference;
declare export opaque type SomeFragment$fragmentType: SomeFragment$ref;
export type SomeFragment = {|
  +__typename: "User",
  +$refType: SomeFragment$ref,
|} | {|
  // This will never be '%other', but we need some
  // value in case none of the concrete values match.
  +__typename: "%other",
  +$refType: SomeFragment$ref,
|};
export type SomeFragment$data = SomeFragment;
export type SomeFragment$key = {
  +$data?: SomeFragment$data,
  +$fragmentRefs: SomeFragment$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: linked-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment LinkedField on User {
  profilePicture {
    uri
    width
    height
  }
  hometown {
    # object
    id
    profilePicture {
      uri
    }
  }
  actor {
    # interface
    id
  }
}

query UnionTypeTest {
  neverNode {
    __typename
    ... on FakeNode {
      id
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// LinkedField.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type LinkedField$ref: FragmentReference;
declare export opaque type LinkedField$fragmentType: LinkedField$ref;
export type LinkedField = {|
  +profilePicture: ?{|
    +uri: ?string,
    +width: ?number,
    +height: ?number,
  |},
  +hometown: ?{|
    +id: string,
    +profilePicture: ?{|
      +uri: ?string
    |},
  |},
  +actor: ?{|
    +id: string
  |},
  +$refType: LinkedField$ref,
|};
export type LinkedField$data = LinkedField;
export type LinkedField$key = {
  +$data?: LinkedField$data,
  +$fragmentRefs: LinkedField$ref,
  ...
};

// UnionTypeTest.graphql
export type UnionTypeTestVariables = {||};
export type UnionTypeTestResponse = {|
  +neverNode: ?({|
    +__typename: "FakeNode",
    +id: string,
  |} | {|
    // This will never be '%other', but we need some
    // value in case none of the concrete values match.
    +__typename: "%other"
  |})
|};
export type UnionTypeTest = {|
  variables: UnionTypeTestVariables,
  response: UnionTypeTestResponse,
|};
`;

exports[`Snapshot tests for useHaste matches expected output: match-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// NameRendererFragment.graphql
import type { MarkdownUserNameRenderer_name$ref } from "MarkdownUserNameRenderer_name.graphql";
import type { PlainUserNameRenderer_name$ref } from "PlainUserNameRenderer_name.graphql";
import type { FragmentReference } from "relay-runtime";
declare export opaque type NameRendererFragment$ref: FragmentReference;
declare export opaque type NameRendererFragment$fragmentType: NameRendererFragment$ref;
export type NameRendererFragment = {|
  +id: string,
  +nameRenderer: ?{|
    +__fragmentPropName?: ?string,
    +__module_component?: ?string,
    +$fragmentRefs: PlainUserNameRenderer_name$ref & MarkdownUserNameRenderer_name$ref,
  |},
  +$refType: NameRendererFragment$ref,
|};
export type NameRendererFragment$data = NameRendererFragment;
export type NameRendererFragment$key = {
  +$data?: NameRendererFragment$data,
  +$fragmentRefs: NameRendererFragment$ref,
  ...
};

// PlainUserNameRenderer_name.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type PlainUserNameRenderer_name$ref: FragmentReference;
declare export opaque type PlainUserNameRenderer_name$fragmentType: PlainUserNameRenderer_name$ref;
export type PlainUserNameRenderer_name = {|
  +plaintext: ?string,
  +data: ?{|
    +text: ?string
  |},
  +$refType: PlainUserNameRenderer_name$ref,
|};
export type PlainUserNameRenderer_name$data = PlainUserNameRenderer_name;
export type PlainUserNameRenderer_name$key = {
  +$data?: PlainUserNameRenderer_name$data,
  +$fragmentRefs: PlainUserNameRenderer_name$ref,
  ...
};

// MarkdownUserNameRenderer_name.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type MarkdownUserNameRenderer_name$ref: FragmentReference;
declare export opaque type MarkdownUserNameRenderer_name$fragmentType: MarkdownUserNameRenderer_name$ref;
export type MarkdownUserNameRenderer_name = {|
  +markdown: ?string,
  +data: ?{|
    +markup: ?string
  |},
  +$refType: MarkdownUserNameRenderer_name$ref,
|};
export type MarkdownUserNameRenderer_name$data = MarkdownUserNameRenderer_name;
export type MarkdownUserNameRenderer_name$key = {
  +$data?: MarkdownUserNameRenderer_name$data,
  +$fragmentRefs: MarkdownUserNameRenderer_name$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: match-field-in-query.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query NameRendererQuery {
  me {
    nameRenderer @match {
      ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
      ...MarkdownUserNameRenderer_name
        @module(name: "MarkdownUserNameRenderer.react")
    }
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// NameRendererQuery.graphql
import type { MarkdownUserNameRenderer_name$ref } from "MarkdownUserNameRenderer_name.graphql";
import type { PlainUserNameRenderer_name$ref } from "PlainUserNameRenderer_name.graphql";
export type NameRendererQueryVariables = {||};
export type NameRendererQueryResponse = {|
  +me: ?{|
    +nameRenderer: ?{|
      +__fragmentPropName?: ?string,
      +__module_component?: ?string,
      +$fragmentRefs: PlainUserNameRenderer_name$ref & MarkdownUserNameRenderer_name$ref,
    |}
  |}
|};
export type NameRendererQuery = {|
  variables: NameRendererQueryVariables,
  response: NameRendererQueryResponse,
|};

// PlainUserNameRenderer_name.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type PlainUserNameRenderer_name$ref: FragmentReference;
declare export opaque type PlainUserNameRenderer_name$fragmentType: PlainUserNameRenderer_name$ref;
export type PlainUserNameRenderer_name = {|
  +plaintext: ?string,
  +data: ?{|
    +text: ?string
  |},
  +$refType: PlainUserNameRenderer_name$ref,
|};
export type PlainUserNameRenderer_name$data = PlainUserNameRenderer_name;
export type PlainUserNameRenderer_name$key = {
  +$data?: PlainUserNameRenderer_name$data,
  +$fragmentRefs: PlainUserNameRenderer_name$ref,
  ...
};

// MarkdownUserNameRenderer_name.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type MarkdownUserNameRenderer_name$ref: FragmentReference;
declare export opaque type MarkdownUserNameRenderer_name$fragmentType: MarkdownUserNameRenderer_name$ref;
export type MarkdownUserNameRenderer_name = {|
  +markdown: ?string,
  +data: ?{|
    +markup: ?string
  |},
  +$refType: MarkdownUserNameRenderer_name$ref,
|};
export type MarkdownUserNameRenderer_name$data = MarkdownUserNameRenderer_name;
export type MarkdownUserNameRenderer_name$key = {
  +$data?: MarkdownUserNameRenderer_name$data,
  +$fragmentRefs: MarkdownUserNameRenderer_name$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: mutaion-with-client-extension.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation Test($input: UpdateAllSeenStateInput) @raw_response_type {
  viewerNotificationsUpdateAllSeenState(input: $input) {
    stories {
      foos {
        bar
      }
    }
  }
}

extend type Story {
  foos: [Foo]
}

type Foo {
  bar: String
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// Test.graphql
export type UpdateAllSeenStateInput = {|
  clientMutationId?: ?string,
  storyIds?: ?$ReadOnlyArray<?string>,
|};
export type TestVariables = {|
  input?: ?UpdateAllSeenStateInput
|};
export type TestResponse = {|
  +viewerNotificationsUpdateAllSeenState: ?{|
    +stories: ?$ReadOnlyArray<?{|
      +foos: ?$ReadOnlyArray<?{|
        +bar: ?string
      |}>
    |}>
  |}
|};
export type TestRawResponse = {|
  +viewerNotificationsUpdateAllSeenState: ?{|
    +stories: ?$ReadOnlyArray<?{|
      +id: ?string,
      +foos?: ?$ReadOnlyArray<?{|
        +bar: ?string
      |}>,
    |}>
  |}
|};
export type Test = {|
  variables: TestVariables,
  response: TestResponse,
  rawResponse: TestRawResponse,
|};
`;

exports[`Snapshot tests for useHaste matches expected output: mutaion-with-response-on-inline-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation TestMutation($input: CommentCreateInput!) @raw_response_type {
  commentCreate(input: $input) {
    viewer {
      actor {
        ...InlineFragmentWithOverlappingFields
      }
    }
  }
}

fragment InlineFragmentWithOverlappingFields on Actor {
  ... on User {
    hometown {
      id
      name
    }
  }
  ... on Page {
    name
    hometown {
      id
      message {
        text
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TestMutation.graphql
import type { InlineFragmentWithOverlappingFields$ref } from "InlineFragmentWithOverlappingFields.graphql";
export type CommentCreateInput = {|
  clientMutationId?: ?string,
  feedbackId?: ?string,
  feedback?: ?CommentfeedbackFeedback,
|};
export type CommentfeedbackFeedback = {|
  comment?: ?FeedbackcommentComment
|};
export type FeedbackcommentComment = {|
  feedback?: ?CommentfeedbackFeedback
|};
export type TestMutationVariables = {|
  input: CommentCreateInput
|};
export type TestMutationResponse = {|
  +commentCreate: ?{|
    +viewer: ?{|
      +actor: ?{|
        +$fragmentRefs: InlineFragmentWithOverlappingFields$ref
      |}
    |}
  |}
|};
export type TestMutationRawResponse = {|
  +commentCreate: ?{|
    +viewer: ?{|
      +actor: ?({|
        +__typename: "User",
        +id: ?string,
        +hometown: ?{|
          +id: string,
          +name: ?string,
        |},
      |} | {|
        +__typename: "Page",
        +id: ?string,
        +name: ?string,
        +hometown: ?{|
          +id: string,
          +message: ?{|
            +text: ?string
          |},
        |},
      |} | {|
        +__typename: ?string,
        +id: ?string,
      |})
    |}
  |}
|};
export type TestMutation = {|
  variables: TestMutationVariables,
  response: TestMutationResponse,
  rawResponse: TestMutationRawResponse,
|};

// InlineFragmentWithOverlappingFields.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type InlineFragmentWithOverlappingFields$ref: FragmentReference;
declare export opaque type InlineFragmentWithOverlappingFields$fragmentType: InlineFragmentWithOverlappingFields$ref;
export type InlineFragmentWithOverlappingFields = {|
  +hometown?: ?{|
    +id: string,
    +name: ?string,
    +message?: ?{|
      +text: ?string
    |},
  |},
  +name?: ?string,
  +$refType: InlineFragmentWithOverlappingFields$ref,
|};
export type InlineFragmentWithOverlappingFields$data = InlineFragmentWithOverlappingFields;
export type InlineFragmentWithOverlappingFields$key = {
  +$data?: InlineFragmentWithOverlappingFields$data,
  +$fragmentRefs: InlineFragmentWithOverlappingFields$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: mutation.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) {
  commentCreate(input: $input) {
    comment {
      id
      name
      friends(first: $first, orderby: $orderBy) {
        count
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// CommentCreateMutation.graphql
export type CommentCreateInput = {|
  clientMutationId?: ?string,
  feedbackId?: ?string,
  feedback?: ?CommentfeedbackFeedback,
|};
export type CommentfeedbackFeedback = {|
  comment?: ?FeedbackcommentComment
|};
export type FeedbackcommentComment = {|
  feedback?: ?CommentfeedbackFeedback
|};
export type CommentCreateMutationVariables = {|
  input: CommentCreateInput,
  first?: ?number,
  orderBy?: ?$ReadOnlyArray<string>,
|};
export type CommentCreateMutationResponse = {|
  +commentCreate: ?{|
    +comment: ?{|
      +id: string,
      +name: ?string,
      +friends: ?{|
        +count: ?number
      |},
    |}
  |}
|};
export type CommentCreateMutation = {|
  variables: CommentCreateMutationVariables,
  response: CommentCreateMutationResponse,
|};
`;

exports[`Snapshot tests for useHaste matches expected output: mutation-input-has-array.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation InputHasArray($input: UpdateAllSeenStateInput) @raw_response_type {
  viewerNotificationsUpdateAllSeenState(input: $input) {
    stories {
      actorCount
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// InputHasArray.graphql
export type UpdateAllSeenStateInput = {|
  clientMutationId?: ?string,
  storyIds?: ?$ReadOnlyArray<?string>,
|};
export type InputHasArrayVariables = {|
  input?: ?UpdateAllSeenStateInput
|};
export type InputHasArrayResponse = {|
  +viewerNotificationsUpdateAllSeenState: ?{|
    +stories: ?$ReadOnlyArray<?{|
      +actorCount: ?number
    |}>
  |}
|};
export type InputHasArrayRawResponse = {|
  +viewerNotificationsUpdateAllSeenState: ?{|
    +stories: ?$ReadOnlyArray<?{|
      +actorCount: ?number,
      +id: ?string,
    |}>
  |}
|};
export type InputHasArray = {|
  variables: InputHasArrayVariables,
  response: InputHasArrayResponse,
  rawResponse: InputHasArrayRawResponse,
|};
`;

exports[`Snapshot tests for useHaste matches expected output: mutation-with-enums-on-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) @raw_response_type {
  commentCreate(input: $input) {
    comment {
      friends(first: $first, orderby: $orderBy) {
        edges {
          node {
            id
            __typename
            ...FriendFragment
          }
        }
      }
    }
  }
}

fragment FriendFragment on User {
  name
  lastName
  profilePicture2 {
    test_enums
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// CommentCreateMutation.graphql
import type { FriendFragment$ref } from "FriendFragment.graphql";
export type TestEnums = "mark" | "zuck" | "%future added value";
export type CommentCreateInput = {|
  clientMutationId?: ?string,
  feedbackId?: ?string,
  feedback?: ?CommentfeedbackFeedback,
|};
export type CommentfeedbackFeedback = {|
  comment?: ?FeedbackcommentComment
|};
export type FeedbackcommentComment = {|
  feedback?: ?CommentfeedbackFeedback
|};
export type CommentCreateMutationVariables = {|
  input: CommentCreateInput,
  first?: ?number,
  orderBy?: ?$ReadOnlyArray<string>,
|};
export type CommentCreateMutationResponse = {|
  +commentCreate: ?{|
    +comment: ?{|
      +friends: ?{|
        +edges: ?$ReadOnlyArray<?{|
          +node: ?{|
            +id: string,
            +__typename: string,
            +$fragmentRefs: FriendFragment$ref,
          |}
        |}>
      |}
    |}
  |}
|};
export type CommentCreateMutationRawResponse = {|
  +commentCreate: ?{|
    +comment: ?{|
      +friends: ?{|
        +edges: ?$ReadOnlyArray<?{|
          +node: ?{|
            +id: string,
            +__typename: "User",
            +name: ?string,
            +lastName: ?string,
            +profilePicture2: ?{|
              +test_enums: ?TestEnums
            |},
          |}
        |}>
      |},
      +id: ?string,
    |}
  |}
|};
export type CommentCreateMutation = {|
  variables: CommentCreateMutationVariables,
  response: CommentCreateMutationResponse,
  rawResponse: CommentCreateMutationRawResponse,
|};

// FriendFragment.graphql
export type TestEnums = "mark" | "zuck" | "%future added value";
import type { FragmentReference } from "relay-runtime";
declare export opaque type FriendFragment$ref: FragmentReference;
declare export opaque type FriendFragment$fragmentType: FriendFragment$ref;
export type FriendFragment = {|
  +name: ?string,
  +lastName: ?string,
  +profilePicture2: ?{|
    +test_enums: ?TestEnums
  |},
  +$refType: FriendFragment$ref,
|};
export type FriendFragment$data = FriendFragment;
export type FriendFragment$key = {
  +$data?: FriendFragment$data,
  +$fragmentRefs: FriendFragment$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: mutation-with-nested-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
mutation CommentCreateMutation(
  $input: CommentCreateInput!
  $first: Int
  $orderBy: [String!]
) @raw_response_type {
  commentCreate(input: $input) {
    comment {
      friends(first: $first, orderby: $orderBy) {
        edges {
          node {
            lastName
            ...FriendFragment
          }
        }
      }
    }
  }
}

fragment FriendFragment on User {
  name
  lastName
  feedback {
    ...FeedbackFragment
  }
}

fragment FeedbackFragment on Feedback {
  id
  name
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// CommentCreateMutation.graphql
import type { FriendFragment$ref } from "FriendFragment.graphql";
export type CommentCreateInput = {|
  clientMutationId?: ?string,
  feedbackId?: ?string,
  feedback?: ?CommentfeedbackFeedback,
|};
export type CommentfeedbackFeedback = {|
  comment?: ?FeedbackcommentComment
|};
export type FeedbackcommentComment = {|
  feedback?: ?CommentfeedbackFeedback
|};
export type CommentCreateMutationVariables = {|
  input: CommentCreateInput,
  first?: ?number,
  orderBy?: ?$ReadOnlyArray<string>,
|};
export type CommentCreateMutationResponse = {|
  +commentCreate: ?{|
    +comment: ?{|
      +friends: ?{|
        +edges: ?$ReadOnlyArray<?{|
          +node: ?{|
            +lastName: ?string,
            +$fragmentRefs: FriendFragment$ref,
          |}
        |}>
      |}
    |}
  |}
|};
export type CommentCreateMutationRawResponse = {|
  +commentCreate: ?{|
    +comment: ?{|
      +friends: ?{|
        +edges: ?$ReadOnlyArray<?{|
          +node: ?{|
            +lastName: ?string,
            +name: ?string,
            +feedback: ?{|
              +id: string,
              +name: ?string,
            |},
            +id: ?string,
          |}
        |}>
      |},
      +id: ?string,
    |}
  |}
|};
export type CommentCreateMutation = {|
  variables: CommentCreateMutationVariables,
  response: CommentCreateMutationResponse,
  rawResponse: CommentCreateMutationRawResponse,
|};

// FriendFragment.graphql
import type { FeedbackFragment$ref } from "FeedbackFragment.graphql";
import type { FragmentReference } from "relay-runtime";
declare export opaque type FriendFragment$ref: FragmentReference;
declare export opaque type FriendFragment$fragmentType: FriendFragment$ref;
export type FriendFragment = {|
  +name: ?string,
  +lastName: ?string,
  +feedback: ?{|
    +$fragmentRefs: FeedbackFragment$ref
  |},
  +$refType: FriendFragment$ref,
|};
export type FriendFragment$data = FriendFragment;
export type FriendFragment$key = {
  +$data?: FriendFragment$data,
  +$fragmentRefs: FriendFragment$ref,
  ...
};

// FeedbackFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type FeedbackFragment$ref: FragmentReference;
declare export opaque type FeedbackFragment$fragmentType: FeedbackFragment$ref;
export type FeedbackFragment = {|
  +id: string,
  +name: ?string,
  +$refType: FeedbackFragment$ref,
|};
export type FeedbackFragment$data = FeedbackFragment;
export type FeedbackFragment$key = {
  +$data?: FeedbackFragment$data,
  +$fragmentRefs: FeedbackFragment$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: plural-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment PluralFragment on Node @relay(plural: true) {
  id
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// PluralFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type PluralFragment$ref: FragmentReference;
declare export opaque type PluralFragment$fragmentType: PluralFragment$ref;
export type PluralFragment = $ReadOnlyArray<{|
  +id: string,
  +$refType: PluralFragment$ref,
|}>;
export type PluralFragment$data = PluralFragment;
export type PluralFragment$key = $ReadOnlyArray<{
  +$data?: PluralFragment$data,
  +$fragmentRefs: PluralFragment$ref,
  ...
}>;
`;

exports[`Snapshot tests for useHaste matches expected output: query-with-handles.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query LinkedHandleField($id: ID!) @raw_response_type {
  node(id: $id) {
    ... on User {
      friends(first: 10) @__clientField(handle: "clientFriends") {
        count
      }
    }
  }
}

query ScalarHandleField($id: ID!) @raw_response_type {
  node(id: $id) {
    ... on User {
      name @__clientField(handle: "clientName")
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// LinkedHandleField.graphql
export type LinkedHandleFieldVariables = {|
  id: string
|};
export type LinkedHandleFieldResponse = {|
  +node: ?{|
    +friends?: ?{|
      +count: ?number
    |}
  |}
|};
export type LinkedHandleFieldRawResponse = {|
  +node: ?({|
    +__typename: "User",
    +id: ?string,
    +friends: ?{|
      +count: ?number
    |},
  |} | {|
    +__typename: ?string,
    +id: ?string,
  |})
|};
export type LinkedHandleField = {|
  variables: LinkedHandleFieldVariables,
  response: LinkedHandleFieldResponse,
  rawResponse: LinkedHandleFieldRawResponse,
|};

// ScalarHandleField.graphql
export type ScalarHandleFieldVariables = {|
  id: string
|};
export type ScalarHandleFieldResponse = {|
  +node: ?{|
    +name?: ?string
  |}
|};
export type ScalarHandleFieldRawResponse = {|
  +node: ?({|
    +__typename: "User",
    +id: ?string,
    +name: ?string,
  |} | {|
    +__typename: ?string,
    +id: ?string,
  |})
|};
export type ScalarHandleField = {|
  variables: ScalarHandleFieldVariables,
  response: ScalarHandleFieldResponse,
  rawResponse: ScalarHandleFieldRawResponse,
|};
`;

exports[`Snapshot tests for useHaste matches expected output: query-with-match-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query Test @raw_response_type {
  node(id: "1") {
    ...NameRendererFragment
  }
}

fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// Test.graphql
import type { Local3DPayload } from "relay-runtime";
import type { NameRendererFragment$ref } from "NameRendererFragment.graphql";
export type TestVariables = {||};
export type TestResponse = {|
  +node: ?{|
    +$fragmentRefs: NameRendererFragment$ref
  |}
|};
export type PlainUserNameRenderer_name = {|
  +plaintext: ?string,
  +data: ?{|
    +text: ?string,
    +id: ?string,
  |},
|};
export type MarkdownUserNameRenderer_name = {|
  +markdown: ?string,
  +data: ?{|
    +markup: ?string,
    +id: ?string,
  |},
|};
export type TestRawResponse = {|
  +node: ?({|
    +__typename: "User",
    +id: ?string,
    +nameRenderer: ?({|
      +__typename: "PlainUserNameRenderer",
      +__module_operation_NameRendererFragment: ?any,
      +__module_component_NameRendererFragment: ?any,
      ...PlainUserNameRenderer_name,
    |} | Local3DPayload<"NameRendererFragment", {|
      +__typename: "PlainUserNameRenderer",
      ...PlainUserNameRenderer_name,
    |}> | {|
      +__typename: "MarkdownUserNameRenderer",
      +__module_operation_NameRendererFragment: ?any,
      +__module_component_NameRendererFragment: ?any,
      ...MarkdownUserNameRenderer_name,
    |} | Local3DPayload<"NameRendererFragment", {|
      +__typename: "MarkdownUserNameRenderer",
      ...MarkdownUserNameRenderer_name,
    |}> | {|
      +__typename: ?string
    |}),
  |} | {|
    +__typename: ?string,
    +id: ?string,
  |})
|};
export type Test = {|
  variables: TestVariables,
  response: TestResponse,
  rawResponse: TestRawResponse,
|};

// NameRendererFragment.graphql
import type { MarkdownUserNameRenderer_name$ref } from "MarkdownUserNameRenderer_name.graphql";
import type { PlainUserNameRenderer_name$ref } from "PlainUserNameRenderer_name.graphql";
import type { FragmentReference } from "relay-runtime";
declare export opaque type NameRendererFragment$ref: FragmentReference;
declare export opaque type NameRendererFragment$fragmentType: NameRendererFragment$ref;
export type NameRendererFragment = {|
  +id: string,
  +nameRenderer: ?{|
    +__fragmentPropName?: ?string,
    +__module_component?: ?string,
    +$fragmentRefs: PlainUserNameRenderer_name$ref & MarkdownUserNameRenderer_name$ref,
  |},
  +$refType: NameRendererFragment$ref,
|};
export type NameRendererFragment$data = NameRendererFragment;
export type NameRendererFragment$key = {
  +$data?: NameRendererFragment$data,
  +$fragmentRefs: NameRendererFragment$ref,
  ...
};

// PlainUserNameRenderer_name.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type PlainUserNameRenderer_name$ref: FragmentReference;
declare export opaque type PlainUserNameRenderer_name$fragmentType: PlainUserNameRenderer_name$ref;
export type PlainUserNameRenderer_name = {|
  +plaintext: ?string,
  +data: ?{|
    +text: ?string
  |},
  +$refType: PlainUserNameRenderer_name$ref,
|};
export type PlainUserNameRenderer_name$data = PlainUserNameRenderer_name;
export type PlainUserNameRenderer_name$key = {
  +$data?: PlainUserNameRenderer_name$data,
  +$fragmentRefs: PlainUserNameRenderer_name$ref,
  ...
};

// MarkdownUserNameRenderer_name.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type MarkdownUserNameRenderer_name$ref: FragmentReference;
declare export opaque type MarkdownUserNameRenderer_name$fragmentType: MarkdownUserNameRenderer_name$ref;
export type MarkdownUserNameRenderer_name = {|
  +markdown: ?string,
  +data: ?{|
    +markup: ?string
  |},
  +$refType: MarkdownUserNameRenderer_name$ref,
|};
export type MarkdownUserNameRenderer_name$data = MarkdownUserNameRenderer_name;
export type MarkdownUserNameRenderer_name$key = {
  +$data?: MarkdownUserNameRenderer_name$data,
  +$fragmentRefs: MarkdownUserNameRenderer_name$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: query-with-module-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query Test @raw_response_type {
  node(id: "1") {
    ...Test_user
  }
}

fragment Test_user on User {
  plainUserRenderer {
    ...Test_userRenderer @module(name: "Renderer.react")
  }
}

fragment Test_userRenderer on PlainUserRenderer {
  user {
    username
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// Test.graphql
import type { Local3DPayload } from "relay-runtime";
import type { Test_user$ref } from "Test_user.graphql";
export type TestVariables = {||};
export type TestResponse = {|
  +node: ?{|
    +$fragmentRefs: Test_user$ref
  |}
|};
export type Test_userRenderer = {|
  +user: ?{|
    +username: ?string,
    +id: ?string,
  |}
|};
export type TestRawResponse = {|
  +node: ?({|
    +__typename: "User",
    +id: ?string,
    +plainUserRenderer: ?({|
      +__module_operation_Test_user: ?any,
      +__module_component_Test_user: ?any,
      ...Test_userRenderer,
    |} | Local3DPayload<"Test_user", {| ...Test_userRenderer
    |}>),
  |} | {|
    +__typename: ?string,
    +id: ?string,
  |})
|};
export type Test = {|
  variables: TestVariables,
  response: TestResponse,
  rawResponse: TestRawResponse,
|};

// Test_user.graphql
import type { Test_userRenderer$ref } from "Test_userRenderer.graphql";
import type { FragmentReference } from "relay-runtime";
declare export opaque type Test_user$ref: FragmentReference;
declare export opaque type Test_user$fragmentType: Test_user$ref;
export type Test_user = {|
  +plainUserRenderer: ?{|
    +__fragmentPropName?: ?string,
    +__module_component?: ?string,
    +$fragmentRefs: Test_userRenderer$ref,
  |},
  +$refType: Test_user$ref,
|};
export type Test_user$data = Test_user;
export type Test_user$key = {
  +$data?: Test_user$data,
  +$fragmentRefs: Test_user$ref,
  ...
};

// Test_userRenderer.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type Test_userRenderer$ref: FragmentReference;
declare export opaque type Test_userRenderer$fragmentType: Test_userRenderer$ref;
export type Test_userRenderer = {|
  +user: ?{|
    +username: ?string
  |},
  +$refType: Test_userRenderer$ref,
|};
export type Test_userRenderer$data = Test_userRenderer;
export type Test_userRenderer$key = {
  +$data?: Test_userRenderer$data,
  +$fragmentRefs: Test_userRenderer$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: query-with-multiple-match-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query Test @raw_response_type {
  node(id: "1") {
    ... on User {
      username
      ...NameRendererFragment
    }
  }
  viewer {
    actor {
      ... on User {
        name
        ...AnotherNameRendererFragment
      }
    }
  }
}

fragment NameRendererFragment on User {
  id
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment AnotherNameRendererFragment on User {
  name
  nameRenderer @match {
    ...PlainUserNameRenderer_name @module(name: "PlainUserNameRenderer.react")
    ...MarkdownUserNameRenderer_name
      @module(name: "MarkdownUserNameRenderer.react")
  }
}

fragment PlainUserNameRenderer_name on PlainUserNameRenderer {
  plaintext
  data {
    text
  }
}

fragment MarkdownUserNameRenderer_name on MarkdownUserNameRenderer {
  markdown
  data {
    markup
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// Test.graphql
import type { Local3DPayload } from "relay-runtime";
import type { AnotherNameRendererFragment$ref } from "AnotherNameRendererFragment.graphql";
import type { NameRendererFragment$ref } from "NameRendererFragment.graphql";
export type TestVariables = {||};
export type TestResponse = {|
  +node: ?{|
    +username?: ?string,
    +$fragmentRefs: NameRendererFragment$ref,
  |},
  +viewer: ?{|
    +actor: ?{|
      +name?: ?string,
      +$fragmentRefs: AnotherNameRendererFragment$ref,
    |}
  |},
|};
export type PlainUserNameRenderer_name = {|
  +plaintext: ?string,
  +data: ?{|
    +text: ?string,
    +id: ?string,
  |},
|};
export type MarkdownUserNameRenderer_name = {|
  +markdown: ?string,
  +data: ?{|
    +markup: ?string,
    +id: ?string,
  |},
|};
export type TestRawResponse = {|
  +node: ?({|
    +__typename: "User",
    +id: ?string,
    +username: ?string,
    +nameRenderer: ?({|
      +__typename: "PlainUserNameRenderer",
      +__module_operation_NameRendererFragment: ?any,
      +__module_component_NameRendererFragment: ?any,
      ...PlainUserNameRenderer_name,
    |} | Local3DPayload<"NameRendererFragment", {|
      +__typename: "PlainUserNameRenderer",
      ...PlainUserNameRenderer_name,
    |}> | {|
      +__typename: "MarkdownUserNameRenderer",
      +__module_operation_NameRendererFragment: ?any,
      +__module_component_NameRendererFragment: ?any,
      ...MarkdownUserNameRenderer_name,
    |} | Local3DPayload<"NameRendererFragment", {|
      +__typename: "MarkdownUserNameRenderer",
      ...MarkdownUserNameRenderer_name,
    |}> | {|
      +__typename: ?string
    |}),
  |} | {|
    +__typename: ?string,
    +id: ?string,
  |}),
  +viewer: ?{|
    +actor: ?({|
      +__typename: "User",
      +id: ?string,
      +name: ?string,
      +nameRenderer: ?({|
        +__typename: "PlainUserNameRenderer",
        +__module_operation_AnotherNameRendererFragment: ?any,
        +__module_component_AnotherNameRendererFragment: ?any,
        ...PlainUserNameRenderer_name,
      |} | Local3DPayload<"AnotherNameRendererFragment", {|
        +__typename: "PlainUserNameRenderer",
        ...PlainUserNameRenderer_name,
      |}> | {|
        +__typename: "MarkdownUserNameRenderer",
        +__module_operation_AnotherNameRendererFragment: ?any,
        +__module_component_AnotherNameRendererFragment: ?any,
        ...MarkdownUserNameRenderer_name,
      |} | Local3DPayload<"AnotherNameRendererFragment", {|
        +__typename: "MarkdownUserNameRenderer",
        ...MarkdownUserNameRenderer_name,
      |}> | {|
        +__typename: ?string
      |}),
    |} | {|
      +__typename: ?string,
      +id: ?string,
    |})
  |},
|};
export type Test = {|
  variables: TestVariables,
  response: TestResponse,
  rawResponse: TestRawResponse,
|};

// NameRendererFragment.graphql
import type { MarkdownUserNameRenderer_name$ref } from "MarkdownUserNameRenderer_name.graphql";
import type { PlainUserNameRenderer_name$ref } from "PlainUserNameRenderer_name.graphql";
import type { FragmentReference } from "relay-runtime";
declare export opaque type NameRendererFragment$ref: FragmentReference;
declare export opaque type NameRendererFragment$fragmentType: NameRendererFragment$ref;
export type NameRendererFragment = {|
  +id: string,
  +nameRenderer: ?{|
    +__fragmentPropName?: ?string,
    +__module_component?: ?string,
    +$fragmentRefs: PlainUserNameRenderer_name$ref & MarkdownUserNameRenderer_name$ref,
  |},
  +$refType: NameRendererFragment$ref,
|};
export type NameRendererFragment$data = NameRendererFragment;
export type NameRendererFragment$key = {
  +$data?: NameRendererFragment$data,
  +$fragmentRefs: NameRendererFragment$ref,
  ...
};

// AnotherNameRendererFragment.graphql
import type { MarkdownUserNameRenderer_name$ref } from "MarkdownUserNameRenderer_name.graphql";
import type { PlainUserNameRenderer_name$ref } from "PlainUserNameRenderer_name.graphql";
import type { FragmentReference } from "relay-runtime";
declare export opaque type AnotherNameRendererFragment$ref: FragmentReference;
declare export opaque type AnotherNameRendererFragment$fragmentType: AnotherNameRendererFragment$ref;
export type AnotherNameRendererFragment = {|
  +name: ?string,
  +nameRenderer: ?{|
    +__fragmentPropName?: ?string,
    +__module_component?: ?string,
    +$fragmentRefs: PlainUserNameRenderer_name$ref & MarkdownUserNameRenderer_name$ref,
  |},
  +$refType: AnotherNameRendererFragment$ref,
|};
export type AnotherNameRendererFragment$data = AnotherNameRendererFragment;
export type AnotherNameRendererFragment$key = {
  +$data?: AnotherNameRendererFragment$data,
  +$fragmentRefs: AnotherNameRendererFragment$ref,
  ...
};

// PlainUserNameRenderer_name.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type PlainUserNameRenderer_name$ref: FragmentReference;
declare export opaque type PlainUserNameRenderer_name$fragmentType: PlainUserNameRenderer_name$ref;
export type PlainUserNameRenderer_name = {|
  +plaintext: ?string,
  +data: ?{|
    +text: ?string
  |},
  +$refType: PlainUserNameRenderer_name$ref,
|};
export type PlainUserNameRenderer_name$data = PlainUserNameRenderer_name;
export type PlainUserNameRenderer_name$key = {
  +$data?: PlainUserNameRenderer_name$data,
  +$fragmentRefs: PlainUserNameRenderer_name$ref,
  ...
};

// MarkdownUserNameRenderer_name.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type MarkdownUserNameRenderer_name$ref: FragmentReference;
declare export opaque type MarkdownUserNameRenderer_name$fragmentType: MarkdownUserNameRenderer_name$ref;
export type MarkdownUserNameRenderer_name = {|
  +markdown: ?string,
  +data: ?{|
    +markup: ?string
  |},
  +$refType: MarkdownUserNameRenderer_name$ref,
|};
export type MarkdownUserNameRenderer_name$data = MarkdownUserNameRenderer_name;
export type MarkdownUserNameRenderer_name$key = {
  +$data?: MarkdownUserNameRenderer_name$data,
  +$fragmentRefs: MarkdownUserNameRenderer_name$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: query-with-raw-response-on-conditional.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query ExampleQuery($id: ID!, $condition: Boolean!) @raw_response_type {
  node(id: $id) {
    ...FriendFragment
  }
}

fragment FriendFragment on User {
  ... @include(if: $condition) {
    name
    lastName
    feedback {
      id
      name
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ExampleQuery.graphql
import type { FriendFragment$ref } from "FriendFragment.graphql";
export type ExampleQueryVariables = {|
  id: string,
  condition: boolean,
|};
export type ExampleQueryResponse = {|
  +node: ?{|
    +$fragmentRefs: FriendFragment$ref
  |}
|};
export type ExampleQueryRawResponse = {|
  +node: ?({|
    +__typename: "User",
    +id: ?string,
    +name: ?string,
    +lastName: ?string,
    +feedback: ?{|
      +id: string,
      +name: ?string,
    |},
  |} | {|
    +__typename: ?string,
    +id: ?string,
  |})
|};
export type ExampleQuery = {|
  variables: ExampleQueryVariables,
  response: ExampleQueryResponse,
  rawResponse: ExampleQueryRawResponse,
|};

// FriendFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type FriendFragment$ref: FragmentReference;
declare export opaque type FriendFragment$fragmentType: FriendFragment$ref;
export type FriendFragment = {|
  +name?: ?string,
  +lastName?: ?string,
  +feedback?: ?{|
    +id: string,
    +name: ?string,
  |},
  +$refType: FriendFragment$ref,
|};
export type FriendFragment$data = FriendFragment;
export type FriendFragment$key = {
  +$data?: FriendFragment$data,
  +$fragmentRefs: FriendFragment$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: query-with-raw-response-on-literal-conditional.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query ExampleQuery($id: ID!) @raw_response_type {
  node(id: $id) {
    username
    ...FriendFragment
    ... @include(if: false) {
      friends(first: 0) {
        count
      }
    }
  }
}

fragment FriendFragment on User {
  ... @include(if: false) {
    name
    lastName
    feedback {
      id
      name
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ExampleQuery.graphql
import type { FriendFragment$ref } from "FriendFragment.graphql";
export type ExampleQueryVariables = {|
  id: string
|};
export type ExampleQueryResponse = {|
  +node: ?{|
    +username: ?string,
    +friends?: ?{|
      +count: ?number
    |},
    +$fragmentRefs: FriendFragment$ref,
  |}
|};
export type ExampleQueryRawResponse = {|
  +node: ?{|
    +__typename: ?string,
    +username: ?string,
    +id: ?string,
  |}
|};
export type ExampleQuery = {|
  variables: ExampleQueryVariables,
  response: ExampleQueryResponse,
  rawResponse: ExampleQueryRawResponse,
|};

// FriendFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type FriendFragment$ref: FragmentReference;
declare export opaque type FriendFragment$fragmentType: FriendFragment$ref;
export type FriendFragment = {|
  +name?: ?string,
  +lastName?: ?string,
  +feedback?: ?{|
    +id: string,
    +name: ?string,
  |},
  +$refType: FriendFragment$ref,
|};
export type FriendFragment$data = FriendFragment;
export type FriendFragment$key = {
  +$data?: FriendFragment$data,
  +$fragmentRefs: FriendFragment$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: query-with-stream.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query TestStream @raw_response_type {
  node(id: "1") {
    ... on User {
      name
      friends(first: 10)
        @stream_connection(
          key: "PaginationFragment_friends"
          initial_count: 1
        ) {
        edges {
          node {
            id
          }
        }
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TestStream.graphql
export type TestStreamVariables = {||};
export type TestStreamResponse = {|
  +node: ?{|
    +name?: ?string,
    +friends?: ?{|
      +edges: ?$ReadOnlyArray<?{|
        +node: ?{|
          +id: string
        |}
      |}>
    |},
  |}
|};
export type TestStreamRawResponse = {|
  +node: ?({|
    +__typename: "User",
    +id: ?string,
    +name: ?string,
    +friends: ?{|
      +edges: ?$ReadOnlyArray<?{|
        +node: ?{|
          +id: string,
          +__typename: "User",
        |},
        +cursor: ?string,
      |}>,
      +pageInfo: ?{|
        +endCursor: ?string,
        +hasNextPage: ?boolean,
      |},
    |},
  |} | {|
    +__typename: ?string,
    +id: ?string,
  |})
|};
export type TestStream = {|
  variables: TestStreamVariables,
  response: TestStreamResponse,
  rawResponse: TestStreamRawResponse,
|};
`;

exports[`Snapshot tests for useHaste matches expected output: query-with-stream-connection.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query TestDefer @raw_response_type {
  node(id: "1") {
    ... on User {
      name
      friends(first: 10)
        @stream_connection(key: "TestDefer_friends", initial_count: 0) {
        edges {
          node {
            actor {
              name
            }
          }
        }
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TestDefer.graphql
export type TestDeferVariables = {||};
export type TestDeferResponse = {|
  +node: ?{|
    +name?: ?string,
    +friends?: ?{|
      +edges: ?$ReadOnlyArray<?{|
        +node: ?{|
          +actor: ?{|
            +name: ?string
          |}
        |}
      |}>
    |},
  |}
|};
export type TestDeferRawResponse = {|
  +node: ?({|
    +__typename: "User",
    +id: ?string,
    +name: ?string,
    +friends: ?{|
      +edges: ?$ReadOnlyArray<?{|
        +node: ?{|
          +actor: ?{|
            +__typename: ?string,
            +name: ?string,
            +id: ?string,
          |},
          +id: ?string,
          +__typename: "User",
        |},
        +cursor: ?string,
      |}>,
      +pageInfo: ?{|
        +endCursor: ?string,
        +hasNextPage: ?boolean,
      |},
    |},
  |} | {|
    +__typename: ?string,
    +id: ?string,
  |})
|};
export type TestDefer = {|
  variables: TestDeferVariables,
  response: TestDeferResponse,
  rawResponse: TestDeferRawResponse,
|};
`;

exports[`Snapshot tests for useHaste matches expected output: recursive-fragments.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment FragmentSpread on Node {
  id
  ... @include(if: $condition) {
    ...FragmentSpread
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// FragmentSpread.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type FragmentSpread$ref: FragmentReference;
declare export opaque type FragmentSpread$fragmentType: FragmentSpread$ref;
export type FragmentSpread = {|
  +id: string,
  +$fragmentRefs: FragmentSpread$ref,
  +$refType: FragmentSpread$ref,
|};
export type FragmentSpread$data = FragmentSpread;
export type FragmentSpread$key = {
  +$data?: FragmentSpread$data,
  +$fragmentRefs: FragmentSpread$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: refetchable-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment RefetchableFragment on Node
  @refetchable(queryName: "RefetchableFragmentQuery") {
  id
  fragAndField: profilePicture {
    uri
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// RefetchableFragment.graphql
import type { FragmentReference } from "relay-runtime";
import type { RefetchableFragment$ref, RefetchableFragment$fragmentType } from "RefetchableFragmentQuery.graphql";
export type { RefetchableFragment$ref, RefetchableFragment$fragmentType };
export type RefetchableFragment = {|
  +id: string,
  +fragAndField: ?{|
    +uri: ?string
  |},
  +$refType: RefetchableFragment$ref,
|};
export type RefetchableFragment$data = RefetchableFragment;
export type RefetchableFragment$key = {
  +$data?: RefetchableFragment$data,
  +$fragmentRefs: RefetchableFragment$ref,
  ...
};

// RefetchableFragmentQuery.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type RefetchableFragment$ref: FragmentReference;
declare export opaque type RefetchableFragment$fragmentType: RefetchableFragment$ref;
export type RefetchableFragmentQueryVariables = {|
  id: string
|};
export type RefetchableFragmentQueryResponse = {|
  +node: ?{|
    +$fragmentRefs: RefetchableFragment$ref
  |}
|};
export type RefetchableFragmentQuery = {|
  variables: RefetchableFragmentQueryVariables,
  response: RefetchableFragmentQueryResponse,
|};
`;

exports[`Snapshot tests for useHaste matches expected output: relay-client-id-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query RelayClientIDFieldQuery($id: ID!) {
  __id # ok on query type
  me {
    __id # ok on object type with 'id'
    __typename
    id
  }
  node(id: $id) {
    __id # ok on interface type
    __typename
    id
    ... on Comment {
      commentBody(supported: ["PlainCommentBody"]) {
        __id # ok on union type
        __typename
        ... on PlainCommentBody {
          __id # ok on object type w/o 'id'
          text {
            __id # ok on object type w/o 'id'
            __typename
            text
          }
        }
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// RelayClientIDFieldQuery.graphql
export type RelayClientIDFieldQueryVariables = {|
  id: string
|};
export type RelayClientIDFieldQueryResponse = {|
  +__id: string,
  +me: ?{|
    +__id: string,
    +__typename: string,
    +id: string,
  |},
  +node: ?{|
    +__id: string,
    +__typename: string,
    +id: string,
    +commentBody?: ?{|
      +__id: string,
      +__typename: string,
      +text?: ?{|
        +__id: string,
        +__typename: string,
        +text: ?string,
      |},
    |},
  |},
|};
export type RelayClientIDFieldQuery = {|
  variables: RelayClientIDFieldQueryVariables,
  response: RelayClientIDFieldQueryResponse,
|};
`;

exports[`Snapshot tests for useHaste matches expected output: roots.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
query ExampleQuery($id: ID!) {
  node(id: $id) {
    id
  }
}

fragment ExampleFragment on User {
  id
}

mutation TestMutation($input: CommentCreateInput!) {
  commentCreate(input: $input) {
    comment {
      id
    }
  }
}

subscription TestSubscription($input: FeedbackLikeInput) {
  feedbackLikeSubscribe(input: $input) {
    feedback {
      id
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ExampleQuery.graphql
export type ExampleQueryVariables = {|
  id: string
|};
export type ExampleQueryResponse = {|
  +node: ?{|
    +id: string
  |}
|};
export type ExampleQuery = {|
  variables: ExampleQueryVariables,
  response: ExampleQueryResponse,
|};

// ExampleFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type ExampleFragment$ref: FragmentReference;
declare export opaque type ExampleFragment$fragmentType: ExampleFragment$ref;
export type ExampleFragment = {|
  +id: string,
  +$refType: ExampleFragment$ref,
|};
export type ExampleFragment$data = ExampleFragment;
export type ExampleFragment$key = {
  +$data?: ExampleFragment$data,
  +$fragmentRefs: ExampleFragment$ref,
  ...
};

// TestMutation.graphql
export type CommentCreateInput = {|
  clientMutationId?: ?string,
  feedbackId?: ?string,
  feedback?: ?CommentfeedbackFeedback,
|};
export type CommentfeedbackFeedback = {|
  comment?: ?FeedbackcommentComment
|};
export type FeedbackcommentComment = {|
  feedback?: ?CommentfeedbackFeedback
|};
export type TestMutationVariables = {|
  input: CommentCreateInput
|};
export type TestMutationResponse = {|
  +commentCreate: ?{|
    +comment: ?{|
      +id: string
    |}
  |}
|};
export type TestMutation = {|
  variables: TestMutationVariables,
  response: TestMutationResponse,
|};

// TestSubscription.graphql
export type FeedbackLikeInput = {|
  clientMutationId?: ?string,
  feedbackId?: ?string,
|};
export type TestSubscriptionVariables = {|
  input?: ?FeedbackLikeInput
|};
export type TestSubscriptionResponse = {|
  +feedbackLikeSubscribe: ?{|
    +feedback: ?{|
      +id: string
    |}
  |}
|};
export type TestSubscription = {|
  variables: TestSubscriptionVariables,
  response: TestSubscriptionResponse,
|};
`;

exports[`Snapshot tests for useHaste matches expected output: scalar-field.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment ScalarField on User {
  id
  name
  websites
  traits
  aliasedLinkedField: birthdate {
    aliasedField: year
  }
  screennames {
    name
    service
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// ScalarField.graphql
export type PersonalityTraits = "CHEERFUL" | "DERISIVE" | "HELPFUL" | "SNARKY" | "%future added value";
import type { FragmentReference } from "relay-runtime";
declare export opaque type ScalarField$ref: FragmentReference;
declare export opaque type ScalarField$fragmentType: ScalarField$ref;
export type ScalarField = {|
  +id: string,
  +name: ?string,
  +websites: ?$ReadOnlyArray<?string>,
  +traits: ?$ReadOnlyArray<?PersonalityTraits>,
  +aliasedLinkedField: ?{|
    +aliasedField: ?number
  |},
  +screennames: ?$ReadOnlyArray<?{|
    +name: ?string,
    +service: ?string,
  |}>,
  +$refType: ScalarField$ref,
|};
export type ScalarField$data = ScalarField;
export type ScalarField$key = {
  +$data?: ScalarField$data,
  +$fragmentRefs: ScalarField$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: typename-inside-with-overlapping-fields.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInsideWithOverlappingFields on Viewer {
  actor {
    __typename
    ... on Page {
      id
      name
    }
    ... on User {
      id
      name
      profile_picture {
        uri
      }
    }
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TypenameInsideWithOverlappingFields.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type TypenameInsideWithOverlappingFields$ref: FragmentReference;
declare export opaque type TypenameInsideWithOverlappingFields$fragmentType: TypenameInsideWithOverlappingFields$ref;
export type TypenameInsideWithOverlappingFields = {|
  +actor: ?({|
    +__typename: "Page",
    +id: string,
    +name: ?string,
  |} | {|
    +__typename: "User",
    +id: string,
    +name: ?string,
    +profile_picture: ?{|
      +uri: ?string
    |},
  |} | {|
    // This will never be '%other', but we need some
    // value in case none of the concrete values match.
    +__typename: "%other"
  |}),
  +$refType: TypenameInsideWithOverlappingFields$ref,
|};
export type TypenameInsideWithOverlappingFields$data = TypenameInsideWithOverlappingFields;
export type TypenameInsideWithOverlappingFields$key = {
  +$data?: TypenameInsideWithOverlappingFields$data,
  +$fragmentRefs: TypenameInsideWithOverlappingFields$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: typename-on-union.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment TypenameInside on Actor {
  ... on User {
    __typename
    firstName
  }
  ... on Page {
    __typename
    username
  }
}

fragment TypenameOutside on Actor {
  __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameOutsideWithAbstractType on Node {
  __typename
  ... on User {
    firstName
    address {
      street # only here
      city # common
    }
  }
  ... on Actor {
    username
    address {
      city # common
      country # only here
    }
  }
}

fragment TypenameWithoutSpreads on User {
  __typename
  firstName
}

fragment TypenameWithoutSpreadsAbstractType on Node {
  __typename
  id
}

fragment TypenameWithCommonSelections on Actor {
  __typename
  name
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameAlias on Actor {
  _typeAlias: __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

fragment TypenameAliases on Actor {
  _typeAlias1: __typename
  _typeAlias2: __typename
  ... on User {
    firstName
  }
  ... on Page {
    username
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// TypenameInside.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type TypenameInside$ref: FragmentReference;
declare export opaque type TypenameInside$fragmentType: TypenameInside$ref;
export type TypenameInside = {|
  +__typename: "User",
  +firstName: ?string,
  +$refType: TypenameInside$ref,
|} | {|
  +__typename: "Page",
  +username: ?string,
  +$refType: TypenameInside$ref,
|} | {|
  // This will never be '%other', but we need some
  // value in case none of the concrete values match.
  +__typename: "%other",
  +$refType: TypenameInside$ref,
|};
export type TypenameInside$data = TypenameInside;
export type TypenameInside$key = {
  +$data?: TypenameInside$data,
  +$fragmentRefs: TypenameInside$ref,
  ...
};

// TypenameOutside.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type TypenameOutside$ref: FragmentReference;
declare export opaque type TypenameOutside$fragmentType: TypenameOutside$ref;
export type TypenameOutside = {|
  +__typename: "User",
  +firstName: ?string,
  +$refType: TypenameOutside$ref,
|} | {|
  +__typename: "Page",
  +username: ?string,
  +$refType: TypenameOutside$ref,
|} | {|
  // This will never be '%other', but we need some
  // value in case none of the concrete values match.
  +__typename: "%other",
  +$refType: TypenameOutside$ref,
|};
export type TypenameOutside$data = TypenameOutside;
export type TypenameOutside$key = {
  +$data?: TypenameOutside$data,
  +$fragmentRefs: TypenameOutside$ref,
  ...
};

// TypenameOutsideWithAbstractType.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type TypenameOutsideWithAbstractType$ref: FragmentReference;
declare export opaque type TypenameOutsideWithAbstractType$fragmentType: TypenameOutsideWithAbstractType$ref;
export type TypenameOutsideWithAbstractType = {|
  +__typename: string,
  +username?: ?string,
  +address?: ?{|
    +city: ?string,
    +country: ?string,
    +street?: ?string,
  |},
  +firstName?: ?string,
  +$refType: TypenameOutsideWithAbstractType$ref,
|};
export type TypenameOutsideWithAbstractType$data = TypenameOutsideWithAbstractType;
export type TypenameOutsideWithAbstractType$key = {
  +$data?: TypenameOutsideWithAbstractType$data,
  +$fragmentRefs: TypenameOutsideWithAbstractType$ref,
  ...
};

// TypenameWithoutSpreads.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type TypenameWithoutSpreads$ref: FragmentReference;
declare export opaque type TypenameWithoutSpreads$fragmentType: TypenameWithoutSpreads$ref;
export type TypenameWithoutSpreads = {|
  +firstName: ?string,
  +__typename: "User",
  +$refType: TypenameWithoutSpreads$ref,
|};
export type TypenameWithoutSpreads$data = TypenameWithoutSpreads;
export type TypenameWithoutSpreads$key = {
  +$data?: TypenameWithoutSpreads$data,
  +$fragmentRefs: TypenameWithoutSpreads$ref,
  ...
};

// TypenameWithoutSpreadsAbstractType.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type TypenameWithoutSpreadsAbstractType$ref: FragmentReference;
declare export opaque type TypenameWithoutSpreadsAbstractType$fragmentType: TypenameWithoutSpreadsAbstractType$ref;
export type TypenameWithoutSpreadsAbstractType = {|
  +__typename: string,
  +id: string,
  +$refType: TypenameWithoutSpreadsAbstractType$ref,
|};
export type TypenameWithoutSpreadsAbstractType$data = TypenameWithoutSpreadsAbstractType;
export type TypenameWithoutSpreadsAbstractType$key = {
  +$data?: TypenameWithoutSpreadsAbstractType$data,
  +$fragmentRefs: TypenameWithoutSpreadsAbstractType$ref,
  ...
};

// TypenameWithCommonSelections.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type TypenameWithCommonSelections$ref: FragmentReference;
declare export opaque type TypenameWithCommonSelections$fragmentType: TypenameWithCommonSelections$ref;
export type TypenameWithCommonSelections = {|
  +__typename: string,
  +name: ?string,
  +firstName?: ?string,
  +username?: ?string,
  +$refType: TypenameWithCommonSelections$ref,
|};
export type TypenameWithCommonSelections$data = TypenameWithCommonSelections;
export type TypenameWithCommonSelections$key = {
  +$data?: TypenameWithCommonSelections$data,
  +$fragmentRefs: TypenameWithCommonSelections$ref,
  ...
};

// TypenameAlias.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type TypenameAlias$ref: FragmentReference;
declare export opaque type TypenameAlias$fragmentType: TypenameAlias$ref;
export type TypenameAlias = {|
  +_typeAlias: "User",
  +firstName: ?string,
  +$refType: TypenameAlias$ref,
|} | {|
  +_typeAlias: "Page",
  +username: ?string,
  +$refType: TypenameAlias$ref,
|} | {|
  // This will never be '%other', but we need some
  // value in case none of the concrete values match.
  +_typeAlias: "%other",
  +$refType: TypenameAlias$ref,
|};
export type TypenameAlias$data = TypenameAlias;
export type TypenameAlias$key = {
  +$data?: TypenameAlias$data,
  +$fragmentRefs: TypenameAlias$ref,
  ...
};

// TypenameAliases.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type TypenameAliases$ref: FragmentReference;
declare export opaque type TypenameAliases$fragmentType: TypenameAliases$ref;
export type TypenameAliases = {|
  +_typeAlias1: "User",
  +_typeAlias2: "User",
  +firstName: ?string,
  +$refType: TypenameAliases$ref,
|} | {|
  +_typeAlias1: "Page",
  +_typeAlias2: "Page",
  +username: ?string,
  +$refType: TypenameAliases$ref,
|} | {|
  // This will never be '%other', but we need some
  // value in case none of the concrete values match.
  +_typeAlias1: "%other",
  // This will never be '%other', but we need some
  // value in case none of the concrete values match.
  +_typeAlias2: "%other",
  +$refType: TypenameAliases$ref,
|};
export type TypenameAliases$data = TypenameAliases;
export type TypenameAliases$key = {
  +$data?: TypenameAliases$data,
  +$fragmentRefs: TypenameAliases$ref,
  ...
};
`;

exports[`Snapshot tests for useHaste matches expected output: unmasked-fragment-spreads.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment UserProfile on User {
  profilePicture(size: $ProfilePicture_SIZE) {
    ...PhotoFragment @relay(mask: false)

    # duplicated field should be merged
    ...AnotherRecursiveFragment @relay(mask: false)

    # Compose child fragment
    ...PhotoFragment
  }
}

fragment PhotoFragment on Image {
  uri
  ...RecursiveFragment @relay(mask: false)
}

fragment RecursiveFragment on Image @relay(mask: false) {
  uri
  width
}

fragment AnotherRecursiveFragment on Image {
  uri
  height
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// UserProfile.graphql
import type { PhotoFragment$ref } from "PhotoFragment.graphql";
import type { FragmentReference } from "relay-runtime";
declare export opaque type UserProfile$ref: FragmentReference;
declare export opaque type UserProfile$fragmentType: UserProfile$ref;
export type UserProfile = {|
  +profilePicture: ?{|
    +uri: ?string,
    +width: ?number,
    +height: ?number,
    +$fragmentRefs: PhotoFragment$ref,
  |},
  +$refType: UserProfile$ref,
|};
export type UserProfile$data = UserProfile;
export type UserProfile$key = {
  +$data?: UserProfile$data,
  +$fragmentRefs: UserProfile$ref,
  ...
};

// PhotoFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type PhotoFragment$ref: FragmentReference;
declare export opaque type PhotoFragment$fragmentType: PhotoFragment$ref;
export type PhotoFragment = {|
  +uri: ?string,
  +width: ?number,
  +$refType: PhotoFragment$ref,
|};
export type PhotoFragment$data = PhotoFragment;
export type PhotoFragment$key = {
  +$data?: PhotoFragment$data,
  +$fragmentRefs: PhotoFragment$ref,
  ...
};

// RecursiveFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type RecursiveFragment$ref: FragmentReference;
declare export opaque type RecursiveFragment$fragmentType: RecursiveFragment$ref;
export type RecursiveFragment = {
  +uri: ?string,
  +width: ?number,
  ...
};
export type RecursiveFragment$data = RecursiveFragment;
export type RecursiveFragment$key = {
  +$data?: RecursiveFragment$data,
  +$fragmentRefs: RecursiveFragment$ref,
  ...
};

// AnotherRecursiveFragment.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type AnotherRecursiveFragment$ref: FragmentReference;
declare export opaque type AnotherRecursiveFragment$fragmentType: AnotherRecursiveFragment$ref;
export type AnotherRecursiveFragment = {|
  +uri: ?string,
  +height: ?number,
  +$refType: AnotherRecursiveFragment$ref,
|};
export type AnotherRecursiveFragment$data = AnotherRecursiveFragment;
export type AnotherRecursiveFragment$key = {
  +$data?: AnotherRecursiveFragment$data,
  +$fragmentRefs: AnotherRecursiveFragment$ref,
  ...
};
`;

exports[`Snapshot tests for useSingleDirectory matches expected output: refetchable-fragment.graphql 1`] = `
~~~~~~~~~~ INPUT ~~~~~~~~~~
fragment RefetchableFragment on Node
  @refetchable(queryName: "RefetchableFragmentQuery") {
  id
  fragAndField: profilePicture {
    uri
  }
}

~~~~~~~~~~ OUTPUT ~~~~~~~~~~
// RefetchableFragment.graphql
import type { FragmentReference } from "relay-runtime";
import type { RefetchableFragment$ref, RefetchableFragment$fragmentType } from "./RefetchableFragmentQuery.graphql";
export type { RefetchableFragment$ref, RefetchableFragment$fragmentType };
export type RefetchableFragment = {|
  +id: string,
  +fragAndField: ?{|
    +uri: ?string
  |},
  +$refType: RefetchableFragment$ref,
|};
export type RefetchableFragment$data = RefetchableFragment;
export type RefetchableFragment$key = {
  +$data?: RefetchableFragment$data,
  +$fragmentRefs: RefetchableFragment$ref,
  ...
};

// RefetchableFragmentQuery.graphql
import type { FragmentReference } from "relay-runtime";
declare export opaque type RefetchableFragment$ref: FragmentReference;
declare export opaque type RefetchableFragment$fragmentType: RefetchableFragment$ref;
export type RefetchableFragmentQueryVariables = {|
  id: string
|};
export type RefetchableFragmentQueryResponse = {|
  +node: ?{|
    +$fragmentRefs: RefetchableFragment$ref
  |}
|};
export type RefetchableFragmentQuery = {|
  variables: RefetchableFragmentQueryVariables,
  response: RefetchableFragmentQueryResponse,
|};
`;
