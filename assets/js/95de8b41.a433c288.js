"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["59468"],{369(e,t,n){n.r(t),n.d(t,{metadata:()=>r,default:()=>c,frontMatter:()=>o,contentTitle:()=>i,toc:()=>d,assets:()=>l});var r=JSON.parse('{"id":"tutorial/queries-2","title":"Queries for Interactions","description":"We\u2019ve seen how fragments let us specify data requirements in each component, yet at runtime perform only a single query for an entire screen. Here we\u2019ll look at a situation where we want a second query on the same screen. This will also let us explore some more features of GraphQL queries.","source":"@site/versioned_docs/version-v14.0.0/tutorial/queries-2.md","sourceDirName":"tutorial","slug":"/tutorial/queries-2","permalink":"/docs/v14.0.0/tutorial/queries-2","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v14.0.0/tutorial/queries-2.md","tags":[],"version":"v14.0.0","frontMatter":{},"sidebar":"docs","previous":{"title":"Arrays and Lists","permalink":"/docs/v14.0.0/tutorial/arrays-lists"},"next":{"title":"Interfaces & Polymorphism","permalink":"/docs/v14.0.0/tutorial/interfaces-polymorphism"}}'),a=n(74848),s=n(28453);let o={},i="Queries for Interactions",l={},d=[{value:"Query Variables",id:"query-variables",level:2},{value:"Step 1 \u2014 define a query variable",id:"step-1--define-a-query-variable",level:3},{value:"Step 2 \u2014 pass the variable in as a field argument",id:"step-2--pass-the-variable-in-as-a-field-argument",level:3},{value:"Step 3 \u2014 provide the argument value to useLazyLoadQuery",id:"step-3--provide-the-argument-value-to-uselazyloadquery",level:3},{value:"Step 4 \u2014 pass the ID in from the parent component",id:"step-4--pass-the-id-in-from-the-parent-component",level:3},{value:"Preloaded Queries",id:"preloaded-queries",level:2},{value:"Step 1 \u2014 change useLazyLoadQuery to usePreloadedQuery",id:"step-1--change-uselazyloadquery-to-usepreloadedquery",level:3},{value:"Step 2: export the query for access from the parent component",id:"step-2-export-the-query-for-access-from-the-parent-component",level:3},{value:"Step 3: Call useQueryLoader in the parent component",id:"step-3-call-usequeryloader-in-the-parent-component",level:3},{value:"Step 4: Fetch the query in the event handler",id:"step-4-fetch-the-query-in-the-event-handler",level:3},{value:"Summary",id:"summary",level:2}];function h(e){let t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:r}=t;return r||function(e,t){throw Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"queries-for-interactions",children:"Queries for Interactions"})}),"\n",(0,a.jsxs)(t.p,{children:["We\u2019ve seen how fragments let us specify data requirements in each component, yet at runtime perform only a single query for an entire screen. Here we\u2019ll look at a situation where we ",(0,a.jsx)(t.em,{children:"want"})," a second query on the same screen. This will also let us explore some more features of GraphQL queries."]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["We\u2019ll build a ",(0,a.jsx)(t.strong,{children:"hovercard"})," that shows more details about the poster of a story when you hover over their name."]}),"\n",(0,a.jsxs)(t.li,{children:["The hovercard will use a second query to fetch ",(0,a.jsx)(t.strong,{children:"additional information"})," that\u2019s only needed if the user hovers."]}),"\n",(0,a.jsxs)(t.li,{children:["We\u2019ll use ",(0,a.jsx)(t.strong,{children:"query variables"})," to tell the server which person we\u2019d like more details about."]}),"\n",(0,a.jsxs)(t.li,{children:["We\u2019ll see how to improve performance with ",(0,a.jsx)(t.strong,{children:"preloaded queries"}),"."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"After covering these topics, we\u2019ll return to look at some more advanced features of Fragments."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsxs)(t.p,{children:["In this section we\u2019ll add a hovercard to ",(0,a.jsx)(t.code,{children:"PosterByline"})," so that you can see more details about the poster of a story by hovering over their name."]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"Deep dive: When to use a secondary query"}),(0,a.jsxs)(t.p,{children:["We've mentioned before that Relay is designed to help you fetch all of your data requirements for an entire screen up-front. But we can generalize this and say that it's a ",(0,a.jsx)(t.em,{children:"user interaction"})," that should have at most one query. Navigating to another screen is just one common type of user interaction."]}),(0,a.jsx)(t.p,{children:"Within a screen, some interactions may disclose additional data from what was shown initially. If an interaction is performed relatively rarely, but needs a significant amount of additional data, it can be smart to fetch that additional data in a second query, performed when the interaction happens, rather than up-front when the screen is first loaded. This makes that initial load faster and less expensive."}),(0,a.jsx)(t.p,{children:"There are also some interactions where the amount of data fetched is indefinite \u2014 e.g., a hovercard within a hovercard \u2014 and not feasible to know statically."}),(0,a.jsxs)(t.p,{children:["If data is lower-priority and should be loaded after the main data has loaded, but should pop in automatically without further user input, Relay has a feature called a ",(0,a.jsx)(t.em,{children:"deferred fragment"})," for that. We'll cover it later."]})]}),"\n",(0,a.jsxs)(t.p,{children:["We\u2019ve already prepared a hovercard component that you can put to use. However, it has been in a directory called ",(0,a.jsx)(t.code,{children:"future"})," in order to avoid compilation errors since it uses ",(0,a.jsx)(t.code,{children:"ImageFragment"}),". Now that we\u2019re at this stage of the tutorial, you can move the modules in ",(0,a.jsx)(t.code,{children:"future"})," into ",(0,a.jsx)(t.code,{children:"src/components"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"mv future/* src/components\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Now, if you did the exercise to make ",(0,a.jsx)(t.code,{children:"PosterByline"})," use fragments, the ",(0,a.jsx)(t.code,{children:"PosterByline"})," component should look something like this:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'export default function PosterByline({ poster }: Props): React.ReactElement {\n  const data = useFragment(PosterBylineFragment, poster);\n  return (\n    <div className="byline">\n      <Image image={data.profilePicture} width={60} height={60} className="byline__image" />\n      <div className="byline__name">{data.name}</div>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"To use the hovercard component, you can make the following changes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'// change-line\nimport Hovercard from \'./Hovercard\';\n// change-line\nimport PosterDetailsHovercardContents from \'./PosterDetailsHovercardContents\';\n// change-line\nconst {useRef} = React;\n\n...\n\nexport default function PosterByline({ poster }: Props): React.ReactElement {\n  const data = useFragment(PosterBylineFragment, poster);\n  // change-line\n  const hoverRef = useRef(null);\n  return (\n    <div\n      // change-line\n      ref={hoverRef}\n      className="byline">\n      <Image image={data.profilePicture} width={60} height={60} className="byline__image" />\n      <div className="byline__name">{data.name}</div>\n      // change\n      <Hovercard targetRef={hoverRef}>\n        <PosterDetailsHovercardContents />\n      </Hovercard>\n      // end-change\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["You should now see that whenever you hover over someone\u2019s name, you get a hovercard with more information. If you look inside ",(0,a.jsx)(t.code,{children:"PosterDetailsHovercardContents.tsx"}),", you\u2019ll find that it performs a second query with ",(0,a.jsx)(t.code,{children:"useLazyLoadQuery"})," to fetch additional information when that component is mounted."]}),"\n",(0,a.jsx)(t.p,{children:"There\u2019s just one problem: it always shows the same person's information, no matter which poster you hover over!"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Hovercard showing the wrong person",src:n(12653).A+"",width:"1256",height:"692"})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"query-variables",children:"Query Variables"}),"\n",(0,a.jsxs)(t.p,{children:["We need to tell the server ",(0,a.jsx)(t.em,{children:"which"})," information we want more information about. GraphQL lets us define ",(0,a.jsx)(t.em,{children:"query variables"})," that can be passed as arguments to specific fields. These arguments are then available on the server."]}),"\n",(0,a.jsxs)(t.p,{children:["In the previous section, we saw how a field can accept arguments, but the argument values were hard-coded, e.g. ",(0,a.jsx)(t.code,{children:"url(width: 200, height: 200)"}),". With query variables, we can determine these values at runtime. They\u2019re passed from the client to the server alongside the query itself. GraphQL variables always begin with a ",(0,a.jsx)(t.code,{children:"$"})," dollar sign."]}),"\n",(0,a.jsxs)(t.p,{children:["Take a look inside ",(0,a.jsx)(t.code,{children:"PosterDetailsHovercardContents.tsx"}),": you should see a query like this one:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'const PosterDetailsHovercardContentsQuery = graphql`\n  query PosterDetailsHovercardContentsQuery {\n    // color1\n    node(id: "1") {\n      // color2\n      ... on Actor {\n        ...PosterDetailsHovercardContentsBodyFragment\n      }\n    }\n  }\n`;\n'})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsxs)("span",{className:"color1",children:["The ",(0,a.jsx)("code",{children:"node"})," field"]})," is a top-level field defined in our schema that lets us fetch any graph node given its unique ID. It takes the ID as an argument, which is currently hard-coded. In this exercise, we\u2019ll be replacing this hard-coded ID with a variable supplied by our UI state."]}),"\n",(0,a.jsxs)(t.p,{children:["The funny-looking ",(0,a.jsx)(t.code,{children:"... on Actor"})," is a ",(0,a.jsx)("span",{className:"color2",children:(0,a.jsx)(t.em,{children:"type refinement"})}),". We\u2019ll look at these in more detail in the next section and can ignore it for now. In brief, since we could supply any ID at all to the ",(0,a.jsx)(t.code,{children:"node"})," field, there\u2019s no way to know statically what ",(0,a.jsx)(t.em,{children:"type"})," of node we\u2019d be selecting. The type refinement specifies what type we expect, allowing us to use fields from the ",(0,a.jsx)(t.code,{children:"Actor"})," type"]}),"\n",(0,a.jsx)(t.p,{children:"Within that, we simply spread a fragment that contains the fields we want to show \u2014 about which more later. For now, here are the steps to take to replace this hard-coded ID with the ID of the poster we\u2019re hovering over:"}),"\n",(0,a.jsx)(t.h3,{id:"step-1--define-a-query-variable",children:"Step 1 \u2014 define a query variable"}),"\n",(0,a.jsx)(t.p,{children:"First we need to edit our query to declare that it accepts a query variable. Here\u2019s the change:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'const PosterDetailsHovercardContentsQuery = graphql`\n  query PosterDetailsHovercardContentsQuery(\n    // change-line\n    $posterID: ID!\n  ) {\n    node(id: "1") {\n      ... on Actor {\n        ...PosterDetailsHovercardContentsBodyFragment\n      }\n    }\n  }\n`;\n'})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The variable name is ",(0,a.jsx)(t.code,{children:"$posterID"}),". This is the symbol we\u2019ll use within the rest of the GraphQL query to refer to the value passed in from the UI."]}),"\n",(0,a.jsxs)(t.li,{children:["Variables have a type \u2014 in this case ",(0,a.jsx)(t.code,{children:"ID!"}),(0,a.jsx)(t.em,{children:"."})," The ",(0,a.jsx)(t.code,{children:"ID"})," type is a synonym for ",(0,a.jsx)(t.code,{children:"String"})," that is used for node IDs to help distinguish them from other strings. The ",(0,a.jsx)(t.code,{children:"!"})," on ",(0,a.jsx)(t.code,{children:"ID!"})," means that field is non-nullable. In GraphQL, fields are normally nullable and non-nullability is the exception."]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"step-2--pass-the-variable-in-as-a-field-argument",children:"Step 2 \u2014 pass the variable in as a field argument"}),"\n",(0,a.jsxs)(t.p,{children:["Now we replace the hard-coded ",(0,a.jsx)(t.code,{children:'"1"'}),"  with our new variable:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"const PosterDetailsHovercardContentsQuery = graphql`\n  query PosterDetailsHovercardContentsQuery($posterID: ID!) {\n    node(\n      // change-line\n      id: $posterID\n    ) {\n    ... on Actor {\n      ...PosterDetailsHovercardContentsBodyFragment\n      }\n    }\n  }\n`;\n"})}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"You can use query variables not only as field arguments, but as arguments to fragments."})}),"\n",(0,a.jsx)(t.h3,{id:"step-3--provide-the-argument-value-to-uselazyloadquery",children:"Step 3 \u2014 provide the argument value to useLazyLoadQuery"}),"\n",(0,a.jsxs)(t.p,{children:["Now we need to pass in the actual value from our UI at runtime. The ",(0,a.jsx)(t.code,{children:"useLazyLoadQuery"})," hook\u2019s second argument is an object with variable values. We\u2019ll add a new prop to our component and pass its value in there:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"export default function PosterDetailsHovercardContents({\n  // change-line\n  posterID,\n}: {\n  // change-line\n  posterID: string;\n}): React.ReactElement {\n  const data = useLazyLoadQuery<QueryType>(\n    PosterDetailsHovercardContentsQuery,\n    // change-line\n    {posterID},\n  );\n  return <PosterDetailsHovercardContentsBody poster={data.node} />;\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"step-4--pass-the-id-in-from-the-parent-component",children:"Step 4 \u2014 pass the ID in from the parent component"}),"\n",(0,a.jsxs)(t.p,{children:["Now we need to supply the ",(0,a.jsx)(t.code,{children:"posterID"})," prop from the hovercard\u2019s parent component, which is ",(0,a.jsx)(t.code,{children:"PosterByline"}),". Head over to that file and add ",(0,a.jsx)(t.code,{children:"id"})," to its fragment \u2014 then pass the ID in as a prop:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"const PosterBylineFragment = graphql`\n  fragment PosterBylineFragment on Actor {\n    // change-line\n    id\n    ...\n  }\n`;\n\nexport default function PosterByline({ poster }: Props): React.ReactElement {\n  ...\n  return (\n   ...\n    <PosterDetailsHovercardContents\n      // change-line\n      posterID={data.id}\n    />\n   ...\n  );\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"At this point, the hovercard should show the appropriate information for each poster that we hover over."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Hovercard showing the correct person",src:n(24706).A+"",width:"1212",height:"712"})}),"\n",(0,a.jsx)(t.p,{children:"If you use the Network inspector in your browser, you should be able to find that the variable value is being passed alongside the query:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Network request inspcetor showing variable being set to the server",src:n(19341).A+"",width:"1444",height:"290"})}),"\n",(0,a.jsx)(t.p,{children:"You may also notice that this request is made only the first time you hover over a particular poster. Relay caches the results of the query and re-uses them after that, until eventually removing the cached data if it hasn\u2019t been used recently."}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"Deep dive: Caching and the Relay Store"}),(0,a.jsx)(t.p,{children:"In contrast to most other systems, Relay\u2019s caching is not based on queries, but on graph nodes. Relay maintains a local cache of all the nodes it has fetched called the Relay Store. Each node in the Store is identified and retrieved by its ID. If two queries ask for the same information, as identified by node IDs, then the second query will be fulfilled using the cached information retrieved for the first query, and not be fetched."}),(0,a.jsx)(t.p,{children:"Relay will garbage-collect nodes from the Store if they aren\u2019t \u201Creachable\u201D from any queries that are used, or have been recently used, by any mounted components."})]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"Deep dive: Why GraphQL Needs a Syntax for Variables"}),(0,a.jsxs)(t.p,{children:["You might be wondering why GraphQL even has the concept of variables, instead of just interpolating the value of the variables into the query string. Well, ",(0,a.jsx)(t.a,{href:"../queries-1",children:"as mentioned before"}),", the text of the GraphQL query string isn\u2019t available at runtime, because Relay replaces it with a data structure that is more efficient. You can also configure Relay to use ",(0,a.jsx)(t.a,{href:"/docs/v14.0.0/guides/persisted-queries/",children:"persisted queries"}),", where the compiler uploads each query to the server at build time and assigns it an ID \u2014 in that case, at runtime, Relay is just telling the server \u201CGive me query #1337\u201D, so string interpolation isn't possible and therefore the variables have to come out of band. Even when the query string is available, passing variable values separately eliminates any issues with serializing arbitrary values and escaping strings, above what is required with any HTTP request."]})]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"preloaded-queries",children:"Preloaded Queries"}),"\n",(0,a.jsx)(t.p,{children:"This example app is very simple, so performance isn't an issue. (In fact, the server is artifically slowed down in order to make loading states perceptible.) However, one of Relay's main concerns is to make performance as fast as possible in real apps."}),"\n",(0,a.jsxs)(t.p,{children:["Right now, the hovercard uses the ",(0,a.jsx)(t.code,{children:"useLazyLoadQuery"})," hook, which fetches the query when the component is rendered. That means the timeline looks something like this:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Network doesn&#39;t start until render",src:n(78285).A+"",width:"1548",height:"924"})}),"\n",(0,a.jsxs)(t.p,{children:["Ideally, we should start the network fetch as early as possible, but here we don't start it until React is finished rendering. This timeline could look even worse if we used ",(0,a.jsx)(t.code,{children:"React.lazy"})," to load the code for the hovercard component itself when the interaction happened. In that case, it would look like this:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Network doesn&#39;t start until component is fetched and then rendered",src:n(19257).A+"",width:"1872",height:"1024"})}),"\n",(0,a.jsx)(t.p,{children:"Notice how we\u2019re waiting around before we even start fetching the GraphQL query. It would be better if the query fetch began before the React component even rendered, right at the beginning in the mouse event handler itself. Then the timeline would look like this:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Network and component fetch happen concurrently",src:n(45680).A+"",width:"1836",height:"584"})}),"\n",(0,a.jsx)(t.p,{children:"When the user interacts, we should immediately start fetching the query we need, while also beginning to render the component (fetching its code first if needed). Once both of these async processes are complete, we can render the component with the data available and show it to the user."}),"\n",(0,a.jsxs)(t.p,{children:["Relay provides a feature called ",(0,a.jsx)(t.em,{children:"preloaded queries"})," that let us do this."]}),"\n",(0,a.jsx)(t.p,{children:"Let\u2019s modify the hovercard to use preloaded queries."}),"\n",(0,a.jsx)(t.h3,{id:"step-1--change-uselazyloadquery-to-usepreloadedquery",children:"Step 1 \u2014 change useLazyLoadQuery to usePreloadedQuery"}),"\n",(0,a.jsxs)(t.p,{children:["As a reminder, this is the ",(0,a.jsx)(t.code,{children:"PosterDetailsHovercardContents"})," component that currently fetches the data lazily:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"export default function PosterDetailsHovercardContents({\n  posterID,\n}: {\n  posterID: string;\n}): React.ReactElement {\n  const data = useLazyLoadQuery<QueryType>(\n    PosterDetailsHovercardContentsQuery,\n    {posterID},\n  );\n  return <PosterDetailsHovercardContentsBody data={data.node} />;\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["It calls ",(0,a.jsx)(t.code,{children:"useLazyLoadQuery"})," which accepts ",(0,a.jsx)(t.em,{children:"variables"})," as its second argument. We want to change this to ",(0,a.jsx)(t.code,{children:"usePreloadedQuery"}),". However, with preloaded queries, the variables are actually determined when the query is fetched, which will be before this component is even rendered. So instead of variables, this hook takes a ",(0,a.jsx)(t.em,{children:"query reference"})," that contains the information it needs to retrieve the results of the query. The query reference will be created when we fetch the query in Step 2."]}),"\n",(0,a.jsx)(t.p,{children:"Change the component as follows:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"import {usePreloadedQuery} from 'react-relay';\nimport type {PreloadedQuery} from 'react-relay';\nimport type {PosterDetailsHovercardContentsQuery as QueryType} from './__generated__/PosterDetailsHovercardContentsQuery.graphql';\n\nexport default function PosterDetailsHovercardContents({\n  // change-line\n  queryRef,\n}: {\n  // change-line\n  queryRef: PreloadedQuery<QueryType>,\n}): React.ReactElement {\n  // change-line\n  const data = usePreloadedQuery(\n    PosterDetailsHovercardContentsQuery,\n    // change-line\n    queryRef,\n  );\n  ...\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"step-2-export-the-query-for-access-from-the-parent-component",children:"Step 2: export the query for access from the parent component"}),"\n",(0,a.jsxs)(t.p,{children:["We\u2019ll be modifying the parent component, ",(0,a.jsx)(t.code,{children:"PosterByline"}),", to have it initiate the ",(0,a.jsx)(t.code,{children:"PosterDetailsHovercardContentsQuery"})," query. It needs a reference to that query, so we need to export it:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"export const PosterDetailsHovercardContentsQuery = graphql`...\n"})}),"\n",(0,a.jsx)(t.h3,{id:"step-3-call-usequeryloader-in-the-parent-component",children:"Step 3: Call useQueryLoader in the parent component"}),"\n",(0,a.jsxs)(t.p,{children:["Now that ",(0,a.jsx)(t.code,{children:"PosterDetailsHovercardContents"})," expects a query ref, we need to create that query ref and pass it down from the parent component, which is ",(0,a.jsx)(t.code,{children:"PosterByline"}),". We create the query ref using a hook called ",(0,a.jsx)(t.code,{children:"useQueryLoader"}),". This hook also returns a function that we call in our event handler to trigger the query fetch."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"import {useQueryLoader} from 'react-relay';\nimport type {PosterDetailsHovercardContentsQuery as HovercardQueryType} from './__generated__/PosterDetailsHovercardContentsQuery.graphql';\nimport {PosterDetailsHovercardContentsQuery} from './PosterDetailsHovercardContents';\n\nexport default function PosterByline({ poster }: Props): React.ReactElement {\n  ...\n  // change\n  const [\n    hovercardQueryRef,\n    loadHovercardQuery,\n  ] = useQueryLoader<HovercardQueryType>(PosterDetailsHovercardContentsQuery);\n  // end-change\n  return (\n   ...\n    <PosterDetailsHovercardContents\n      // change-line\n      queryRef={hovercardQueryRef}\n    />\n   ...\n  );\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"useQueryLoader"})," hook returns two things we need:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The query ref is an opaque piece of information that ",(0,a.jsx)(t.code,{children:"usePreloadedQuery"})," will use to retrieve the result of the query."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"loadHovercardQuery"})," is a function that will initiate the request."]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"step-4-fetch-the-query-in-the-event-handler",children:"Step 4: Fetch the query in the event handler"}),"\n",(0,a.jsxs)(t.p,{children:["Finally, we need to call ",(0,a.jsx)(t.code,{children:"loadHovercardQuery"})," in an event handler that happens when the card is shown. Luckily the ",(0,a.jsx)(t.code,{children:"Hovercard"})," component has a ",(0,a.jsx)(t.code,{children:"onBeginHover"})," event that we can use:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'export default function PosterByline({ poster }: Props): React.ReactElement {\n  ...\n  const [\n    hovercardQueryRef,\n    loadHovercardQuery,\n  ] = useQueryLoader<HovercardQueryType>(PosterDetailsHovercardContentsQuery);\n  // change\n  function onBeginHover() {\n    loadHovercardQuery({posterID: data.id});\n  }\n  // end-change\n  return (\n    <div className="byline">\n      ...\n      <Hovercard\n        // change-line\n        onBeginHover={onBeginHover}\n        targetRef={hoverRef}>\n        <PosterDetailsHovercardContents queryRef={hovercardQueryRef} />\n      </Hovercard>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"Note that the query variables are now passed in here where we initiate the request."}),"\n",(0,a.jsx)(t.p,{children:"At this point, you should see the same behavior as before, but now it will be a little bit faster since Relay can get the query started earlier."}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsxs)(t.p,{children:["Although we introduced queries using ",(0,a.jsx)(t.code,{children:"useLazyLoadQuery"})," for simplicity, preloaded queries are always the preferred way to use queries in Relay because they can significantly improve performance in the real world. With the appropriate ",(0,a.jsx)(t.a,{href:"https://github.com/relayjs/relay-examples/tree/main/issue-tracker-next-v13",children:"integrations with your server and router system"}),", you can even preload the main query for a webpage on the server side before you\u2019ve even downloaded or run any client code."]})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Although all of the data initially shown on a screen should be combined into one query, user interactions needing further information can be handled with secondary queries."}),"\n",(0,a.jsx)(t.li,{children:"Query variables let you pass information to the server along with your query."}),"\n",(0,a.jsx)(t.li,{children:"Query variables are used by passing them into field arguments."}),"\n",(0,a.jsx)(t.li,{children:"Preloaded queries are always the best way to go. For user interaction queries, initiate the fetch in the event handler. For the initial query for your screen, initiate the fetch as early as possible in your specific routing system. Use lazy-loaded queries only for quick prototyping, or not at all."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Next we'll briefly look at a way to enhance the hovecard by handling different types of posters differently. After that, we'll see how to handle situations where information that's part of the initial query also needs to be updated and refetched with different variables."})]})}function c(e={}){let{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},19341(e,t,n){n.d(t,{A:()=>r});let r=n.p+"assets/images/network-request-with-variables-685cd702f4b24496f003c6dc72a18310.png"},78285(e,t,n){n.d(t,{A:()=>r});let r=n.p+"assets/images/preloaded-basic-2693ff0ba53d8b3f7e5e905bc6a8d80d.png"},45680(e,t,n){n.d(t,{A:()=>r});let r=n.p+"assets/images/preloaded-ideal-cd02a128e114e8cbb8dd98f38b1646b1.png"},19257(e,t,n){n.d(t,{A:()=>r});let r=n.p+"assets/images/preloaded-lazy-b66d3f27f599118b87b8c917acbed796.png"},12653(e,t,n){n.d(t,{A:()=>r});let r=n.p+"assets/images/queries-wrong-hovercard-person-ca391a8bfc10666af0914b2c71577a32.png"},24706(e,t,n){n.d(t,{A:()=>r});let r=n.p+"assets/images/query-variables-hovercard-correct-4d9278160ae02a07df46a5c395659031.png"},28453(e,t,n){n.d(t,{R:()=>o,x:()=>i});var r=n(96540);let a={},s=r.createContext(a);function o(e){let t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);