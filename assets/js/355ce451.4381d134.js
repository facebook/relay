"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["52576"],{91242(e,t,n){n.r(t),n.d(t,{metadata:()=>r,default:()=>f,frontMatter:()=>c,contentTitle:()=>d,toc:()=>p,assets:()=>u});var r=JSON.parse('{"id":"guides/relay-resolvers/defining-types","title":"Defining Types","description":"How to define types for your client state schema","source":"@site/versioned_docs/version-v20.1.0/guides/relay-resolvers/defining-types.md","sourceDirName":"guides/relay-resolvers","slug":"/guides/relay-resolvers/defining-types/","permalink":"/docs/guides/relay-resolvers/defining-types/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v20.1.0/guides/relay-resolvers/defining-types.md","tags":[],"version":"v20.1.0","frontMatter":{"id":"defining-types","title":"Defining Types","slug":"/guides/relay-resolvers/defining-types/","description":"How to define types for your client state schema"},"sidebar":"docs","previous":{"title":"Enabling Relay Resolvers","permalink":"/docs/guides/relay-resolvers/enabling-resolvers"},"next":{"title":"Defining Fields","permalink":"/docs/guides/relay-resolvers/defining-fields/"}}'),a=n(74848),s=n(28453),l=n(17352),i=n(78010),o=n(57250);let c={id:"defining-types",title:"Defining Types",slug:"/guides/relay-resolvers/defining-types/",description:"How to define types for your client state schema"},d,u={},p=[{value:"Defining a \u201Cstrong\u201D type",id:"defining-a-strong-type",level:3},{value:"Defining a \u201Cweak\u201D type",id:"defining-a-weak-type",level:3},{value:"Implementing Abstract Types",id:"implementing-abstract-types",level:3}];function h(e){let t={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["You can think of client state resolvers as defining a GraphQL server that runs in the client. Just like with a server-defined GraphQL server you will need to define the ",(0,a.jsx)(t.em,{children:"types"})," that exist in your schema as well as the ",(0,a.jsx)(t.em,{children:"fields"}),' on those types. Just like a GraphQL server, fields are defined as functions that compute the GraphQL value from the parent object. In Relay Resolvers we call this parent JavaScript object the "model" of the type.']}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsx)(t.p,{children:'Each client state GraphQL type is backed by a JavaScript object type which these docs will refer to as its "model type". Resolvers "on" this type will be passed an instance of this type as their first argument.'})}),"\n",(0,a.jsxs)(t.p,{children:["Resolver types are defined using the ",(0,a.jsx)(t.code,{children:"@RelayResolver"})," tag followed by the name of the type you are defining. By default Relay assumes your client types are \u201Cstrong\u201D, meaning each instance has an ID which is unique within the type. This property allows Relay to apply a number of optimizations, such as memoizing resolver computation."]}),"\n",(0,a.jsx)(t.h3,{id:"defining-a-strong-type",children:"Defining a \u201Cstrong\u201D type"}),"\n",(0,a.jsx)(t.p,{children:"Strong types are defined by a docblock followed by an exported function whose name matches the type's name, and which accepts an ID as its only argument and returns an instance of the type\u2019s model. Resolvers that define edges to this type will simply need to return the ID of the object, rather than deriving the model themselves."}),"\n",(0,a.jsxs)(i.default,{groupId:"resolver",defaultValue:"Docblock",values:(0,l.fbContent)({internal:[{label:"Docblock",value:"Docblock"},{label:"Flow",value:"Flow"}],external:[{label:"Docblock",value:"Docblock"}]}),children:[(0,a.jsx)(o.default,{value:"Docblock",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"/**\n * @RelayResolver User\n */\nexport function User(id: DataID): UserModel {\n  return UserService.getById(id);\n}\n"})})}),(0,a.jsx)(o.default,{value:"Flow",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"/**\n * @RelayResolver\n */\nexport function User(id: DataID): UserModel {\n  return UserService.getById(id);\n}\n"})})})]}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsx)(t.p,{children:"Elsewhere in the docs this function is referred to as the \u201Cmodel resolver\u201D for the type."})}),"\n",(0,a.jsxs)(t.p,{children:["Generally objects in your client data store will be able to change over time. To support this Relay Resolvers support resolvers that subscribe to the underlying data source. To learn about this, see the page on ",(0,a.jsx)(t.a,{href:"/docs/guides/relay-resolvers/live-fields/",children:"Live Fields"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"defining-a-weak-type",children:"Defining a \u201Cweak\u201D type"}),"\n",(0,a.jsxs)(t.p,{children:["If your type does not have a unique identifier, you can define it as \u201Cweak\u201D by adding the ",(0,a.jsx)(t.code,{children:"@weak"})," docblock tag. Weak types are defined by a docblock followed by an exported type definition matching the types name. Resolvers that define edges to weak types will need to return a fully populated model object matching this type."]}),"\n",(0,a.jsxs)(i.default,{groupId:"resolver",defaultValue:"Docblock",values:(0,l.fbContent)({internal:[{label:"Docblock",value:"Docblock"},{label:"Flow",value:"Flow"}],external:[{label:"Docblock",value:"Docblock"}]}),children:[(0,a.jsx)(o.default,{value:"Docblock",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"/**\n * @RelayResolver ProfilePicture\n * @weak\n */\nexport type ProfilePicture = { url: string, height: number, width: number };\n"})})}),(0,a.jsx)(o.default,{value:"Flow",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"/**\n * @RelayResolver\n */\nexport type ProfilePicture = { url: string, height: number, width: number };\n"})})})]}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsx)(t.p,{children:'Generally weak types are used for creating a namespace for a set of fields that ultimately "belong" to a parent object.'})}),"\n",(0,a.jsx)(t.h3,{id:"implementing-abstract-types",children:"Implementing Abstract Types"}),"\n",(0,a.jsxs)(t.p,{children:["Relay Resolver types can implement ",(0,a.jsx)(t.a,{href:"https://relay.dev/docs/glossary/#abstract-type",children:"abstract types"})," defined in the graphql schema. Note, these abstract types can\nbe defined on your GraphQL server schema OR a ",(0,a.jsx)(t.a,{href:"https://relay.dev/docs/next/guides/client-schema-extensions/",children:"client side schema extension"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"For example, given the following interface:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-graphql",children:"# IUser.graphql\ninterface IUser {\n  name: String\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"You could define two (or more) concrete resolver types that implement the IUser interface by adding annotations in the docblock (the same applies for unions)."}),"\n",(0,a.jsx)(l.FbInternalOnly,{children:(0,a.jsx)(t.p,{children:"Note, support for abstract types is not available for relay resolvers in Flow syntax (yet)."})}),"\n",(0,a.jsx)(i.default,{groupId:"resolver",defaultValue:"Docblock",values:(0,l.fbContent)({internal:[{label:"Docblock",value:"Docblock"}],external:[{label:"Docblock",value:"Docblock"}]}),children:(0,a.jsx)(o.default,{value:"Docblock",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"/**\n * @RelayResolver BasicUser implements IUser\n */\nexport function BasicUser(id: DataID): BasicUserModel {\n  return { ...BasicUserService.getById(id), name: 'BasicUser1'};\n}\n\n/**\n * @RelayResolver SpecialUser implements IUser\n */\nexport function SpecialUser(id: DataID): SpecialUserModel {\n  return { ...SpecialUserService.getById(id), name: 'SpecalUser1'};\n}\n"})})})})]})}function f(e={}){let{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},57250(e,t,n){n.r(t),n.d(t,{default:()=>s});var r=n(74848);n(96540);var a=n(18215);function s({children:e,hidden:t,className:n}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,a.A)("tabItem_Ymn6",n),hidden:t,children:e})}},78010(e,t,n){n.r(t),n.d(t,{default:()=>b});var r=n(74848),a=n(96540),s=n(18215),l=n(88287),i=n(28584),o=n(99770),c=n(99989),d=n(96629),u=n(80618),p=n(41367);function h(e){return a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){let{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function f({value:e,tabValues:t}){return t.some(t=>t.value===e)}var y=n(19863);function m({className:e,block:t,selectedValue:n,selectValue:a,tabValues:l}){let o=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.a_)(),d=e=>{let t=e.currentTarget,r=l[o.indexOf(t)].value;r!==n&&(c(t),a(r))},u=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{let n=o.indexOf(e.currentTarget)+1;t=o[n]??o[0];break}case"ArrowLeft":{let n=o.indexOf(e.currentTarget)-1;t=o[n]??o[o.length-1]}}t?.focus()};return(0,r.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":t},e),children:l.map(({value:e,label:t,attributes:a})=>(0,r.jsx)("li",{role:"tab",tabIndex:n===e?0:-1,"aria-selected":n===e,ref:e=>{o.push(e)},onKeyDown:u,onClick:d,...a,className:(0,s.A)("tabs__item","tabItem_LNqP",a?.className,{"tabs__item--active":n===e}),children:t??e},e))})}function v({lazy:e,children:t,selectedValue:n}){let l=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){let e=l.find(e=>e.props.value===n);return e?(0,a.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,r.jsx)("div",{className:"margin-top--md",children:l.map((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==n}))})}function g(e){let t=function(e){let t,{defaultValue:n,queryString:r=!1,groupId:s}=e,l=function(e){let{values:t,children:n}=e;return(0,a.useMemo)(()=>{let e=t??h(n).map(({props:{value:e,label:t,attributes:n,default:r}})=>({value:e,label:t,attributes:n,default:r})),r=(0,u.XI)(e,(e,t)=>e.value===t.value);if(r.length>0)throw Error(`Docusaurus error: Duplicate values "${r.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`);return e},[t,n])}(e),[i,y]=(0,a.useState)(()=>(function({defaultValue:e,tabValues:t}){if(0===t.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!f({value:e,tabValues:t}))throw Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}let n=t.find(e=>e.default)??t[0];if(!n)throw Error("Unexpected error: 0 tabValues");return n.value})({defaultValue:n,tabValues:l})),[m,v]=function({queryString:e=!1,groupId:t}){let n=(0,o.W6)(),r=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,d.aZ)(r),(0,a.useCallback)(e=>{if(!r)return;let t=new URLSearchParams(n.location.search);t.set(r,e),n.replace({...n.location,search:t.toString()})},[r,n])]}({queryString:r,groupId:s}),[g,b]=function({groupId:e}){let t=e?`docusaurus.tab.${e}`:null,[n,r]=(0,p.Dv)(t);return[n,(0,a.useCallback)(e=>{t&&r.set(e)},[t,r])]}({groupId:s}),x=f({value:t=m??g,tabValues:l})?t:null;return(0,c.A)(()=>{x&&y(x)},[x]),{selectedValue:i,selectValue:(0,a.useCallback)(e=>{if(!f({value:e,tabValues:l}))throw Error(`Can't select invalid tab value=${e}`);y(e),v(e),b(e)},[v,b,l]),tabValues:l}}(e);return(0,r.jsxs)("div",{className:(0,s.A)(l.G.tabs.container,"tabs-container","tabList__CuJ"),children:[(0,r.jsx)(m,{...t,...e}),(0,r.jsx)(v,{...t,...e})]})}function b(e){let t=(0,y.default)();return(0,r.jsx)(g,{...e,children:h(e.children)},String(t))}},28453(e,t,n){n.d(t,{R:()=>l,x:()=>i});var r=n(96540);let a={},s=r.createContext(a);function l(e){let t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);