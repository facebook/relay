"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["16239"],{71530(e,t,s){s.r(t),s.d(t,{metadata:()=>a,default:()=>c,frontMatter:()=>i,contentTitle:()=>n,toc:()=>d,assets:()=>l});var a=JSON.parse('{"id":"guides/relay-resolvers/limitations","title":"Limitations","description":"Limitations of Relay Resolvers","source":"@site/versioned_docs/version-v17.0.0/guides/relay-resolvers/limitations.md","sourceDirName":"guides/relay-resolvers","slug":"/guides/relay-resolvers/limitations/","permalink":"/docs/v17.0.0/guides/relay-resolvers/limitations/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v17.0.0/guides/relay-resolvers/limitations.md","tags":[],"version":"v17.0.0","frontMatter":{"id":"limitations","title":"Limitations","slug":"/guides/relay-resolvers/limitations/","description":"Limitations of Relay Resolvers"},"sidebar":"docs","previous":{"title":"Deprecated","permalink":"/docs/v17.0.0/guides/relay-resolvers/deprecated/"},"next":{"title":"Testing Relay Components","permalink":"/docs/v17.0.0/guides/testing-relay-components/"}}'),o=s(74848),r=s(28453);let i={id:"limitations",title:"Limitations",slug:"/guides/relay-resolvers/limitations/",description:"Limitations of Relay Resolvers"},n,l={},d=[{value:"No context or info arguments",id:"no-context-or-info-arguments",level:2},{value:"No support for abstract types",id:"no-support-for-abstract-types",level:2},{value:"All fields must be nullable",id:"all-fields-must-be-nullable",level:2},{value:"Not all GraphQL constructs are supported",id:"not-all-graphql-constructs-are-supported",level:2},{value:"No support for mutations",id:"no-support-for-mutations",level:2},{value:"Resolvers are always evaluated lazily",id:"resolvers-are-always-evaluated-lazily",level:2},{value:"Verbose/awkward docblock syntax",id:"verboseawkward-docblock-syntax",level:2}];function u(e){let t={a:"a",code:"code",h2:"h2",p:"p",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Relay Resolvers are do have some limitations. Here we will collect a list of known limitations and provide alternatives where possible."}),"\n",(0,o.jsx)(t.h2,{id:"no-context-or-info-arguments",children:"No context or info arguments"}),"\n",(0,o.jsxs)(t.p,{children:["In a full GraphQL implementation, resolvers would have access to a ",(0,o.jsx)(t.code,{children:"context"})," and ",(0,o.jsx)(t.code,{children:"info"})," argument. These arguments are not available in Relay Resolvers today. Supporting context is something we would like to do in the future, but have not yet implemented."]}),"\n",(0,o.jsx)(t.h2,{id:"no-support-for-abstract-types",children:"No support for abstract types"}),"\n",(0,o.jsx)(t.p,{children:"Today it is not possible to define an interface or union with multiple concrete types using Relay Resolvers. This is something we would like to support in the future, but have not yet implemented."}),"\n",(0,o.jsx)(t.h2,{id:"all-fields-must-be-nullable",children:"All fields must be nullable"}),"\n",(0,o.jsxs)(t.p,{children:["Today all resolvers must be typed as nullable in order to support coercing errors to null without having to implement null bubbling. In the future we intend Resolvers to support some version of ",(0,o.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/discussions/1410",children:"strict semantic nullability"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"not-all-graphql-constructs-are-supported",children:"Not all GraphQL constructs are supported"}),"\n",(0,o.jsx)(t.p,{children:"Today Relay Resolvers only support a subset of GraphQL constructs. For example, it's not currently possible to define input types, enums or interfaces using Relay Resolvers."}),"\n",(0,o.jsx)(t.h2,{id:"no-support-for-mutations",children:"No support for mutations"}),"\n",(0,o.jsx)(t.p,{children:"Today Relay Resolvers only support the read path. Defining mutation fields is not yet supported. We are working to understand what it means to perform a mutation against a reactive schema, and hope to support them in the future."}),"\n",(0,o.jsx)(t.h2,{id:"resolvers-are-always-evaluated-lazily",children:"Resolvers are always evaluated lazily"}),"\n",(0,o.jsx)(t.p,{children:"Today Relay Resolvers are always evaluated lazily on a per-fragment basis. This has the advantage that if a resolver is not read, it will never be evaluated. However, it can lead to issues with waterfalls if your client schema ends up making async requests to fetch data as its read. We are actively exploring other execution strategies for Relay Resolvers, such as evaluating all fields in a query at request time, but expect the way resolvers are defined to remain stable."}),"\n",(0,o.jsx)(t.h2,{id:"verboseawkward-docblock-syntax",children:"Verbose/awkward docblock syntax"}),"\n",(0,o.jsx)(t.p,{children:"Today defining a resolver requires defining a function with a docblock which uses special syntax and duplicates information already specified in the function's name an types. Futher, in order to enforce that these values match up, Relay emits type assertions in its generated types. While these assertions do ensure safety, they are an awkward developer experience."}),"\n",(0,o.jsxs)(t.p,{children:["To address these issues we are exploring a more streamlined approach where names and types can be inferred from your Flow or TypeScript code similar to the approach taken by ",(0,o.jsx)(t.a,{href:"https://grats.capt.dev/",children:"Grats"}),". This syntax may become available in future versions of Relay."]})]})}function c(e={}){let{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},28453(e,t,s){s.d(t,{R:()=>i,x:()=>n});var a=s(96540);let o={},r=a.createContext(o);function i(e){let t=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function n(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);