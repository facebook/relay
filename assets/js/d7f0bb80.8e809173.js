"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[39238],{3905:(e,n,r)=>{r.r(n),r.d(n,{MDXContext:()=>s,MDXProvider:()=>p,mdx:()=>h,useMDXComponents:()=>c,withMDXComponents:()=>m});var t=r(67294);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var t in r)Object.prototype.hasOwnProperty.call(r,t)&&(e[t]=r[t])}return e},o.apply(this,arguments)}function l(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function i(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?l(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):l(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function d(e,n){if(null==e)return{};var r,t,a=function(e,n){if(null==e)return{};var r,t,a={},o=Object.keys(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||(a[r]=e[r]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=t.createContext({}),m=function(e){return function(n){var r=c(n.components);return t.createElement(e,o({},n,{components:r}))}},c=function(e){var n=t.useContext(s),r=n;return e&&(r="function"==typeof e?e(n):i(i({},n),e)),r},p=function(e){var n=c(e.components);return t.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},f=t.forwardRef((function(e,n){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),m=c(r),p=a,f=m["".concat(l,".").concat(p)]||m[p]||u[p]||o;return r?t.createElement(f,i(i({ref:n},s),{},{components:r})):t.createElement(f,i({ref:n},s))}));function h(e,n){var r=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=r.length,l=new Array(o);l[0]=f;var i={};for(var d in n)hasOwnProperty.call(n,d)&&(i[d]=n[d]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var s=2;s<o;s++)l[s]=r[s];return t.createElement.apply(null,l)}return t.createElement.apply(null,r)}f.displayName="MDXCreateElement"},50986:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>m,contentTitle:()=>d,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var t=r(83117),a=r(80102),o=(r(67294),r(3905)),l=["components"],i={id:"docblock-format",title:"Docblock Format",slug:"/api-reference/relay-resolvers/docblock-format/",description:"Docblock format for Relay Resolvers"},d=void 0,s={unversionedId:"api-reference/relay-resolvers/docblock-format",id:"version-v17.0.0/api-reference/relay-resolvers/docblock-format",title:"Docblock Format",description:"Docblock format for Relay Resolvers",source:"@site/versioned_docs/version-v17.0.0/api-reference/relay-resolvers/docblock-format.md",sourceDirName:"api-reference/relay-resolvers",slug:"/api-reference/relay-resolvers/docblock-format/",permalink:"/docs/v17.0.0/api-reference/relay-resolvers/docblock-format/",draft:!1,editUrl:"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v17.0.0/api-reference/relay-resolvers/docblock-format.md",tags:[],version:"v17.0.0",frontMatter:{id:"docblock-format",title:"Docblock Format",slug:"/api-reference/relay-resolvers/docblock-format/",description:"Docblock format for Relay Resolvers"},sidebar:"docs",previous:{title:"requestSubscription",permalink:"/docs/v17.0.0/api-reference/request-subscription/"},next:{title:"Runtime Functions",permalink:"/docs/v17.0.0/api-reference/relay-resolvers/runtime-functions/"}},m={},c=[{value:"<code>@RelayResolver TypeName</code>",id:"relayresolver-typename",level:2},{value:"<code>@RelayResolver TypeName.fieldName: FieldTypeName</code>",id:"relayresolver-typenamefieldname-fieldtypename",level:2},{value:"<code>@rootFragment</code>",id:"rootfragment",level:2},{value:"<code>@live</code>",id:"live",level:2},{value:"<code>@weak</code>",id:"weak",level:2},{value:"<code>@deprecated</code>",id:"deprecated",level:2},{value:"Descriptions",id:"descriptions",level:2}],p={toc:c};function u(e){var n=e.components,r=(0,a.Z)(e,l);return(0,o.mdx)("wrapper",(0,t.Z)({},p,r,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"Relay Resolvers allow you to define additional types and fields in your GraphQL schema that are backed by client-side data. To achieve this, the Relay compiler looks for special ",(0,o.mdx)("inlineCode",{parentName:"p"},"@RelayResolver")," docblocks in your code. These docblocks define the types and fields in your schema and also tell Relay where to find the resolver functions that implement them."),(0,o.mdx)("p",null,"For an overview of Relay Resolvers and how to think about them, see the ",(0,o.mdx)("a",{parentName:"p",href:"/docs/v17.0.0/guides/relay-resolvers/introduction"},"Relay Resolvers")," guide. This page documents the different docblock tags that the Relay compiler looks for, and how to use them."),(0,o.mdx)("admonition",{title:"The Relay compiler only looks at docblocks which include the",type:"note"},(0,o.mdx)("p",{parentName:"admonition"},(0,o.mdx)("inlineCode",{parentName:"p"},"@RelayResolver")," tag. Any other docblocks will be ignored.")),(0,o.mdx)("h2",{id:"relayresolver-typename"},(0,o.mdx)("inlineCode",{parentName:"h2"},"@RelayResolver TypeName")),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"@RelayResolver")," tag followed by a single name defines a new GraphQL type in your schema. By default it is expected to be followed by an exported function whose name matches the type name. The function should accept an ID as its sole argument and return the JavaScript model/object which is the backing data for the type. See ",(0,o.mdx)("a",{parentName:"p",href:"#weak"},(0,o.mdx)("inlineCode",{parentName:"a"},"@weak"))," for an alternative way to define the backing data for a type."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-tsx"},"/**\n * @RelayResolver User\n */\nexport function User(id): UserModel {\n  return UserModel.getById(id);\n}\n")),(0,o.mdx)("p",null,"See the ",(0,o.mdx)("a",{parentName:"p",href:"/docs/v17.0.0/guides/relay-resolvers/defining-types/"},"Defining Types")," guide for more information."),(0,o.mdx)("h2",{id:"relayresolver-typenamefieldname-fieldtypename"},(0,o.mdx)("inlineCode",{parentName:"h2"},"@RelayResolver TypeName.fieldName: FieldTypeName")),(0,o.mdx)("p",null,"If the typename in a ",(0,o.mdx)("inlineCode",{parentName:"p"},"@RelayResolver")," tag is followed by a dot and then a field definition, it defines a new field on the type. The portion following the ",(0,o.mdx)("inlineCode",{parentName:"p"},".")," is expected to follow GraphQL's\n",(0,o.mdx)("a",{parentName:"p",href:"https://spec.graphql.org/June2018/#FieldDefinition"},"schema definition language"),"."),(0,o.mdx)("p",null,"Field definitions are expected to be followed by an exported function whose name matches the field name. The function should accept the model/object returned by the type resolver as its sole argument and return the value of the field."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-tsx"},"/**\n * @RelayResolver User.name: String\n */\nexport function name(user: UserModel): string {\n  return user.name;\n}\n")),(0,o.mdx)("p",null,"See the ",(0,o.mdx)("a",{parentName:"p",href:"/docs/v17.0.0/guides/relay-resolvers/defining-fields/"},"Defining Fields")," guide for more information."),(0,o.mdx)("h2",{id:"rootfragment"},(0,o.mdx)("inlineCode",{parentName:"h2"},"@rootFragment")),(0,o.mdx)("p",null,"Relay Resolvers may also be used to model data that is derived from other data in the graph. These fields will be automatically recomputed by Relay when the data they depend on changes."),(0,o.mdx)("p",null,"To define a derived field, use the ",(0,o.mdx)("inlineCode",{parentName:"p"},"@rootFragment")," tag on an existing field\ndefinition, and follow it with the name of a fragment that defines the data that the field depends on. The resolver function for the field will be passed a fragment key which can be used to read the fragment data using ",(0,o.mdx)("inlineCode",{parentName:"p"},"readFragment()"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-tsx"},"import {readFragment} from 'relay-runtime';\n\n/**\n * @RelayResolver User.fullName: String\n * @rootFragment UserFullNameFragment\n */\nexport function fullName(key: UserFullNameFragment$key): string {\n  const user = readFragment(\n    graphql`\n      fragment UserFullNameFragment on User {\n        firstName\n        lastName\n      }\n    `,\n    key,\n  );\n  return `${user.firstName} ${user.lastName}`;\n}\n")),(0,o.mdx)("p",null,"See ",(0,o.mdx)("a",{parentName:"p",href:"/docs/v17.0.0/guides/relay-resolvers/derived-fields/"},"Derived Fields")," for more information."),(0,o.mdx)("h2",{id:"live"},(0,o.mdx)("inlineCode",{parentName:"h2"},"@live")),(0,o.mdx)("p",null,"When modeling client state that can change over time, a resolver function which returns a single value is not sufficient. To accommodate this, Relay Resolvers allow you to define a field that returns a stream of values over time. This is done by adding the ",(0,o.mdx)("inlineCode",{parentName:"p"},"@live")," tag to a ",(0,o.mdx)("em",{parentName:"p"},"field or type definition"),"."),(0,o.mdx)("p",null,(0,o.mdx)("inlineCode",{parentName:"p"},"@live")," resolvers must return an object with the shape of a ",(0,o.mdx)("inlineCode",{parentName:"p"},"LiveStateValue")," to allow Relay to read the current value and subscribe to changes."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-tsx"},"import type {LiveState} from 'relay-runtime';\n\n/**\n * @RelayResolver Query.counter: Int\n * @live\n */\nexport function counter(): LiveState<number> {\n  return {\n    read: () => store.getState().counter,\n    subscribe: cb => {\n      return store.subscribe(cb);\n    },\n  };\n}\n")),(0,o.mdx)("p",null,"See the ",(0,o.mdx)("a",{parentName:"p",href:"/docs/v17.0.0/guides/relay-resolvers/live-fields/"},"Live Fields")," guide for\nmore information."),(0,o.mdx)("h2",{id:"weak"},(0,o.mdx)("inlineCode",{parentName:"h2"},"@weak")),(0,o.mdx)("p",null,"By default, Relay Resolvers expect the backing data for a type to be returned by a resolver function. However, in some cases objects of a given type may not have identifiers. In this case, you can use the ",(0,o.mdx)("inlineCode",{parentName:"p"},"@RelayResolver TypeName")," syntax described above followed by the tag ",(0,o.mdx)("inlineCode",{parentName:"p"},"@weak"),' to define a "weak" type.'),(0,o.mdx)("p",null,"Weak type declarations are expected to be followed by an exported type\ndefinition whose name matches the type name."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-tsx"},"/**\n * @RelayResolver ProfilePicture\n * @weak\n */\nexport type ProfilePicture = {\n  url: string;\n  width: number;\n  height: number;\n};\n")),(0,o.mdx)("p",null,"See the ","[Weak Types]","(/docs/v17.0.0/guides/relay-resolvers/defining-types/#Defining a \u201cweak\u201d type) guide for more information including how to define an edge to a weak type."),(0,o.mdx)("h2",{id:"deprecated"},(0,o.mdx)("inlineCode",{parentName:"h2"},"@deprecated")),(0,o.mdx)("p",null,"Just like the GraphQL schema definition language, Relay Resolvers support the ",(0,o.mdx)("inlineCode",{parentName:"p"},"@deprecated")," tag to mark a field as deprecated. The tag may be followed by a string which will be used as the deprecation reason. Deprecated fields will\nreceive special treatment in the editor if you are using the\n",(0,o.mdx)("a",{parentName:"p",href:"/docs/v17.0.0/editor-support/"},"Relay VSCode extension"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-tsx"},"/**\n * @RelayResolver User.name: String\n * @deprecated Use `fullName` instead.\n */\nexport function name(user: UserModel): string {\n  return user.name;\n}\n")),(0,o.mdx)("p",null,"See the ",(0,o.mdx)("a",{parentName:"p",href:"/docs/v17.0.0/guides/relay-resolvers/deprecated/"},"Deprecated")," guide for more information."),(0,o.mdx)("h2",{id:"descriptions"},"Descriptions"),(0,o.mdx)("p",null,"Any free text in the docblock (text not following a tag) will be used as the description for the type or field. This description will be surfaced in the editor if you are using the ",(0,o.mdx)("a",{parentName:"p",href:"/docs/v17.0.0/editor-support/"},"Relay VSCode extension"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-tsx"},"/**\n * @RelayResolver User.name: String\n *\n * What's in a name? That which we call a rose by any other name would smell\n * just as sweet.\n */\nexport function name(user: UserModel): string {\n  return user.name;\n}\n")),(0,o.mdx)("p",null,"See the ",(0,o.mdx)("a",{parentName:"p",href:"/docs/v17.0.0/guides/relay-resolvers/descriptions/"},"Descriptions")," guide for more information."))}u.isMDXComponent=!0}}]);