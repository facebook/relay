"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["73723"],{6151(e,t,n){n.r(t),n.d(t,{metadata:()=>i,default:()=>m,frontMatter:()=>d,contentTitle:()=>c,toc:()=>h,assets:()=>l});var i=JSON.parse('{"id":"guided-tour/updating-data/graphql-mutations","title":"GraphQL Mutations","description":"Relay guide to GraphQl mutations","source":"@site/versioned_docs/version-v13.0.0/guided-tour/updating-data/graphql-mutations.md","sourceDirName":"guided-tour/updating-data","slug":"/guided-tour/updating-data/graphql-mutations/","permalink":"/docs/v13.0.0/guided-tour/updating-data/graphql-mutations/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v13.0.0/guided-tour/updating-data/graphql-mutations.md","tags":[],"version":"v13.0.0","frontMatter":{"id":"graphql-mutations","title":"GraphQL Mutations","slug":"/guided-tour/updating-data/graphql-mutations/","description":"Relay guide to GraphQl mutations","keywords":["mutation"]},"sidebar":"docs","previous":{"title":"Introduction","permalink":"/docs/v13.0.0/guided-tour/updating-data/"},"next":{"title":"GraphQL Subscriptions","permalink":"/docs/v13.0.0/guided-tour/updating-data/graphql-subscriptions/"}}'),o=n(74848),a=n(28453),r=n(86898),s=n(17352);let d={id:"graphql-mutations",title:"GraphQL Mutations",slug:"/guided-tour/updating-data/graphql-mutations/",description:"Relay guide to GraphQl mutations",keywords:["mutation"]},c,l={},h=[{value:"Writing Mutations",id:"writing-mutations",level:2},{value:"Updating data once a request is complete",id:"updating-data-once-a-request-is-complete",level:2},{value:"Updater functions",id:"updater-functions",level:2},{value:"Optimistic updates",id:"optimistic-updates",level:2},{value:"Optimistic Response",id:"optimistic-response",level:3},{value:"Optimistic updater",id:"optimistic-updater",level:3},{value:"Order of execution of updater functions",id:"order-of-execution-of-updater-functions",level:2},{value:"Full example",id:"full-example",level:3},{value:"Invalidating data during a mutation",id:"invalidating-data-during-a-mutation",level:2},{value:"Handling errors",id:"handling-errors",level:2},{value:"Surfacing mutation level errors",id:"surfacing-mutation-level-errors",level:3},{value:"Surfacing field level errors",id:"surfacing-field-level-errors",level:3},{value:"Mutation queueing",id:"mutation-queueing",level:2}];function u(e){let t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["In GraphQL, data in the server is updated using ",(0,o.jsx)(t.a,{href:"https://graphql.org/learn/queries/#mutations",children:"GraphQL Mutations"}),". Mutations are ",(0,o.jsx)(t.em,{children:"read-write"})," server operations, which both modify data on the backend, and allow querying for the modified data from the server in the same request."]}),"\n",(0,o.jsx)(t.h2,{id:"writing-mutations",children:"Writing Mutations"}),"\n",(0,o.jsxs)(t.p,{children:["A GraphQL mutation looks very similar to a query, with the exception that it uses the ",(0,o.jsx)(t.code,{children:"mutation"})," keyword:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-graphql",children:"mutation FeedbackLikeMutation($input: FeedbackLikeData!) {\n  feedback_like(data: $input) {\n    feedback {\n      id\n      viewer_does_like\n      like_count\n    }\n  }\n}\n"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:['The mutation above modifies the server data to "like" the specified ',(0,o.jsx)(t.code,{children:"Feedback"})," object. ",(0,o.jsx)(t.code,{children:"feedback_like"})," is a ",(0,o.jsx)(t.em,{children:"mutation root field"})," (or just ",(0,o.jsx)(t.em,{children:"mutation field"}),"), which takes specific input and will be processed by the server to update the relevant data on the backend."]}),"\n",(0,o.jsx)(t.li,{children:"A mutation is handled in two separate steps: first, the update is processed on the server, and then the query is executed. This ensures that you only see data that has already been updated as part of your mutation response."}),"\n",(0,o.jsxs)(t.li,{children:["The mutation field (in this case, ",(0,o.jsx)(t.code,{children:"feedback_like"}),") returns a specific GraphQL type which exposes the data for which we can query in the mutation response."]}),"\n"]}),"\n",(0,o.jsx)(s.FbInternalOnly,{children:(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["The fields you can access on the mutation field are not automatically the same fields you can access in a regular query. ",(0,o.jsx)(t.a,{href:"https://fb.workplace.com/groups/644933736023601/?multi_permalinks=823422684841371",children:"It is a best practice"})," to include the ",(0,o.jsx)(t.code,{children:"viewer"})," object and all updated Ents as part of the mutation response."]}),"\n"]})}),"\n",(0,o.jsx)(s.OssOnly,{children:(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["The fields you can access on the mutation field are not automatically the same fields you can access in a regular query. It is a best practice to include the ",(0,o.jsx)(t.code,{children:"viewer"})," object and all updated entities as part of the mutation response."]}),"\n"]})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["In this case, we're querying for the ",(0,o.jsx)(t.em,{children:"updated"})," feedback object, including the updated ",(0,o.jsx)(t.code,{children:"like_count"})," and the updated value for ",(0,o.jsx)(t.code,{children:"viewer_does_like"}),", indicating whether the current viewer likes the feedback object."]}),"\n"]}),"\n",(0,o.jsx)(s.FbInternalOnly,{children:(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Check out the ",(0,o.jsx)(t.a,{href:"https://www.internalfb.com/intern/wiki/Graphql-for-hack-developers/mutation-root-fields/",children:"Hack documentation on writing mutations"})," for information on how to add a mutation field to your backend code."]}),"\n"]})}),"\n",(0,o.jsx)(t.p,{children:"An example of a successful response for the above mutation could look like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-json",children:'{\n  "feedback_like": {\n    "feedback": {\n      "id": "feedback-id",\n      "viewer_does_like": true,\n      "like_count": 1,\n    }\n  }\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["In Relay, we can declare GraphQL mutations using the ",(0,o.jsx)(t.code,{children:"graphql"})," tag too:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"const {graphql} = require('react-relay');\n\nconst feedbackLikeMutation = graphql`\n  mutation FeedbackLikeMutation($input: FeedbackLikeData!) {\n    feedback_like(data: $input) {\n      feedback {\n        id\n        viewer_does_like\n        like_count\n      }\n    }\n  }\n`;\n"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Note that mutations can also reference GraphQL ",(0,o.jsx)(t.a,{href:"../../rendering/variables/",children:"variables"})," in the same way queries or fragments do."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["In order to ",(0,o.jsx)(t.em,{children:"execute"})," a mutation against the server in Relay, we can use the ",(0,o.jsx)(t.code,{children:"commitMutation"})," and ",(0,o.jsx)(t.a,{href:"../../../api-reference/use-mutation",children:"useMutation"})," APIs. Let's take a look at an example using the ",(0,o.jsx)(t.code,{children:"commitMutation"})," API:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"import type {Environment} from 'react-relay';\nimport type {FeedbackLikeData, FeedbackLikeMutation} from 'FeedbackLikeMutation.graphql';\n\nconst {commitMutation, graphql} = require('react-relay');\n\nfunction commitFeedbackLikeMutation(\n  environment: Environment,\n  input: FeedbackLikeData,\n) {\n  return commitMutation<FeedbackLikeMutation>(environment, {\n    mutation: graphql`\n      mutation FeedbackLikeMutation($input: FeedbackLikeData!) {\n        feedback_like(data: $input) {\n          feedback {\n            id\n            viewer_does_like\n            like_count\n          }\n        }\n      }\n    `,\n    variables: {input},\n    onCompleted: response => {} /* Mutation completed */,\n    onError: error => {} /* Mutation errored */,\n  });\n}\n\nmodule.exports = {commit: commitFeedbackLikeMutation};\n"})}),"\n",(0,o.jsx)(t.p,{children:"Let's distill what's happening here:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"commitMutation"})," takes an environment, the ",(0,o.jsx)(t.code,{children:"graphql"})," tagged  mutation, and the variables to use for sending the mutation request to the server."]}),"\n",(0,o.jsxs)(t.li,{children:["Note that the ",(0,o.jsx)(t.code,{children:"input"})," for the mutation can be Flow-typed with the autogenerated type available from the ",(0,o.jsx)(t.em,{children:(0,o.jsx)(t.code,{children:"FeedbackLikeMutation.graphql"})})," module. In general, the Relay will generate Flow types for mutations at build time, with the following naming format: ",(0,o.jsx)(t.code,{children:"*<mutation_name>*.graphql.js"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["Note that ",(0,o.jsx)(t.code,{children:"variables"}),", ",(0,o.jsx)(t.code,{children:"response"})," in ",(0,o.jsx)(t.code,{children:"onCompleted"}),", and ",(0,o.jsx)(t.code,{children:"optimisticResponse"})," will be typed by providing a single autogenerated type, such as ",(0,o.jsx)(t.code,{children:"FeedbackLikeMutation"})," from the ",(0,o.jsx)(t.code,{children:"FeedbackLikeMutation.graphql"})," module."]}),"\n",(0,o.jsxs)(t.li,{children:["To also strongly type the ",(0,o.jsx)(t.code,{children:"optimisticResponse"})," field, a ",(0,o.jsx)(t.code,{children:"@raw_response_type"})," directive should be added to the mutation query root."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"commitMutation"})," also takes ",(0,o.jsx)(t.code,{children:"onCompleted"})," and ",(0,o.jsx)(t.code,{children:"onError"})," callbacks, which will be called when the request completes successfully or when an error occurs, respectively."]}),"\n",(0,o.jsxs)(t.li,{children:["When the mutation response is received, any objects in the mutation response with ",(0,o.jsx)(t.code,{children:"id"})," fields that match records in the local store will ",(0,o.jsx)(t.em,{children:"automatically"})," be updated with the new field values from the response. In this case, it would automatically find the existing ",(0,o.jsx)(t.code,{children:"Feedback"})," object matching the given id in the store, and update the values for its ",(0,o.jsx)(t.code,{children:"viewer_does_like"})," and ",(0,o.jsx)(t.code,{children:"like_count"})," fields."]}),"\n",(0,o.jsx)(t.li,{children:"Note that any local data updates caused by the mutation will automatically cause components subscribed to the data to be notified of the change and re-render."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"updating-data-once-a-request-is-complete",children:"Updating data once a request is complete"}),"\n",(0,o.jsx)(t.p,{children:"There are four ways in which store data is updated when a request is complete:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["If a field is queried from within the mutation field and includes an id field, that record in the local store will automatically be updated with the new values from the response. In the example, because the query includes ",(0,o.jsx)(t.code,{children:"feedback"})," and ",(0,o.jsx)(t.code,{children:"id"}),", Relay will find the existing ",(0,o.jsx)(t.code,{children:"Feedback"})," object that matches the given ID in the store, and update the values for its ",(0,o.jsx)(t.code,{children:"viewer_does_like"})," and ",(0,o.jsx)(t.code,{children:"like_count"})," fields.","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Note that instead of refetching a fragment after a mutation completes, you can often spread the fragment into the mutation response in order to update the fragment's data as part of the same request."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["If a field is queried from within the mutation field and includes an id field which has the ",(0,o.jsx)(t.code,{children:"@deleteRecord"})," directive, that field will be removed from the store."]}),"\n",(0,o.jsxs)(t.li,{children:["If an edge field is queried from within the mutation field and includes the ",(0,o.jsx)(t.code,{children:"@prependEdge"})," or ",(0,o.jsx)(t.code,{children:"@appendEdge"})," directives, that edge will be prepended or appended to a connection, respectively."]}),"\n",(0,o.jsx)(t.li,{children:"Lastly, for all updates not covered by the previous three bullet points, updater functions give you full control over how the data in the local store is updated when the request completes."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["See the ",(0,o.jsx)(t.a,{href:"#order-of-execution-of-updater-functions",children:"order of execution section"})," for information on what happens when Relay encounters multiple ways to update the data in the store."]}),"\n",(0,o.jsx)(t.h2,{id:"updater-functions",children:"Updater functions"}),"\n",(0,o.jsxs)(t.p,{children:["If the updates you wish to perform on the local data are more complex than just updating the values of fields and cannot be handled by the declarative mutation directives, you can provide an ",(0,o.jsx)(t.code,{children:"updater"})," function to ",(0,o.jsx)(t.code,{children:"commitMutation"})," or ",(0,o.jsx)(t.code,{children:"useMutation"})," for full control over how to update the store:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"import type {Environment} from 'react-relay';\nimport type {CommentCreateData, CreateCommentMutation} from 'CreateCommentMutation.graphql';\n\nconst {commitMutation, graphql} = require('react-relay');\nconst {ConnectionHandler} = require('relay-runtime');\n\nfunction commitCommentCreateMutation(\n  environment: Environment,\n  feedbackID: string,\n  input: CommentCreateData,\n) {\n  return commitMutation<CreateCommentMutation>(environment, {\n    mutation: graphql`\n      mutation CreateCommentMutation($input: CommentCreateData!) {\n        comment_create(input: $input) {\n          comment_edge {\n            cursor\n            node {\n              body {\n                text\n              }\n            }\n          }\n        }\n      }\n    `,\n    variables: {input},\n    onCompleted: () => {},\n    onError: error => {},\n    updater: store => {\n      const feedbackRecord = store.get(feedbackID);\n\n      // Get connection record\n      const connectionRecord = ConnectionHandler.getConnection(\n        feedbackRecord,\n        'CommentsComponent_comments_connection',\n      );\n\n      // Get the payload returned from the server\n      const payload = store.getRootField('comment_create');\n\n      // Get the edge inside the payload\n      const serverEdge = payload.getLinkedRecord('comment_edge');\n\n      // Build edge for adding to the connection\n      const newEdge = ConnectionHandler.buildConnectionEdge(\n        store,\n        connectionRecord,\n        serverEdge,\n      );\n\n      // Add edge to the end of the connection\n      ConnectionHandler.insertEdgeAfter(\n        connectionRecord,\n        newEdge,\n      );\n    },\n  });\n}\n\nmodule.exports = {commit: commitCommentCreateMutation};\n"})}),"\n",(0,o.jsx)(t.p,{children:"Let's distill this example:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"updater"})," takes a ",(0,o.jsx)(t.em,{children:(0,o.jsx)(t.code,{children:"store"})})," argument, which is an instance of a ",(0,o.jsx)(t.a,{href:"../../../api-reference/store/",children:(0,o.jsx)(t.code,{children:"RecordSourceSelectorProxy"})}),";  this interface allows you to ",(0,o.jsx)(t.em,{children:"imperatively"})," write and read data directly to and from the Relay store. This means that you have full control over how to update the store in response to the mutation response: you can ",(0,o.jsx)(t.em,{children:"create entirely new records"}),", or ",(0,o.jsx)(t.em,{children:"update or delete existing ones"}),".","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"updater"})," takes a second ",(0,o.jsx)(t.em,{children:(0,o.jsx)(t.code,{children:"payload"})})," argument, which is the mutation response object. This can be used to retrieve the payload data without interacting with the ",(0,o.jsx)(t.em,{children:(0,o.jsx)(t.code,{children:"store"})}),"."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["In our specific example, we're adding a new comment to our local store after it has successfully been added on the server. Specifically, we're adding a new item to a connection; for more details on the specifics of how that works, check out our section on ",(0,o.jsx)(t.a,{href:"../../list-data/updating-connections/",children:"adding and removing items from a connection"}),".","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["There is no need for an updater in this example \u2014 it would be a great place to use the ",(0,o.jsx)(t.code,{children:"@appendEdge"})," directive instead!"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["Note that the mutation response is a ",(0,o.jsx)(t.em,{children:"root field"})," record that can be read from the ",(0,o.jsx)(t.code,{children:"store"}),", specifically using the ",(0,o.jsx)(t.code,{children:"store.getRootField"})," API. In our case, we're reading the ",(0,o.jsx)(t.code,{children:"comment_create"})," root field, which is a root field in the mutation response."]}),"\n",(0,o.jsxs)(t.li,{children:["Note that the ",(0,o.jsx)(t.code,{children:"root"})," field of the mutation is different from the ",(0,o.jsx)(t.code,{children:"root"})," of queries, and ",(0,o.jsx)(t.code,{children:"store.getRootField"})," in the mutation updater can only get the record from the mutation response. To get records from the root that's not in the mutation response, use ",(0,o.jsx)(t.code,{children:"store.getRoot().getLinkedRecord"})," instead."]}),"\n",(0,o.jsxs)(t.li,{children:["Note that any local data updates caused by the mutation ",(0,o.jsx)(t.code,{children:"updater"})," will automatically cause components subscribed to the data to be notified of the change and re-render."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"optimistic-updates",children:"Optimistic updates"}),"\n",(0,o.jsx)(t.p,{children:"Oftentimes, we don't want to wait for the server response to complete before we respond to user interaction. For example, if a user clicks the \"Like\" button, we don't want to wait until the mutation response comes back before we show them that the post has been liked; ideally, we'd do that instantly."}),"\n",(0,o.jsxs)(t.p,{children:["More generally, in these cases we want to immediately ** update our local data ",(0,o.jsx)(t.em,{children:"optimistically,"})," in order to improve perceived responsiveness; that is, we want to update our local data to immediately reflect what it would look like after the mutation ",(0,o.jsx)(t.em,{children:"succeeds"}),". If the mutation ends up ",(0,o.jsx)(t.em,{children:"not"})," succeeding, we can roll back the change and show an error message, but we're ",(0,o.jsx)(t.em,{children:"optimistically"})," expecting the mutation to succeed most of the time."]}),"\n",(0,o.jsx)(t.p,{children:"In order to do this, Relay provides two APIs to specify an optimistic update when executing a mutation:"}),"\n",(0,o.jsx)(t.h3,{id:"optimistic-response",children:"Optimistic Response"}),"\n",(0,o.jsxs)(t.p,{children:["When you can predict what the server response for a mutation is going to be, the simplest way to optimistically update the store is by providing an ",(0,o.jsx)(t.code,{children:"optimisticResponse"})," to ",(0,o.jsx)(t.code,{children:"commitMutation"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"import type {Environment} from 'react-relay';\nimport type {FeedbackLikeData, FeedbackLikeMutation} from 'FeedbackLikeMutation.graphql';\n\nconst {commitMutation, graphql} = require('react-relay');\n\nfunction commitFeedbackLikeMutation(\n  environment: Environment,\n  feedbackID: string,\n  input: FeedbackLikeData,\n) {\n  return commitMutation<FeedbackLikeMutation>(environment, {\n    mutation: graphql`\n      mutation FeedbackLikeMutation($input: FeedbackLikeData!)\n        @raw_response_type {\n        feedback_like(data: $input) {\n          feedback {\n            id\n            viewer_does_like\n          }\n        }\n      }\n    `,\n    variables: {input},\n    optimisticResponse: {\n      feedback_like: {\n        feedback: {\n          id: feedbackID,\n          viewer_does_like: true,\n        },\n      },\n    },\n    onCompleted: () => {} /* Mutation completed */,\n    onError: error => {} /* Mutation errored */,\n  });\n}\n\nmodule.exports = {commit: commitFeedbackLikeMutation};\n"})}),"\n",(0,o.jsx)(t.p,{children:"Let's see what's happening in this example."}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["The ",(0,o.jsx)(t.code,{children:"optimisticResponse"})," is an object matching the shape of the mutation response, and it simulates a successful response from the server. When ",(0,o.jsx)(t.code,{children:"optimisticResponse"}),", is provided, Relay will automatically process the response in the same way it would process the response from the server, and update the data accordingly (i.e. update the values of fields for the record with the matching id).","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["In this case, we would immediately set the ",(0,o.jsx)(t.code,{children:"viewer_does_like"})," field to ",(0,o.jsx)(t.code,{children:"true"})," in our ",(0,o.jsx)(t.code,{children:"Feedback"})," object, which would be immediately reflected in our UI."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["If the mutation ",(0,o.jsx)(t.em,{children:"succeeds"}),", ",(0,o.jsx)(t.em,{children:"the optimistic update will be rolled back,"})," and the server response will be applied."]}),"\n",(0,o.jsxs)(t.li,{children:["If the mutation ",(0,o.jsx)(t.em,{children:"fails"}),", ",(0,o.jsx)(t.em,{children:"the optimistic update will be rolled back,"})," and the error will be communicated via the ",(0,o.jsx)(t.code,{children:"onError"})," callback."]}),"\n",(0,o.jsxs)(t.li,{children:["Note that by adding ",(0,o.jsx)(t.code,{children:"@raw_response_type"})," directive,  the type for ",(0,o.jsx)(t.code,{children:"optimisticResponse"})," is generated."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"optimistic-updater",children:"Optimistic updater"}),"\n",(0,o.jsxs)(t.p,{children:["However, in some cases we can't statically predict what the server response will be, or we need to optimistically perform more complex updates, like deleting or creating new records, or ",(0,o.jsx)(t.a,{href:"../../list-data/updating-connections/",children:"adding and removing items from a connection"}),". In these cases we can provide an ",(0,o.jsx)(t.code,{children:"optimisticUpdater"})," function to ",(0,o.jsx)(t.code,{children:"commitMutation"}),". For example, in addition to setting ",(0,o.jsx)(t.code,{children:"viewer_does_like"})," to true, we can increment the ",(0,o.jsx)(t.code,{children:"like_count"})," field by using an ",(0,o.jsx)(t.code,{children:"optimisticUpdater"})," instead of an ",(0,o.jsx)(t.code,{children:"optimisticResponse"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"import type {Environment} from 'react-relay';\nimport type {FeedbackLikeData} from 'FeedbackLikeMutation.graphql';\n\nconst {commitMutation, graphql} = require('react-relay');\n\nfunction commitFeedbackLikeMutation(\n  environment: Environment,\n  feedbackID: string,\n  input: FeedbackLikeData,\n) {\n  return commitMutation(environment, {\n    mutation: graphql`\n      mutation FeedbackLikeMutation($input: FeedbackLikeData!) {\n        feedback_like(data: $input) {\n          feedback {\n            id\n            like_count\n            viewer_does_like\n          }\n        }\n      }\n    `,\n    variables: {input},\n    optimisticUpdater: store => {\n      // Get the record for the Feedback object\n      const feedbackRecord = store.get(feedbackID);\n\n      // Read the current value for the like_count\n      const currentLikeCount = feedbackRecord.getValue('like_count');\n\n      // Optimistically increment the like_count by 1\n      feedbackRecord.setValue((currentLikeCount ?? 0) + 1, 'like_count');\n\n      // Optimistically set viewer_does_like to true\n      feedbackRecord.setValue(true, 'viewer_does_like');\n    },\n    onCompleted: () => {} /* Mutation completed */,\n    onError: error => {} /* Mutation errored */,\n  });\n}\n\nmodule.exports = {commit: commitFeedbackLikeMutation};\n"})}),"\n",(0,o.jsx)(t.p,{children:"Let's see what's happening here:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["The ",(0,o.jsx)(t.code,{children:"optimisticUpdater"})," has the same signature and behaves the same way as the regular ",(0,o.jsx)(t.code,{children:"updater"})," function, the main difference being that it will be executed immediately, before the mutation response completes."]}),"\n",(0,o.jsxs)(t.li,{children:["If the mutation succeeds, ",(0,o.jsx)(t.em,{children:"the optimistic update will be rolled back,"})," and the server response will be applied.","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Note that if we used an ",(0,o.jsx)(t.code,{children:"optimisticResponse"}),", we wouldn't able to statically provide a value for ",(0,o.jsx)(t.code,{children:"like_count"}),", since it requires reading the current value from the store first, which we can do with an ",(0,o.jsx)(t.code,{children:"optimisticUpdater"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:['Also note that when mutation completes, the value from the server might differ from the value we optimistically predicted locally. For example, if other "Likes" occurred at the same time, the final ',(0,o.jsx)(t.code,{children:"like_count"})," from the server might've incremented by more than 1."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["If the mutation ",(0,o.jsx)(t.em,{children:"fails"}),", ",(0,o.jsx)(t.em,{children:"the optimistic update will be rolled back,"})," and the error will be communicated via the ",(0,o.jsx)(t.code,{children:"onError"})," callback."]}),"\n",(0,o.jsxs)(t.li,{children:["Note that we're not providing an ",(0,o.jsx)(t.code,{children:"updater"})," function, which is okay. If it's not provided, the default behavior will still be applied when the server response arrives (i.e. merging the new field values for ",(0,o.jsx)(t.code,{children:"like_count"})," and ",(0,o.jsx)(t.code,{children:"viewer_does_like"})," on the ",(0,o.jsx)(t.code,{children:"Feedback"})," object)."]}),"\n"]}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsx)(t.p,{children:"Remember that any updates to local data caused by a mutation will automatically notify and re-render components subscribed to that data."})}),"\n",(0,o.jsx)(t.h2,{id:"order-of-execution-of-updater-functions",children:"Order of execution of updater functions"}),"\n",(0,o.jsxs)(t.p,{children:["In general, execution of the ",(0,o.jsx)(t.code,{children:"updater"})," and optimistic updates will occur in the following order:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["If an ",(0,o.jsx)(t.code,{children:"optimisticResponse"})," is provided, Relay will use it to merge the new field values for the records that match the ids in the ",(0,o.jsx)(t.code,{children:"optimisticResponse"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["If an ",(0,o.jsx)(t.code,{children:"optimisticUpdater"})," is provided, Relay will execute it and update the store accordingly."]}),"\n",(0,o.jsxs)(t.li,{children:["If an ",(0,o.jsx)(t.code,{children:"optimisticResponse"})," was provided, the declarative mutation directives ",(0,o.jsx)(t.code,{children:"@deleteRecord"}),", ",(0,o.jsx)(t.code,{children:"@appendEdge"})," and ",(0,o.jsx)(t.code,{children:"@prependEdge"})," will be processed on the optimistic response."]}),"\n",(0,o.jsxs)(t.li,{children:["If the mutation request succeeds:","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Any optimistic update that was applied will be rolled back."}),"\n",(0,o.jsx)(t.li,{children:"Relay will use the server response to merge the new field values for the records that match the ids in the response."}),"\n",(0,o.jsxs)(t.li,{children:["If an ",(0,o.jsx)(t.code,{children:"updater"})," was provided, Relay will execute it and update the store accordingly. The server payload will be available to the ",(0,o.jsx)(t.code,{children:"updater"})," as a root field in the store."]}),"\n",(0,o.jsxs)(t.li,{children:["Relay will process any ",(0,o.jsx)(t.code,{children:"@deleteRecord"}),", ",(0,o.jsx)(t.code,{children:"@appendEdge"})," and ",(0,o.jsx)(t.code,{children:"@prependEdge"})," declarative mutation directives."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["If the mutation request fails:","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Any optimistic update was applied will be rolled back."}),"\n",(0,o.jsxs)(t.li,{children:["The ",(0,o.jsx)(t.code,{children:"onError"})," callback will be called."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"full-example",children:"Full example"}),"\n",(0,o.jsxs)(t.p,{children:["This means that in more complicated scenarios you can still provide many options: ",(0,o.jsx)(t.code,{children:"optimisticResponse"}),", ",(0,o.jsx)(t.code,{children:"optimisticUpdater"})," and ",(0,o.jsx)(t.code,{children:"updater"}),". For example, the mutation to add a new comment could like something like the following (for full details on updating connections, check out our ",(0,o.jsx)(t.a,{href:"../../list-data/updating-connections/",children:"Updating Connections"})," guide):"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"import type {Environment} from 'react-relay';\nimport type {CommentCreateData, CreateCommentMutation} from 'CreateCommentMutation.graphql';\n\nconst {commitMutation, graphql} = require('react-relay');\nconst {ConnectionHandler} = require('relay-runtime');\n\nfunction commitCommentCreateMutation(\n  environment: Environment,\n  feedbackID: string,\n  input: CommentCreateData,\n) {\n  return commitMutation<CreateCommentMutation>(environment, {\n    mutation: graphql`\n      mutation CreateCommentMutation($input: CommentCreateData!) {\n        comment_create(input: $input) {\n          feedback {\n            id\n            viewer_has_commented\n          }\n          comment_edge {\n            cursor\n            node {\n              body {\n                text\n              }\n            }\n          }\n        }\n      }\n    `,\n    variables: {input},\n    onCompleted: () => {},\n    onError: error => {},\n\n    // Optimistically set the value for `viewer_has_commented`\n    optimisticResponse: {\n      feedback: {\n        id: feedbackID,\n        viewer_has_commented: true,\n      },\n    },\n\n    // Optimistically add a new comment to the comments connection\n    optimisticUpdater: store => {\n      const feedbackRecord = store.get(feedbackID);\n      const connectionRecord = ConnectionHandler.getConnection(\n        userRecord,\n        'CommentsComponent_comments_connection',\n      );\n\n      // Create a new local Comment from scratch\n      const id = `client:new_comment:${randomID()}`;\n      const newCommentRecord = store.create(id, 'Comment');\n\n      // ... update new comment with content\n\n      // Create new edge from scratch\n      const newEdge = ConnectionHandler.createEdge(\n        store,\n        connectionRecord,\n        newCommentRecord,\n        'CommentEdge' /* GraphQl Type for edge */,\n      );\n\n      // Add edge to the end of the connection\n      ConnectionHandler.insertEdgeAfter(connectionRecord, newEdge);\n    },\n    updater: store => {\n      const feedbackRecord = store.get(feedbackID);\n      const connectionRecord = ConnectionHandler.getConnection(\n        userRecord,\n        'CommentsComponent_comments_connection',\n      );\n\n      // Get the payload returned from the server\n      const payload = store.getRootField('comment_create');\n\n      // Get the edge from server payload\n      const newEdge = payload.getLinkedRecord('comment_edge');\n\n      // Add edge to the end of the connection\n      ConnectionHandler.insertEdgeAfter(connectionRecord, newEdge);\n    },\n  });\n}\n\nmodule.exports = {commit: commitCommentCreateMutation};\n"})}),"\n",(0,o.jsx)(t.p,{children:"Let's distill this example, according to the execution order of the updaters:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Given that an ",(0,o.jsx)(t.code,{children:"optimisticResponse"})," was provided, it will be executed ",(0,o.jsx)(t.em,{children:"first"}),". This will cause the new value of ",(0,o.jsx)(t.code,{children:"viewer_has_commented"})," to be merged into the existing ",(0,o.jsx)(t.code,{children:"Feedback"})," object, setting it to ",(0,o.jsx)(t.code,{children:"true"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["Given that an ",(0,o.jsx)(t.code,{children:"optimisticUpdater"})," was provided, it will be executed next. Our ",(0,o.jsx)(t.code,{children:"optimisticUpdater"})," will create new comment and edge records from scratch, simulating what the new edge in the server response would look like, and then add the new edge to the connection."]}),"\n",(0,o.jsx)(t.li,{children:"When the optimistic updates conclude, components subscribed to this data will be notified."}),"\n",(0,o.jsx)(t.li,{children:"When the mutation succeeds, all of our optimistic updates will be rolled back."}),"\n",(0,o.jsxs)(t.li,{children:["The server response will be processed by relay, and this will cause the new value of ",(0,o.jsx)(t.code,{children:"viewer_has_commented"})," to be merged into the existing ",(0,o.jsx)(t.code,{children:"Feedback"})," object, setting it to ",(0,o.jsx)(t.code,{children:"true"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["Finally, the ",(0,o.jsx)(t.code,{children:"updater"})," function we provided will be executed. The ",(0,o.jsx)(t.code,{children:"updater"})," function is very similar to the ",(0,o.jsx)(t.code,{children:"optimisticUpdater"})," function, however, instead of creating the new data from scratch, it reads it from the mutation payload and adds the new edge to the connection."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"invalidating-data-during-a-mutation",children:"Invalidating data during a mutation"}),"\n",(0,o.jsxs)(t.p,{children:["The recommended approach when executing a mutation is to request ",(0,o.jsx)(t.em,{children:"all"})," the relevant data that was affected by the mutation back from the server (as part of the mutation body), so that our local Relay store is consistent with the state of the server."]}),"\n",(0,o.jsx)(t.p,{children:'However, often times it can be unfeasible to know and specify all the possible data the possible data that would be affected for mutations that have large rippling effects (e.g. imagine "blocking a user" or "leaving a group").'}),"\n",(0,o.jsxs)(t.p,{children:["For these types of mutations, it's often more straightforward to explicitly mark some data as stale (or the whole store), so that Relay knows to refetch it the next time it is rendered. In order to do so, you can use the data invalidation APIs documented in our ",(0,o.jsx)(t.a,{href:"../../reusing-cached-data/staleness-of-data/",children:"Staleness of Data section"}),"."]}),"\n",(0,o.jsxs)(s.FbInternalOnly,{children:[(0,o.jsx)(t.h2,{id:"handling-errors",children:"Handling errors"}),(0,o.jsx)(t.p,{children:"GraphQL errors can largely be differentiated as:"}),(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Operation (query/mutation/subscription) level errors, and"}),"\n",(0,o.jsx)(t.li,{children:"Field level errors"}),"\n"]}),(0,o.jsx)(t.h3,{id:"surfacing-mutation-level-errors",children:"Surfacing mutation level errors"}),(0,o.jsxs)(t.p,{children:["If you're surfacing an error in the mutation (eg the server rejects the entire mutation because it's invalid), as long as the error returned is considered a ",(0,o.jsx)(t.a,{href:"https://www.internalfb.com/code/www/%5Bb5a08782893a%5D/flib/graphql/experimental/core/error/GraphQL2ErrorSeverity.php?lines=11",children:(0,o.jsx)(t.code,{children:"CRITICAL"})})," error, you can make use of the ",(0,o.jsx)(t.code,{children:"onError"})," callback from useMutation to handle that error in whatever way you see fit for your use case."]}),(0,o.jsx)(t.p,{children:"If you control the server resolver, the question you should ask is whether or not throwing a CRITICAL error is the correct behavior for the client. Note though that throwing a CRITICAL error means that Relay will no longer process the interaction, which may not always be what you want if you can still partially update your UI. For example, it's possible that the mutation errored, but still wrote some data to the database, in which case you might still want Relay to process the updated fields."}),(0,o.jsx)(t.p,{children:"In the non-CRITICAL case the mutation may have failed, but some data was successfully returned in the case of partial data and/or the error response if encoded in the schema. Relay will still process this data, update its store, as well as components relying on that data. That is not true for the case where you've returned a CRITICAL error."}),(0,o.jsx)(t.h3,{id:"surfacing-field-level-errors",children:"Surfacing field level errors"}),(0,o.jsxs)(t.p,{children:["Field level errors from the server are generally recommended to be at the ",(0,o.jsx)(t.a,{href:"https://www.internalfb.com/code/www/%5B9120ab8aa8a5%5D/flib/graphql/experimental/core/error/GraphQL2ErrorSeverity.php?lines=17",children:(0,o.jsx)(t.code,{children:"ERROR"})})," level, because your UI should still be able to process the other fields that were successfully returned. If you want to explicitly handle the field level error, then we still recommend ",(0,o.jsx)(t.a,{href:"../../rendering/error-states/#accessing-errors-in-graphql-responses",children:"modeling that"})," in your schema."]})]}),"\n",(0,o.jsx)(t.h2,{id:"mutation-queueing",children:"Mutation queueing"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"TBD: Left to be implemented in user space"}),"\n"]}),"\n",(0,o.jsx)(r.A,{})]})}function m(e={}){let{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},86898(e,t,n){n.d(t,{A:()=>p});var i=n(74848),o=n(95310),a=n(17352),r=n(96540);function s(){let e=window.encodeURI(JSON.stringify({title:"Feedback about "+window.location.pathname,description:"**!!! Required !!!**\n\nPlease modify the task description to let us know how the docs can be improved.\n\n**Please do not ask support questions via this form! Instead, ask in fburl.com/relay_support**",tag_ids:{add:[0xac96423e5b680,0x64079768ac750]}}));window.open("https://www.internalfb.com/tasks/?n="+e)}function d({children:e}){return(0,i.jsxs)("div",{className:"docsRating",id:"docsRating",children:[(0,i.jsx)("hr",{}),e]})}let c=()=>{let[e,t]=r.useState(!1),n=e=>{t(!0),window.ga&&window.ga("send",{hitType:"event",eventCategory:"button",eventAction:"feedback",eventValue:e})};return e?"Thank you for letting us know!":(0,i.jsxs)(i.Fragment,{children:["Is this page useful?",(0,i.jsx)("svg",{className:"i_thumbsup",alt:"Like",id:"docsRating-like",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 81.13 89.76",onClick:()=>n(1),children:(0,i.jsx)("path",{d:"M22.9 6a18.57 18.57 0 002.67 8.4 25.72 25.72 0 008.65 7.66c3.86 2 8.67 7.13 13.51 11 3.86 3.11 8.57 7.11 11.54 8.45s13.59.26 14.64 1.17c1.88 1.63 1.55 9-.11 15.25-1.61 5.86-5.96 10.55-6.48 16.86-.4 4.83-2.7 4.88-10.93 4.88h-1.35c-3.82 0-8.24 2.93-12.92 3.62a68 68 0 01-9.73.5c-3.57 0-7.86-.08-13.25-.08-3.56 0-4.71-1.83-4.71-4.48h8.42a3.51 3.51 0 000-7H12.28a2.89 2.89 0 01-2.88-2.88 1.91 1.91 0 01.77-1.78h16.46a3.51 3.51 0 000-7H12.29c-3.21 0-4.84-1.83-4.84-4a6.41 6.41 0 011.17-3.78h19.06a3.5 3.5 0 100-7H9.75A3.51 3.51 0 016 42.27a3.45 3.45 0 013.75-3.48h13.11c5.61 0 7.71-3 5.71-5.52-4.43-4.74-10.84-12.62-11-18.71-.15-6.51 2.6-7.83 5.36-8.56m0-6a6.18 6.18 0 00-1.53.2c-6.69 1.77-10 6.65-9.82 14.5.08 5.09 2.99 11.18 8.52 18.09H9.74a9.52 9.52 0 00-6.23 16.9 12.52 12.52 0 00-2.07 6.84 9.64 9.64 0 003.65 7.7 7.85 7.85 0 00-1.7 5.13 8.9 8.9 0 005.3 8.13 6 6 0 00-.26 1.76c0 6.37 4.2 10.48 10.71 10.48h13.25a73.75 73.75 0 0010.6-.56 35.89 35.89 0 007.58-2.18 17.83 17.83 0 014.48-1.34h1.35c4.69 0 7.79 0 10.5-1 3.85-1.44 6-4.59 6.41-9.38.2-2.46 1.42-4.85 2.84-7.62a41.3 41.3 0 003.42-8.13 48 48 0 001.59-10.79c.1-5.13-1-8.48-3.35-10.55-2.16-1.87-4.64-1.87-9.6-1.88a46.86 46.86 0 01-6.64-.29c-1.92-.94-5.72-4-8.51-6.3l-1.58-1.28c-1.6-1.3-3.27-2.79-4.87-4.23-3.33-3-6.47-5.79-9.61-7.45a20.2 20.2 0 01-6.43-5.53 12.44 12.44 0 01-1.72-5.36 6 6 0 00-6-5.86z"})}),(0,i.jsx)("svg",{className:"i_thumbsdown",alt:"Dislike",id:"docsRating-dislike",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 81.13 89.76",onClick:()=>n(0),children:(0,i.jsx)("path",{d:"M22.9 6a18.57 18.57 0 002.67 8.4 25.72 25.72 0 008.65 7.66c3.86 2 8.67 7.13 13.51 11 3.86 3.11 8.57 7.11 11.54 8.45s13.59.26 14.64 1.17c1.88 1.63 1.55 9-.11 15.25-1.61 5.86-5.96 10.55-6.48 16.86-.4 4.83-2.7 4.88-10.93 4.88h-1.35c-3.82 0-8.24 2.93-12.92 3.62a68 68 0 01-9.73.5c-3.57 0-7.86-.08-13.25-.08-3.56 0-4.71-1.83-4.71-4.48h8.42a3.51 3.51 0 000-7H12.28a2.89 2.89 0 01-2.88-2.88 1.91 1.91 0 01.77-1.78h16.46a3.51 3.51 0 000-7H12.29c-3.21 0-4.84-1.83-4.84-4a6.41 6.41 0 011.17-3.78h19.06a3.5 3.5 0 100-7H9.75A3.51 3.51 0 016 42.27a3.45 3.45 0 013.75-3.48h13.11c5.61 0 7.71-3 5.71-5.52-4.43-4.74-10.84-12.62-11-18.71-.15-6.51 2.6-7.83 5.36-8.56m0-6a6.18 6.18 0 00-1.53.2c-6.69 1.77-10 6.65-9.82 14.5.08 5.09 2.99 11.18 8.52 18.09H9.74a9.52 9.52 0 00-6.23 16.9 12.52 12.52 0 00-2.07 6.84 9.64 9.64 0 003.65 7.7 7.85 7.85 0 00-1.7 5.13 8.9 8.9 0 005.3 8.13 6 6 0 00-.26 1.76c0 6.37 4.2 10.48 10.71 10.48h13.25a73.75 73.75 0 0010.6-.56 35.89 35.89 0 007.58-2.18 17.83 17.83 0 014.48-1.34h1.35c4.69 0 7.79 0 10.5-1 3.85-1.44 6-4.59 6.41-9.38.2-2.46 1.42-4.85 2.84-7.62a41.3 41.3 0 003.42-8.13 48 48 0 001.59-10.79c.1-5.13-1-8.48-3.35-10.55-2.16-1.87-4.64-1.87-9.6-1.88a46.86 46.86 0 01-6.64-.29c-1.92-.94-5.72-4-8.51-6.3l-1.58-1.28c-1.6-1.3-3.27-2.79-4.87-4.23-3.33-3-6.47-5.79-9.61-7.45a20.2 20.2 0 01-6.43-5.53 12.44 12.44 0 01-1.72-5.36 6 6 0 00-6-5.86z"})})]})},l=()=>(0,i.jsxs)("p",{children:["Let us know how these docs can be improved by",(0,i.jsx)("a",{className:"button",role:"button",tabIndex:0,onClick:s,children:"Filing a task"})]}),h=()=>(0,i.jsxs)("p",{children:["Help us make the site even better by"," ",(0,i.jsx)(o.default,{to:"https://www.surveymonkey.com/r/FYC9TCJ",children:"answering a few quick questions"}),"."]}),u=()=>(0,i.jsxs)(d,{children:[(0,i.jsx)(l,{}),(0,i.jsx)(c,{}),(0,i.jsx)(h,{})]}),m=()=>(0,i.jsxs)(d,{children:[(0,i.jsx)(c,{}),(0,i.jsx)(h,{})]}),p=()=>(0,a.fbContent)({internal:(0,i.jsx)(u,{}),external:(0,i.jsx)(m,{})})},28453(e,t,n){n.d(t,{R:()=>r,x:()=>s});var i=n(96540);let o={},a=i.createContext(o);function r(e){let t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);