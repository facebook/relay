"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["84620"],{23849(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var a=t(19968),i=t(74848),o=t(28453);let s={title:"How Relay Enables Optimal Data Fetching",author:"Jordan Eldredge",tags:[],description:"Exploring the tradoeffs that most data fetching strategies are forced to make, and how Relay allows you to have your cake and eat it too.",hide_table_of_contents:!1},r,l={authorsImageUrls:[void 0]},d=[{value:"Loading experience",id:"loading-experience",level:3},{value:"Suspense cascades",id:"suspense-cascades",level:3},{value:"Composability",id:"composability",level:3},{value:"Granular updates",id:"granular-updates",level:3},{value:"Relay",id:"relay",level:2},{value:"Summary",id:"summary",level:2}];function c(e){let n={h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Relay\u2019s approach to application authorship enables a unique combination of\noptimal runtime performance and application maintainability. In this post I\u2019ll\ndescribe the tradeoffs most apps are forced to make with their data fetching and\nthen describe how Relay\u2019s approach allows you to sidestep these tradeoffs and\nachieve an optimal outcome across multiple tradeoff dimensions."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"In component-based UI systems such as React, one important decision to make is\nwhere in your UI tree you fetch data. While data fetching can be done at any\npoint in the UI tree, in order to understand the tradeoffs at play, let\u2019s\nconsider the two extremes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Leaf node: Fetch data directly within each component that uses data"}),"\n",(0,i.jsx)(n.li,{children:"Root node: Fetch all data at the root of your UI and thread it down to leaf\nnodes using prop drilling"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Where in the UI tree you fetch data impacts multiple dimensions of the\nperformance and maintainability of your application. Unfortunately, with naive\ndata fetching, neither extreme is optimal for all dimensions. Let\u2019s look at\nthese dimensions and consider which improve as you move data fetching closer to\nthe leaves, vs. which improve as you move data fetching closer to the root."}),"\n",(0,i.jsx)(n.h3,{id:"loading-experience",children:"Loading experience"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u{1F6AB} Leaf node: If individual nodes fetch data, you will end up with request\ncascades where your UI needs to make multiple request roundtrips in series\n(waterfalls) since each layer of the UI is blocked on its parent layer\nrendering. Additionally, if multiple components happen to use the same data,\nyou will end up fetching the same data multiple times"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Root node: If all your data is fetched at the root, you will make single\nrequest and render the whole UI without any duplicate data or cascading\nrequests"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"suspense-cascades",children:"Suspense cascades"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u{1F6AB} Leaf node: If each individual component needs to fetch data separately,\neach component will suspend on initial render. With the current implementation\nof React, unsuspending results in rerendering from the nearest parent suspense\nboundary. This means you will have to reevaluate product component code O(n)\ntimes during initial load, where n is the depth of the tree."}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Root node: If all your data is fetched at the root, you will suspend a\nsingle time and evaluate product component code only once."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"composability",children:"Composability"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Leaf node: Using an existing component in a new place is as easy as\nrendering it. Removing a component is as simple as not-rendering it. Similarly\nadding/removing data dependencies can be done fully locally."}),"\n",(0,i.jsx)(n.li,{children:"\u{1F6AB} Root node: Adding an existing component as a child of another component\nrequires updating every query that includes that component to fetch the new\ndata and then threading the new data through all intermediate layers.\nSimilarly, removing a component requires tracing those data dependencies back\nto each root component and determining if the component you removed was that\ndata\u2019s last remaining consumer. The same dynamics apply to adding/removing new\ndata to an existing component."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"granular-updates",children:"Granular updates"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Leaf node: When data changes, each component reading that data can\nindividually rerender, avoiding the need to rerender unaffected components."}),"\n",(0,i.jsx)(n.li,{children:"\u{1F6AB} Root node: Since all data originates at the root, when any data updates it\nalways forces the root component to update forcing an expensive rerender of\nthe entire component tree."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"relay",children:"Relay"}),"\n",(0,i.jsx)(n.p,{children:"Relay leverages GraphQL fragments and a compiler build step to offer a more\noptimal alternative. In an app that uses Relay, each component defines a GraphQL\nfragment which declares the data that it needs. This includes both the concrete\nvalues the component will render as well as the fragments (referenced by name)\nof each direct child component it will render."}),"\n",(0,i.jsx)(n.p,{children:"At build time, the Relay compiler collects these fragments and builds a single\nquery for each root node in your application. Let\u2019s look at how this approach\nplays out for each of the dimensions described above:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Loading experience - The compiler generated query fetches all data needed\nfor the surface in a single roundtrip"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Suspense cascades - Since all data is fetched in a single request, we only\nsuspend once, and it\u2019s right at the root of the tree"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Composability - Adding/removing data from a component, including the\nfragment data needed to render a child component, can be done locally within a\nsingle component. The compiler takes care of updating all impacted root\nqueries"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Granular updates - Because each component defines a fragment, Relay knows\nexactly which data is consumed by each component. This lets relay perform\noptimal updates where the minimal set of components are rerendered when data\nchanges"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"As you can see, Relay\u2019s use of a declarative composable data fetching language\n(GraphQL), combined a compiler step, allows us to achieve optimal outcomes\nacross all of the tradeoff dimensions outlined above:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{children:"Leaf node"}),(0,i.jsx)(n.th,{children:"Root node"}),(0,i.jsx)(n.th,{children:"GraphQL/Relay"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Loading experience"}),(0,i.jsx)(n.td,{children:"\u{1F6AB}"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Suspense cascades"}),(0,i.jsx)(n.td,{children:"\u{1F6AB}"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Composability"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u{1F6AB}"}),(0,i.jsx)(n.td,{children:"\u2705"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Granular updates"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u{1F6AB}"}),(0,i.jsx)(n.td,{children:"\u2705"})]})]})]})]})}function h(e={}){let{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453(e,n,t){t.d(n,{R:()=>s,x:()=>r});var a=t(96540);let i={},o=a.createContext(i);function s(e){let n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:n},e.children)}},19968(e){e.exports=JSON.parse('{"permalink":"/blog/2023/10/24/how-relay-enables-optimal-data-fetching","source":"@site/blog/2023-10-24-how-relay-enables-optimal-data-fetching.mdx","title":"How Relay Enables Optimal Data Fetching","description":"Exploring the tradoeffs that most data fetching strategies are forced to make, and how Relay allows you to have your cake and eat it too.","date":"2023-10-24T00:00:00.000Z","tags":[],"readingTime":3.93,"hasTruncateMarker":false,"authors":[{"name":"Jordan Eldredge","key":null,"page":null}],"frontMatter":{"title":"How Relay Enables Optimal Data Fetching","author":"Jordan Eldredge","tags":[],"description":"Exploring the tradoeffs that most data fetching strategies are forced to make, and how Relay allows you to have your cake and eat it too.","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Relay v19.0","permalink":"/blog/2025/04/02/relay-19"},"nextItem":{"title":"Relay v15.0","permalink":"/blog/2023/03/30/relay-15"}}')}}]);