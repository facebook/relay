"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["66748"],{17037(e,n,s){s.r(n),s.d(n,{metadata:()=>t,default:()=>p,frontMatter:()=>d,contentTitle:()=>l,toc:()=>h,assets:()=>c});var t=JSON.parse('{"id":"guided-tour/rendering/loading-states","title":"Loading States with Suspense","description":"Relay guide to loading states","source":"@site/versioned_docs/version-v15.0.0/guided-tour/rendering/loading-states.md","sourceDirName":"guided-tour/rendering","slug":"/guided-tour/rendering/loading-states/","permalink":"/docs/v15.0.0/guided-tour/rendering/loading-states/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v15.0.0/guided-tour/rendering/loading-states.md","tags":[],"version":"v15.0.0","frontMatter":{"id":"loading-states","title":"Loading States with Suspense","slug":"/guided-tour/rendering/loading-states/","description":"Relay guide to loading states","keywords":["suspense","loading","glimmer","fallback","spinner"]}}'),a=s(74848),i=s(28453),r=s(86898),o=s(17352);let d={id:"loading-states",title:"Loading States with Suspense",slug:"/guided-tour/rendering/loading-states/",description:"Relay guide to loading states",keywords:["suspense","loading","glimmer","fallback","spinner"]},l,c={},h=[{value:"Loading fallbacks with Suspense Boundaries",id:"loading-fallbacks-with-suspense-boundaries",level:2},{value:"Transitions and Updates that Suspend",id:"transitions-and-updates-that-suspend",level:2},{value:"How We Use Suspense in Relay",id:"how-we-use-suspense-in-relay",level:2},{value:"Queries",id:"queries",level:3},{value:"Fragments",id:"fragments",level:3},{value:"Transitions",id:"transitions",level:3}];function u(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["As you may have noticed, we mentioned that using ",(0,a.jsx)(n.code,{children:"usePreloadedQuery"})," and ",(0,a.jsx)(n.code,{children:"useLazyLoadQuery"})," will render data from a query that was being fetched from the server, but we didn't elaborate on how to render a loading UI (such as a glimmer) while that data is still being fetched. We will cover that in this section."]}),"\n",(0,a.jsx)(o.OssOnly,{children:(0,a.jsxs)(n.p,{children:["To render loading states while a query is being fetched, we rely on ",(0,a.jsx)(n.a,{href:"https://reactjs.org/docs/concurrent-mode-suspense.html",children:"React Suspense"}),". Suspense is a new feature in React that allows components to interrupt or ",(0,a.jsx)(n.em,{children:'"suspend"'}),' rendering in order to wait for some asynchronous resource (such as code, images or data) to be loaded; when a component "suspends", it indicates to React that the component isn\'t ',(0,a.jsx)(n.em,{children:'"ready"'})," to be rendered yet, and won't be until the asynchronous resource it's waiting for is loaded. When the resource finally loads, React will try to render the component again."]})}),"\n",(0,a.jsx)(n.p,{children:"This capability is useful for components to express asynchronous dependencies like data, code, or images that they require in order to render, and lets React coordinate rendering the loading states across a component tree as these asynchronous resources become available. More generally, the use of Suspense give us better control to implement more deliberately designed loading states when our app is loading for the first time or when it's transitioning to different states, and helps prevent accidental flickering of loading elements (such as spinners), which can commonly occur when loading sequences aren't explicitly designed and coordinated."}),"\n",(0,a.jsx)(o.OssOnly,{children:(0,a.jsxs)(n.admonition,{type:"caution",children:[(0,a.jsxs)(n.p,{children:["Note that this ",(0,a.jsx)(n.strong,{children:"DOES NOT"}),' mean that "Suspense for Data Fetching" is ready for general implementation and adoption yet. ',(0,a.jsx)(n.strong,{children:"Support, general guidance, and requirements for usage of Suspense for Data Fetching are still not ready"}),", and the React team is still defining what this guidance will be for upcoming React releases."]}),(0,a.jsx)(n.p,{children:"Even though there will be some limitations when Suspense is used in React 17, Relay Hooks are stable and on the trajectory for supporting upcoming releases of React."}),(0,a.jsxs)(n.p,{children:["For more information, see our ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"../../../migration-and-compatibility/suspense-compatibility/",children:"Suspense Compatibility"})})," guide."]})]})}),"\n",(0,a.jsx)(n.h2,{id:"loading-fallbacks-with-suspense-boundaries",children:"Loading fallbacks with Suspense Boundaries"}),"\n",(0,a.jsxs)(n.p,{children:["When a component is suspended, we need to render a ",(0,a.jsx)(n.em,{children:"fallback"})," in place of the component while we wait for it to become ",(0,a.jsx)(n.em,{children:'"ready"'}),". In order to do so, we use the ",(0,a.jsx)(n.code,{children:"Suspense"})," component provided by React:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const React = require('React');\nconst {Suspense} = require('React');\n\nfunction App() {\n  return (\n    // Render a fallback using Suspense as a wrapper\n    <Suspense fallback={<LoadingGlimmer />}>\n      <CanSuspend />\n    </Suspense>\n  );\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Suspense"})," components can be used to wrap any component; if the target component suspends, ",(0,a.jsx)(n.code,{children:"Suspense"})," will render the provided fallback until all its descendants become ",(0,a.jsx)(n.em,{children:'"ready"'})," (i.e. until ",(0,a.jsx)(n.em,{children:"all"})," of the suspended components within the subtree resolve). Usually, the fallback is used to render fallback loading states such as a glimmers and placeholders."]}),"\n",(0,a.jsxs)(n.p,{children:["Usually, different pieces of content in our  app might suspend, so we can show loading state until they are resolved by using ",(0,a.jsx)(n.code,{children:"Suspense"})," :"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"/**\n * App.react.js\n */\n\nconst React = require('React');\nconst {Suspense} = require('React');\n\nfunction App() {\n  return (\n    // LoadingGlimmer is rendered via the Suspense fallback\n    <Suspense fallback={<LoadingGlimmer />}>\n      <MainContent /> {/* MainContent may suspend */}\n    </Suspense>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Let's distill what's going on here:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["If ",(0,a.jsx)(n.code,{children:"MainContent"})," suspends because it's waiting on some asynchronous resource (like data), the ",(0,a.jsx)(n.code,{children:"Suspense"})," component that wraps ",(0,a.jsx)(n.code,{children:"MainContent"})," will detect that it suspended, and will render the ",(0,a.jsx)(n.code,{children:"fallback"})," element (i.e. the ",(0,a.jsx)(n.code,{children:"LoadingGlimmer"})," in this case) up until ",(0,a.jsx)(n.code,{children:"MainContent"})," is ready to be rendered. Note that this also transitively includes descendants of ",(0,a.jsx)(n.code,{children:"MainContent"}),", which might also suspend."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"What's nice about Suspense is that you have granular control about how to accumulate loading states for different parts of your component tree:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"/**\n * App.react.js\n */\n\nconst React = require('React');\nconst {Suspense} = require('React');\n\nfunction App() {\n  return (\n    // A LoadingGlimmer for all content is rendered via the Suspense fallback\n    <Suspense fallback={<LoadingGlimmer />}>\n      <MainContent />\n      <SecondaryContent /> {/* SecondaryContent can also suspend */}\n    </Suspense>\n  );\n}\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["In this case, both ",(0,a.jsx)(n.code,{children:"MainContent"})," and ",(0,a.jsx)(n.code,{children:"SecondaryContent"})," may suspend while they load their asynchronous resources; by wrapping both in a ",(0,a.jsx)(n.code,{children:"Suspense"}),", we can show a single loading state up until they are ",(0,a.jsx)(n.em,{children:"all"})," ready, and then render the entire content in a single paint, after everything has successfully loaded."]}),"\n",(0,a.jsxs)(n.li,{children:["In fact, ",(0,a.jsx)(n.code,{children:"MainContent"})," and ",(0,a.jsx)(n.code,{children:"SecondaryContent"})," may suspend for different reasons other than fetching data, but the same ",(0,a.jsx)(n.code,{children:"Suspense"})," component can be used to render a fallback up until ",(0,a.jsx)(n.em,{children:"all"})," components in the subtree are ready to be rendered. Note that this also transitively includes descendants of ",(0,a.jsx)(n.code,{children:"MainContent"})," or ",(0,a.jsx)(n.code,{children:"SecondaryContent"}),", which might also suspend."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Conversely, you can also decide to be more granular about your loading UI and wrap Suspense components around smaller or individual parts of your component tree:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"/**\n * App.react.js\n */\n\nconst React = require('React');\nconst {Suspense} = require('React');\n\nfunction App() {\n  return (\n    <>\n      {/* Show a separate loading UI for the LeftHandColumn */}\n      <Suspense fallback={<LeftColumnPlaceholder />}>\n        <LeftColumn />\n      </Suspense>\n\n      {/* Show a separate loading UI for both the Main and Secondary content */}\n      <Suspense fallback={<LoadingGlimmer />}>\n        <MainContent />\n        <SecondaryContent />\n      </Suspense>\n    </>\n  );\n}\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["In this case, we're showing 2 separate loading UIs:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["One to be shown until the ",(0,a.jsx)(n.code,{children:"LeftColumn"})," becomes ready"]}),"\n",(0,a.jsxs)(n.li,{children:["And one to be shown until both the ",(0,a.jsx)(n.code,{children:"MainContent"})," and ",(0,a.jsx)(n.code,{children:"SecondaryContent"})," become ready."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["What is powerful about this is that by more granularly wrapping our components in Suspense, ",(0,a.jsx)(n.em,{children:"we allow other components to be rendered earlier as they become ready"}),". In our example, by separately wrapping ",(0,a.jsx)(n.code,{children:"MainContent"})," and ",(0,a.jsx)(n.code,{children:"SecondaryContent"})," under ",(0,a.jsx)(n.code,{children:"Suspense"}),", we're allowing ",(0,a.jsx)(n.code,{children:"LeftColumn"})," to render as soon as it becomes ready, which might be earlier than when the content sections become ready."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"transitions-and-updates-that-suspend",children:"Transitions and Updates that Suspend"}),"\n",(0,a.jsxs)(o.OssOnly,{children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Suspense"})," boundary fallbacks allow us to describe our loading placeholders when initially rendering some content, but our applications will also have transitions between different content. Specifically, when switching between two components within an already mounted boundary, the new component you're switching to might not have loaded all of its async dependencies, which means that it might also suspend."]}),(0,a.jsxs)(n.p,{children:["In these cases, we would still show the ",(0,a.jsx)(n.code,{children:"Suspense"})," boundary fallbacks. However, this means that we would hide existing content in favor of showing the ",(0,a.jsx)(n.code,{children:"Suspense"})," fallback. In future versions of React when concurrent rendering is supported, React will provide an option to support this case and avoid hiding already rendered content with a Suspense fallback when suspending."]})]}),"\n",(0,a.jsx)(n.h2,{id:"how-we-use-suspense-in-relay",children:"How We Use Suspense in Relay"}),"\n",(0,a.jsx)(n.h3,{id:"queries",children:"Queries"}),"\n",(0,a.jsx)(n.p,{children:"In our case, our query components are components that can suspend, so we use Suspense to render loading states while a query is being fetched. Let's see what that looks like in practice:"}),"\n",(0,a.jsx)(n.p,{children:"Say we have the following query renderer component:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"/**\n * MainContent.react.js\n *\n * Query Component\n */\n\nconst React = require('React');\nconst {graphql, usePreloadedQuery} = require('react-relay');\n\nfunction MainContent(props) {\n  // Fetch and render a query\n  const data = usePreloadedQuery(\n    graphql`...`,\n    props.queryRef,\n  );\n\n  return (...);\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"/**\n * App.react.js\n */\n\nconst React = require('React');\nconst {Suspense} = require('React');\n\nfunction App() {\n  return (\n    // LoadingGlimmer is rendered via the Suspense fallback\n    <Suspense fallback={<LoadingGlimmer />}>\n      <MainContent /> {/* MainContent may suspend */}\n    </Suspense>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Let's distill what's going on here:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["We have a ",(0,a.jsx)(n.code,{children:"MainContent"})," component, which is a query renderer that fetches and renders a query. ",(0,a.jsx)(n.code,{children:"MainContent"})," will ",(0,a.jsx)(n.em,{children:"suspend"})," rendering when it attempts to fetch the query, indicating that it isn't ready to be rendered yet, and it will resolve when the query is fetched."]}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"Suspense "}),"component that wraps ",(0,a.jsx)(n.code,{children:"MainContent"})," will detect that ",(0,a.jsx)(n.code,{children:"MainContent"})," suspended, and will render the ",(0,a.jsx)(n.code,{children:"fallback"})," element (i.e. the ",(0,a.jsx)(n.code,{children:"LoadingGlimmer"})," in this case) up until ",(0,a.jsx)(n.code,{children:"MainContent"})," is ready to be rendered; that is, up until the query is fetched."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"fragments",children:"Fragments"}),"\n",(0,a.jsx)(o.OssOnly,{children:(0,a.jsxs)(n.p,{children:["Fragments are also integrated with Suspense in order to support rendering of data that's being ",(0,a.jsx)(n.code,{children:"@defer'"}),"d or data that's partially available in the Relay Store (i.e. ",(0,a.jsx)(n.a,{href:"../../reusing-cached-data/rendering-partially-cached-data/",children:"partial rendering"}),")."]})}),"\n",(0,a.jsx)(n.h3,{id:"transitions",children:"Transitions"}),"\n",(0,a.jsxs)(n.p,{children:["Additionally, our APIs for refetching (",(0,a.jsx)(n.a,{href:"../../refetching/",children:"Refreshing and Refetching"}),") and for ",(0,a.jsx)(n.a,{href:"../../list-data/connections/",children:"rendering connections"})," are also integrated with Suspense; for these use cases, these APIs will also suspend."]}),"\n",(0,a.jsx)(r.A,{})]})}function p(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},86898(e,n,s){s.d(n,{A:()=>g});var t=s(74848),a=s(95310),i=s(17352),r=s(96540);function o(){let e=window.encodeURI(JSON.stringify({title:"Feedback about "+window.location.pathname,description:"**!!! Required !!!**\n\nPlease modify the task description to let us know how the docs can be improved.\n\n**Please do not ask support questions via this form! Instead, ask in fburl.com/relay_support**",tag_ids:{add:[0xac96423e5b680,0x64079768ac750]}}));window.open("https://www.internalfb.com/tasks/?n="+e)}function d({children:e}){return(0,t.jsxs)("div",{className:"docsRating",id:"docsRating",children:[(0,t.jsx)("hr",{}),e]})}let l=()=>{let[e,n]=r.useState(!1),s=e=>{n(!0),window.ga&&window.ga("send",{hitType:"event",eventCategory:"button",eventAction:"feedback",eventValue:e})};return e?"Thank you for letting us know!":(0,t.jsxs)(t.Fragment,{children:["Is this page useful?",(0,t.jsx)("svg",{className:"i_thumbsup",alt:"Like",id:"docsRating-like",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 81.13 89.76",onClick:()=>s(1),children:(0,t.jsx)("path",{d:"M22.9 6a18.57 18.57 0 002.67 8.4 25.72 25.72 0 008.65 7.66c3.86 2 8.67 7.13 13.51 11 3.86 3.11 8.57 7.11 11.54 8.45s13.59.26 14.64 1.17c1.88 1.63 1.55 9-.11 15.25-1.61 5.86-5.96 10.55-6.48 16.86-.4 4.83-2.7 4.88-10.93 4.88h-1.35c-3.82 0-8.24 2.93-12.92 3.62a68 68 0 01-9.73.5c-3.57 0-7.86-.08-13.25-.08-3.56 0-4.71-1.83-4.71-4.48h8.42a3.51 3.51 0 000-7H12.28a2.89 2.89 0 01-2.88-2.88 1.91 1.91 0 01.77-1.78h16.46a3.51 3.51 0 000-7H12.29c-3.21 0-4.84-1.83-4.84-4a6.41 6.41 0 011.17-3.78h19.06a3.5 3.5 0 100-7H9.75A3.51 3.51 0 016 42.27a3.45 3.45 0 013.75-3.48h13.11c5.61 0 7.71-3 5.71-5.52-4.43-4.74-10.84-12.62-11-18.71-.15-6.51 2.6-7.83 5.36-8.56m0-6a6.18 6.18 0 00-1.53.2c-6.69 1.77-10 6.65-9.82 14.5.08 5.09 2.99 11.18 8.52 18.09H9.74a9.52 9.52 0 00-6.23 16.9 12.52 12.52 0 00-2.07 6.84 9.64 9.64 0 003.65 7.7 7.85 7.85 0 00-1.7 5.13 8.9 8.9 0 005.3 8.13 6 6 0 00-.26 1.76c0 6.37 4.2 10.48 10.71 10.48h13.25a73.75 73.75 0 0010.6-.56 35.89 35.89 0 007.58-2.18 17.83 17.83 0 014.48-1.34h1.35c4.69 0 7.79 0 10.5-1 3.85-1.44 6-4.59 6.41-9.38.2-2.46 1.42-4.85 2.84-7.62a41.3 41.3 0 003.42-8.13 48 48 0 001.59-10.79c.1-5.13-1-8.48-3.35-10.55-2.16-1.87-4.64-1.87-9.6-1.88a46.86 46.86 0 01-6.64-.29c-1.92-.94-5.72-4-8.51-6.3l-1.58-1.28c-1.6-1.3-3.27-2.79-4.87-4.23-3.33-3-6.47-5.79-9.61-7.45a20.2 20.2 0 01-6.43-5.53 12.44 12.44 0 01-1.72-5.36 6 6 0 00-6-5.86z"})}),(0,t.jsx)("svg",{className:"i_thumbsdown",alt:"Dislike",id:"docsRating-dislike",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 81.13 89.76",onClick:()=>s(0),children:(0,t.jsx)("path",{d:"M22.9 6a18.57 18.57 0 002.67 8.4 25.72 25.72 0 008.65 7.66c3.86 2 8.67 7.13 13.51 11 3.86 3.11 8.57 7.11 11.54 8.45s13.59.26 14.64 1.17c1.88 1.63 1.55 9-.11 15.25-1.61 5.86-5.96 10.55-6.48 16.86-.4 4.83-2.7 4.88-10.93 4.88h-1.35c-3.82 0-8.24 2.93-12.92 3.62a68 68 0 01-9.73.5c-3.57 0-7.86-.08-13.25-.08-3.56 0-4.71-1.83-4.71-4.48h8.42a3.51 3.51 0 000-7H12.28a2.89 2.89 0 01-2.88-2.88 1.91 1.91 0 01.77-1.78h16.46a3.51 3.51 0 000-7H12.29c-3.21 0-4.84-1.83-4.84-4a6.41 6.41 0 011.17-3.78h19.06a3.5 3.5 0 100-7H9.75A3.51 3.51 0 016 42.27a3.45 3.45 0 013.75-3.48h13.11c5.61 0 7.71-3 5.71-5.52-4.43-4.74-10.84-12.62-11-18.71-.15-6.51 2.6-7.83 5.36-8.56m0-6a6.18 6.18 0 00-1.53.2c-6.69 1.77-10 6.65-9.82 14.5.08 5.09 2.99 11.18 8.52 18.09H9.74a9.52 9.52 0 00-6.23 16.9 12.52 12.52 0 00-2.07 6.84 9.64 9.64 0 003.65 7.7 7.85 7.85 0 00-1.7 5.13 8.9 8.9 0 005.3 8.13 6 6 0 00-.26 1.76c0 6.37 4.2 10.48 10.71 10.48h13.25a73.75 73.75 0 0010.6-.56 35.89 35.89 0 007.58-2.18 17.83 17.83 0 014.48-1.34h1.35c4.69 0 7.79 0 10.5-1 3.85-1.44 6-4.59 6.41-9.38.2-2.46 1.42-4.85 2.84-7.62a41.3 41.3 0 003.42-8.13 48 48 0 001.59-10.79c.1-5.13-1-8.48-3.35-10.55-2.16-1.87-4.64-1.87-9.6-1.88a46.86 46.86 0 01-6.64-.29c-1.92-.94-5.72-4-8.51-6.3l-1.58-1.28c-1.6-1.3-3.27-2.79-4.87-4.23-3.33-3-6.47-5.79-9.61-7.45a20.2 20.2 0 01-6.43-5.53 12.44 12.44 0 01-1.72-5.36 6 6 0 00-6-5.86z"})})]})},c=()=>(0,t.jsxs)("p",{children:["Let us know how these docs can be improved by",(0,t.jsx)("a",{className:"button",role:"button",tabIndex:0,onClick:o,children:"Filing a task"})]}),h=()=>(0,t.jsxs)("p",{children:["Help us make the site even better by"," ",(0,t.jsx)(a.default,{to:"https://www.surveymonkey.com/r/FYC9TCJ",children:"answering a few quick questions"}),"."]}),u=()=>(0,t.jsxs)(d,{children:[(0,t.jsx)(c,{}),(0,t.jsx)(l,{}),(0,t.jsx)(h,{})]}),p=()=>(0,t.jsxs)(d,{children:[(0,t.jsx)(l,{}),(0,t.jsx)(h,{})]}),g=()=>(0,i.fbContent)({internal:(0,t.jsx)(u,{}),external:(0,t.jsx)(p,{})})},28453(e,n,s){s.d(n,{R:()=>r,x:()=>o});var t=s(96540);let a={},i=t.createContext(a);function r(e){let n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);