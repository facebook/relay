(window.webpackJsonp=window.webpackJsonp||[]).push([[658],{1171:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return m}));var a=t(0),r=t.n(a);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),d=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},b=function(e){var n=d(e.components);return r.a.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},u=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=d(t),u=a,m=b["".concat(o,".").concat(u)]||b[u]||p[u]||i;return t?r.a.createElement(m,s(s({ref:n},c),{},{components:t})):r.a.createElement(m,s({ref:n},c))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=t[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},741:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return s})),t.d(n,"toc",(function(){return l})),t.d(n,"default",(function(){return d}));var a=t(3),r=t(7),i=(t(0),t(1171)),o={id:"a-guided-tour-of-relay",title:"A Guided Tour",original_id:"a-guided-tour-of-relay"},s={unversionedId:"a-guided-tour-of-relay",id:"version-experimental/a-guided-tour-of-relay",isDocsHomePage:!1,title:"A Guided Tour",description:"Relay is a framework for managing and declaratively fetching GraphQL data. Specifically, it provides a set of APIs to fetch and declare data dependencies for React components, in colocation with component definitions themselves.",source:"@site/versioned_docs/version-experimental/RelayHooks-AGuidedTourOfRelay.md",slug:"/a-guided-tour-of-relay",permalink:"/docs/experimental/a-guided-tour-of-relay",editUrl:"https://github.com/facebook/relay/edit/master/website-v2/versioned_docs/version-experimental/RelayHooks-AGuidedTourOfRelay.md",version:"experimental",lastUpdatedBy:"Robert Balicki",lastUpdatedAt:1615351685,sidebar:"version-experimental/docs",previous:{title:"A Step By Step Guide",permalink:"/docs/experimental/step-by-step"},next:{title:"API Reference",permalink:"/docs/experimental/api-reference"}},l=[{value:"Example App",id:"example-app",children:[]},{value:"Setup and Workflow",id:"setup-and-workflow",children:[{value:"Installation",id:"installation",children:[]},{value:"Babel plugin",id:"babel-plugin",children:[]},{value:"Relay Compiler",id:"relay-compiler",children:[]},{value:"Config file",id:"config-file",children:[]}]},{value:"Rendering Data Basics",id:"rendering-data-basics",children:[{value:"Fragments",id:"fragments",children:[]},{value:"Composing Fragments",id:"composing-fragments",children:[]},{value:"Queries",id:"queries",children:[]},{value:"Variables",id:"variables",children:[]},{value:"<code>@arguments</code> and <code>@argumentDefinitions</code>",id:"arguments-and-argumentdefinitions",children:[]},{value:"Loading States with Suspense",id:"loading-states-with-suspense",children:[]},{value:"Error States with Error Boundaries",id:"error-states-with-error-boundaries",children:[]},{value:"Environment",id:"environment",children:[]}]},{value:"Reusing Cached Data for Render",id:"reusing-cached-data-for-render",children:[{value:"Fetch Policies",id:"fetch-policies",children:[]},{value:"Availability of Cached Data",id:"availability-of-cached-data",children:[]},{value:"Presence of Data",id:"presence-of-data",children:[]},{value:"Staleness of Data",id:"staleness-of-data",children:[]},{value:"Rendering Partially Cached Data HIGHLY EXPERIMENTAL",id:"rendering-partially-cached-data-highly-experimental",children:[]},{value:"Filling in Missing Data (Missing Data Handlers)",id:"filling-in-missing-data-missing-data-handlers",children:[]}]},{value:"Fetching Rendering <em>Different</em> Data",id:"fetching-rendering-different-data",children:[{value:"Refreshing Rendered Data",id:"refreshing-rendered-data",children:[]},{value:"Re-rendering with Different Data",id:"re-rendering-with-different-data",children:[]}]},{value:"Rendering List Data and Pagination",id:"rendering-list-data-and-pagination",children:[{value:"Connections",id:"connections",children:[]},{value:"Rendering Connections",id:"rendering-connections",children:[]},{value:"Pagination",id:"pagination",children:[]},{value:"Blocking (&quot;all-at-once&quot;) Pagination",id:"blocking-all-at-once-pagination",children:[]},{value:"Using and Changing Filters",id:"using-and-changing-filters",children:[]},{value:"Adding and Removing Items From a Connection",id:"adding-and-removing-items-from-a-connection",children:[]},{value:"Connection Records",id:"connection-records",children:[]},{value:"Adding Edges",id:"adding-edges",children:[]},{value:"Removing Edges",id:"removing-edges",children:[]},{value:"Connection Identity With Filters",id:"connection-identity-with-filters",children:[]},{value:"Advanced Pagination Use Cases",id:"advanced-pagination-use-cases",children:[]}]},{value:"Advanced Data Fetching",id:"advanced-data-fetching",children:[{value:"Preloading Data",id:"preloading-data",children:[]},{value:"Incremental Data Delivery",id:"incremental-data-delivery",children:[]},{value:"Data-driven Dependencies",id:"data-driven-dependencies",children:[]},{value:"Image Prefetching",id:"image-prefetching",children:[]}]},{value:"Updating Data",id:"updating-data",children:[{value:"GraphQL Mutations",id:"graphql-mutations",children:[]},{value:"GraphQL Subscriptions",id:"graphql-subscriptions",children:[]},{value:"Local Data Updates",id:"local-data-updates",children:[]},{value:"Client-Only Data (Client Schema Extensions)",id:"client-only-data-client-schema-extensions",children:[]}]},{value:"Local Application State Management",id:"local-application-state-management",children:[]},{value:"Accessing Data Outside React",id:"accessing-data-outside-react",children:[{value:"Fetching Queries",id:"fetching-queries",children:[]},{value:"Prefetching Queries",id:"prefetching-queries",children:[]},{value:"Subscribing to Queries",id:"subscribing-to-queries",children:[]},{value:"Reading Queries from Local Cache",id:"reading-queries-from-local-cache",children:[]},{value:"Reading Fragments from Local Cache",id:"reading-fragments-from-local-cache",children:[]},{value:"Retaining Queries",id:"retaining-queries",children:[]}]},{value:"Testing",id:"testing",children:[]}],c={toc:l};function d(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://relay.dev/"}),"Relay")," is a framework for managing and declaratively fetching GraphQL data. Specifically, it provides a set of APIs to fetch and declare data dependencies for React components, in colocation with component definitions themselves."),Object(i.b)("p",null,"In this guide, we're going to go over how to use Relay to build out some of the more common use cases in apps. If you're interested in a detailed reference of our APIs, check out our ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./api-reference"}),"API Reference")," page. Before getting started, bear in mind that we assume some level of familiarity with JavaScript, ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/getting-started.html"}),"React"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://graphql.org/learn/"}),"GraphQL"),", and assume that you have set up a GraphQL Server that adheres to the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./graphql-server-specification"}),"Relay specification")),Object(i.b)("h2",{id:"example-app"},"Example App"),Object(i.b)("p",null,"To see a full example using Relay Hooks and our integration with ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/concurrent-mode-suspense.html"}),"Suspense for Data Fetching"),", check out: ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/relayjs/relay-examples/tree/master/issue-tracker"}),"relay-examples/issue-tracker"),"."),Object(i.b)("h2",{id:"setup-and-workflow"},"Setup and Workflow"),Object(i.b)("p",null,"In case you've never worked with Relay before, here's a rundown of what you need to set up to get up and running developing with Relay:"),Object(i.b)("h3",{id:"installation"},"Installation"),Object(i.b)("p",null,"Install the experimental versions of React and Relay using ",Object(i.b)("inlineCode",{parentName:"p"},"yarn")," or ",Object(i.b)("inlineCode",{parentName:"p"},"npm"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"\nyarn add react@experimental react-dom@experimental react-relay@experimental\n\n")),Object(i.b)("h3",{id:"babel-plugin"},"Babel plugin"),Object(i.b)("p",null,"Relay requires a Babel plugin to process ",Object(i.b)("inlineCode",{parentName:"p"},"graphql")," tags inside your JavaScript code:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"\nyarn add --dev babel-plugin-relay graphql\n\n")),Object(i.b)("p",null,"Add ",Object(i.b)("inlineCode",{parentName:"p"},'"relay"')," to the list of plugins in your ",Object(i.b)("inlineCode",{parentName:"p"},".babelrc")," file:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\n{\n  "plugins": [\n    "relay"\n  ]\n}\n\n')),Object(i.b)("p",null,"Please note that the ",Object(i.b)("inlineCode",{parentName:"p"},'"relay"')," plugin should run before other plugins or\npresets to ensure the ",Object(i.b)("inlineCode",{parentName:"p"},"graphql")," template literals are correctly transformed. See\nBabel's ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://babeljs.io/docs/plugins/#pluginpreset-ordering"}),"documentation on this topic"),"."),Object(i.b)("p",null,"Alternatively, instead of using ",Object(i.b)("inlineCode",{parentName:"p"},"babel-plugin-relay"),", you can use Relay with ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/kentcdodds/babel-plugin-macros"}),"babel-plugin-macros"),". After installing ",Object(i.b)("inlineCode",{parentName:"p"},"babel-plugin-macros")," and adding it to your Babel config:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst graphql = require('babel-plugin-relay/macro');\n\n")),Object(i.b)("p",null,"If you need to configure ",Object(i.b)("inlineCode",{parentName:"p"},"babel-plugin-relay")," further, you can do so by ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/user.md#config-experimental"}),"specifying the options in a number of ways"),"."),Object(i.b)("h3",{id:"relay-compiler"},"Relay Compiler"),Object(i.b)("p",null,"Whenever you're developing Relay components, for example by writing ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#fragments"}),"Fragments")," or ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#queries"}),"Queries"),", you will need to run the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./graphql-in-relay#relay-compiler"}),"Relay Compiler"),". The Relay Compiler will read and analyze any ",Object(i.b)("inlineCode",{parentName:"p"},"graphql")," inside your JavaScript code, and produce a set of artifacts that will be used by Relay at runtime (i.e. when the application is running on the browser)."),Object(i.b)("p",null,"To install the compiler, you can use ",Object(i.b)("inlineCode",{parentName:"p"},"yarn")," or ",Object(i.b)("inlineCode",{parentName:"p"},"npm"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"\nyarn add --dev relay-compiler\n\n")),Object(i.b)("p",null,"This installs the bin script ",Object(i.b)("inlineCode",{parentName:"p"},"relay-compiler")," in your ",Object(i.b)("inlineCode",{parentName:"p"},"node_modules")," folder. It's recommended to run this from a ",Object(i.b)("inlineCode",{parentName:"p"},"yarn"),"/",Object(i.b)("inlineCode",{parentName:"p"},"npm")," script by adding a script to your ",Object(i.b)("inlineCode",{parentName:"p"},"package.json")," file:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'\n"scripts": {\n  "relay": "relay-compiler --src ./src --schema ./schema.graphql"\n}\n\n')),Object(i.b)("p",null,"or if you are using jsx:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'\n"scripts": {\n  "relay": "relay-compiler --src ./src --schema ./schema.graphql --extensions js jsx"\n}\n\n')),Object(i.b)("p",null,"Then, whenever you've made edits to your application files, you can run the ",Object(i.b)("inlineCode",{parentName:"p"},"relay")," script to run the compiler and generate new compiled artifacts:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"\n# Single run\nyarn run relay\n\n")),Object(i.b)("p",null,"You can also pass the ",Object(i.b)("inlineCode",{parentName:"p"},"--watch")," option to watch for changes in your application files and automatically re-compile the artifacts (",Object(i.b)("strong",{parentName:"p"},"Note:")," Requires ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://facebook.github.io/watchman"}),"watchman")," to be installed):"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"\n# Watch for changes\nyarn run relay --watch\n\n")),Object(i.b)("h3",{id:"config-file"},"Config file"),Object(i.b)("p",null,"The configuration of ",Object(i.b)("inlineCode",{parentName:"p"},"babel-plugin-relay")," and ",Object(i.b)("inlineCode",{parentName:"p"},"relay-compiler")," can be applied using a single configuration file by\nusing the ",Object(i.b)("inlineCode",{parentName:"p"},"relay-config")," package. Besides unifying all Relay configuration in a single place, other tooling can leverage this to provide zero-config setup (e.g. ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/relay-tools/vscode-apollo-relay"}),"vscode-apollo-relay"),")."),Object(i.b)("p",null,"Install the package:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"\nyarn add --dev relay-config\n\n")),Object(i.b)("p",null,"And create the configuration file:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\n// relay.config.js\nmodule.exports = {\n  // ...\n  // Configuration options accepted by the `relay-compiler` command-line tool and `babel-plugin-relay`.\n  src: "./src",\n  schema: "./data/schema.graphql",\n  exclude: ["**/node_modules/**", "**/__mocks__/**", "**/__generated__/**"],\n}\n\n')),Object(i.b)("h2",{id:"rendering-data-basics"},"Rendering Data Basics"),Object(i.b)("h3",{id:"fragments"},"Fragments"),Object(i.b)("p",null,"The main building block for declaring data dependencies for React Components in Relay are ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://graphql.org/learn/queries/#fragments"}),"GraphQL fragments"),", which are essentially a selection of fields on a GraphQL Type:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"\nfragment UserFragment on User {\n  name\n  age\n  profile_picture(scale: 2) {\n    uri\n  }\n}\n\n")),Object(i.b)("p",null,"In order to declare a fragment inside your JavaScript code, you must use the ",Object(i.b)("inlineCode",{parentName:"p"},"graphql")," tag:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {graphql} = require('react-relay/hooks');\n\nconst userFragment = graphql`\n  fragment UserFragment on User {\n    name\n    age\n    profile_picture(scale: 2) {\n      uri\n    }\n  }\n`;\n\n")),Object(i.b)("p",null,"In order to ",Object(i.b)("em",{parentName:"p"},"render")," the data for a fragment, you can use the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"useFragment"))," Hook:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {UserComponent_user$key} from 'UserComponent_user.graphql';\n\nconst React = require('React');\n\nconst {graphql, useFragment} = require('react-relay/hooks');\n\ntype Props = {|\n  user: UserComponent_user$key,\n|};\n\nfunction UserComponent(props: Props) {\n  const data = useFragment(\n    graphql`\n      fragment UserComponent_user on User {\n        name\n        profile_picture(scale: 2) {\n          uri\n        }\n      }\n    `,\n    props.user,\n  );\n\n  return (\n    <>\n      <h1>{data.name}</h1>\n      <div>\n        <img src={data.profile_picture?.uri} />\n      </div>\n    </>\n  );\n}\n\nmodule.exports = UserComponent;\n\n")),Object(i.b)("p",null,"Let's distill what's going on here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"useFragment")," takes a fragment definition and a ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"fragment reference")),", and returns the corresponding ",Object(i.b)("inlineCode",{parentName:"li"},"data")," for that fragment and reference."),Object(i.b)("li",{parentName:"ul"},"A ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"fragment reference"))," is an object that Relay uses to ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"read"))," the data declared in the fragment definition; as you can see, the ",Object(i.b)("inlineCode",{parentName:"li"},"UserComponent_user")," fragment itself just declares fields on the ",Object(i.b)("inlineCode",{parentName:"li"},"User")," type, but we need to know ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"which"))," specific user to read those fields from; this is what the fragment reference corresponds to. In other words, a fragment reference is like ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"a pointer to a specific instance of a type"))," that we want to read data from."),Object(i.b)("li",{parentName:"ul"},"Note that ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"the component is automatically subscribed to updates to the fragment data:"))," if the data for this particular ",Object(i.b)("inlineCode",{parentName:"li"},"User")," is updated anywhere in the app (e.g. via fetching new data, or mutating existing data), the component will automatically re-render with the latest updated data."),Object(i.b)("li",{parentName:"ul"},"Relay will automatically generate Flow types for any declared fragments when the compiler is run, so you can use these types to declare the type for your Component's ",Object(i.b)("inlineCode",{parentName:"li"},"props"),".",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"The generated Flow types include a type for the fragment reference, which is the type with the ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"$key"))," suffix: ",Object(i.b)("inlineCode",{parentName:"li"},"<fragment_name>$key"),", and a type for the shape of the data, which is the type with the ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"$data"))," suffix:  ",Object(i.b)("inlineCode",{parentName:"li"},"<fragment_name>$data"),"; these types are available to import from files that are generated with the following name: ",Object(i.b)("inlineCode",{parentName:"li"},"<fragment_name>.graphql.js"),"."),Object(i.b)("li",{parentName:"ul"},"We use our ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/relayjs/eslint-plugin-relay"}),"lint rule")," to enforce that the type of the fragment reference prop is correctly declared when using ",Object(i.b)("inlineCode",{parentName:"li"},"useFragment"),". By using a properly typed fragment reference as input, the type of the returned ",Object(i.b)("inlineCode",{parentName:"li"},"data")," will automatically be Flow typed without requiring an explicit annotation."),Object(i.b)("li",{parentName:"ul"},"In our example, we're typing the ",Object(i.b)("inlineCode",{parentName:"li"},"user")," prop as the fragment reference we need for ",Object(i.b)("inlineCode",{parentName:"li"},"useFragment"),", which corresponds to the ",Object(i.b)("inlineCode",{parentName:"li"},"UserComponent_user$key")," imported from  ",Object(i.b)("inlineCode",{parentName:"li"},"UserComponent_user.graphql"),", which means that the type of ",Object(i.b)("inlineCode",{parentName:"li"},"data")," above would be: ",Object(i.b)("inlineCode",{parentName:"li"},"{| name: ?string, profile_picture: ?{| uri: ?string |} |}"),"."))),Object(i.b)("li",{parentName:"ul"},"Fragment names need to be globally unique. In order to easily achieve this, we name fragments using the following convention based on the module name followed by an identifier: ",Object(i.b)("inlineCode",{parentName:"li"},"<module_name>_<property_name>"),". This makes it easy to identify which fragments are defined in which modules and avoids name collisions when multiple fragments are defined in the same module.")),Object(i.b)("p",null,"If you need to render data from multiple fragments inside the same component, you can use  ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"useFragment"))," multiple times:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {UserComponent_user$key} from 'UserComponent_user.graphql';\nimport type {UserComponent_viewer$key} from 'UserComponent_viewer.graphql';\n\nconst React = require('React');\nconst {graphql, useFragment} = require('react-relay/hooks');\n\ntype Props = {|\n  user: UserComponent_user$key,\n  viewer: UserComponent_viewer$key,\n|};\n\nfunction UserComponent(props: Props) {\n  const userData = useFragment(\n    graphql`\n      fragment UserComponent_user on User(id: $ID!) {\n        name\n        profile_picture(scale: 2) {\n          uri\n        }\n      }\n    `,\n    props.user,\n  );\n\n  const viewerData = useFragment(\n    graphql`\n      fragment UserComponent_viewer on Viewer {\n        actor {\n          name\n        }\n      }\n    `,\n    props.viewer,\n  );\n\n  return (\n    <>\n      <h1>{userData.name}</h1>\n      <div>\n        <img src={userData.profile_picture?.uri} />\n        Acting as: {viewerData.actor?.name ?? 'Unknown'}\n      </div>\n    </>\n  );\n}\n\nmodule.exports = UserComponent;\n\n")),Object(i.b)("h3",{id:"composing-fragments"},"Composing Fragments"),Object(i.b)("p",null,"In GraphQL, fragments are reusable units, which means they can include ",Object(i.b)("em",{parentName:"p"},"other")," fragments, and consequently a fragment can be included within other fragments or ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#queries"}),"Queries"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"\nfragment UserFragment on User {\n  name\n  age\n  profile_picture(scale: 2) {\n    uri\n  }\n  ...AnotherUserFragment\n}\n\nfragment AnotherUserFragment on User {\n  username\n  ...FooUserFragment\n}\n\n")),Object(i.b)("p",null,"With Relay, you can compose fragment components in a similar way, using both component composition and fragment composition. Each React component is responsible for fetching the data dependencies of its direct children - just as it has to know about its children's props in order to render them correctly. This pattern means that developers are able to reason locally about components - what data they need, what components they render - but Relay is able to derive a global view of the data dependencies of an entire UI tree."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * UsernameSection.react.js\n *\n * Child Fragment Component\n */\n\nimport type {UsernameSection_user$key} from 'UsernameSection_user.graphql';\n\nconst React = require('React');\nconst {graphql, useFragment} = require('react-relay/hooks');\n\ntype Props = {|\n  user: UsernameSection_user$key,\n|};\n\nfunction UsernameSection(props: Props) {\n  const data = useFragment(\n    graphql`\n      fragment UsernameSection_user on User {\n        username\n      }\n    `,\n    props.user,\n  );\n\n  return <div>{data.username ?? 'Unknown'}</div>;\n}\n\nmodule.exports = UsernameSection;\n\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * UserComponent.react.js\n *\n * Parent Fragment Component\n */\n\nimport type {UserComponent_user$key} from 'UserComponent_user.graphql';\n\nconst React = require('React');\nconst {graphql, useFragment} = require('react-relay/hooks');\n\nconst UsernameSection = require('./UsernameSection.react');\n\ntype Props = {|\n  user: UserComponent_user$key,\n|};\n\nfunction UserComponent(props: Props) {\n  const user = useFragment(\n    graphql`\n      fragment UserComponent_user on User {\n        name\n        age\n        profile_picture(scale: 2) {\n          uri\n        }\n\n        # Include child fragment:\n        ...UsernameSection_user\n      }\n    `,\n    props.user,\n  );\n\n  // Render child component by passing the _fragment reference_ to <UsernameSection>\n  return (\n    <>\n      <h1>{user.name}</h1>\n      <div>\n        <img src={user.profile_picture?.uri} />\n        {user.age}\n\n        <UsernameSection user={user}/>\n      </div>\n    </>\n  );\n}\n\nmodule.exports = UserComponent;\n\n")),Object(i.b)("p",null,"There are a few things to note here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"UserComponent")," both renders ",Object(i.b)("inlineCode",{parentName:"li"},"UsernameSection"),", ",Object(i.b)("em",{parentName:"li"},"and")," includes the fragment declared by ",Object(i.b)("inlineCode",{parentName:"li"},"UsernameSection")," inside its own ",Object(i.b)("inlineCode",{parentName:"li"},"graphql")," fragment declaration."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"UsernameSection")," expects a ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"fragment reference"))," as the ",Object(i.b)("inlineCode",{parentName:"li"},"user")," prop. As we've mentioned before, a fragment reference is an object that Relay uses to ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"read"))," the data declared in the fragment definition; as you can see, the child ",Object(i.b)("inlineCode",{parentName:"li"},"UsernameSection_user")," fragment itself just declares fields on the ",Object(i.b)("inlineCode",{parentName:"li"},"User")," type, but we need to know ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"which"))," specific user to read those fields from; this is what the fragment reference corresponds to. In other words, a fragment reference is like ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"a pointer to a specific instance of a type"))," that we want to read data from."),Object(i.b)("li",{parentName:"ul"},"Note that in this case the ",Object(i.b)("inlineCode",{parentName:"li"},"user")," passed to ",Object(i.b)("inlineCode",{parentName:"li"},"UsernameSection"),", i.e. the fragment reference, ",Object(i.b)("em",{parentName:"li"},"doesn't actually contain any of the data declared by the child ",Object(i.b)("inlineCode",{parentName:"em"},"UsernameSection")," component"),"; instead, ",Object(i.b)("inlineCode",{parentName:"li"},"UsernameSection")," will use the fragment reference to read the data ",Object(i.b)("em",{parentName:"li"},"it")," declared internally, using ",Object(i.b)("inlineCode",{parentName:"li"},"useFragment"),". This prevents the parent from implicitly creating dependencies on data declared by its children, and vice-versa, which allows us to reason locally about our components and modify them without worrying about affecting other components. If this wasn't the case, and the parent had access to the child's data, modifying the data declared by the child could break the parent. This is known as ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://relay.dev/docs/en/thinking-in-relay#data-masking"}),Object(i.b)("strong",{parentName:"a"},Object(i.b)("em",{parentName:"strong"},"data masking"))),"."),Object(i.b)("li",{parentName:"ul"},"The ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"fragment reference"))," that the child (i.e.  ",Object(i.b)("inlineCode",{parentName:"li"},"UsernameSection"),") expects is the result of reading a parent fragment that ",Object(i.b)("em",{parentName:"li"},"includes")," the child fragment. In our particular example, that means the result of reading a fragment that includes ",Object(i.b)("inlineCode",{parentName:"li"},"...UsernameSection_user")," will be the fragment reference that ",Object(i.b)("inlineCode",{parentName:"li"},"UsernameSection")," expects. In other words, the data obtained as a result of reading a fragment via ",Object(i.b)("inlineCode",{parentName:"li"},"useFragment")," also serves as the fragment reference for any child fragments included in that fragment.")),Object(i.b)("h3",{id:"queries"},"Queries"),Object(i.b)("p",null,"A ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://graphql.github.io/learn/queries/"}),"GraphQL query")," is a request that can be sent to a GraphQL server in combination with a set of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#variables"}),"Variables"),", in order to fetch some data. It consists of a selection of fields, and potentially includes other fragments:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"\nquery UserQuery($id: ID!) {\n  user(id: $id) {\n    id\n    name\n    ...UserFragment\n  }\n  viewer {\n    actor {\n      name\n    }\n  }\n}\n\nfragment UserFragment on User {\n  username\n}\n\n")),Object(i.b)("p",null,"Sample response:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'\n{\n  "data": {\n    "user": {\n      "id": "4",\n      "name": "Mark Zuckerberg",\n      "username": "zuck"\n    },\n    "viewer": {\n      "actor": {\n        "name": "Your Name"\n      }\n    }\n  }\n}\n\n')),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"NOTE:"))," Fragments in Relay allow declaring data dependencies for a component, but they can't be fetched by themselves; they need to be included by a query, either directly or transitively. This implies that ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"all fragments must belong to a query when they are rendered")),", or in other words, they must be ",Object(i.b)("em",{parentName:"p"},"rooted")," under some query. Note that a single fragment can still be included by multiple queries, but when rendering a specific ",Object(i.b)("em",{parentName:"p"},"instance")," of a fragment component, it must have been included as part of a specific query request."),Object(i.b)("hr",null),Object(i.b)("p",null,"To ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"fetch"))," ",Object(i.b)("em",{parentName:"p"},"and")," render a query in Relay, you can use ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"useLazyLoadQuery"))," Hook:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {AppQuery} from 'AppQuery.graphql';\n\nconst React = require('React');\nconst {graphql, useLazyLoadQuery} = require('react-relay/hooks');\n\nfunction App() {\n  const data = useLazyLoadQuery<AppQuery>(\n    graphql`\n      query AppQuery($id: ID!) {\n        user(id: $id) {\n          name\n        }\n      }\n    `,\n    {id: '4'},\n  );\n\n  return (\n    <h1>{data.user?.name}</h1>\n  );\n}\n\n")),Object(i.b)("p",null,"Lets see what's going on here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"useLazyLoadQuery")),"  takes a ",Object(i.b)("inlineCode",{parentName:"li"},"graphql")," query and some variables for that query, and returns the data that was fetched for that query. The ",Object(i.b)("inlineCode",{parentName:"li"},"variables")," are an object containing the values for the ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#variables"}),"Variables")," referenced inside the GraphQL query."),Object(i.b)("li",{parentName:"ul"},"Similarly to fragments, the component is automatically subscribed to updates to the query data: if the data for this query is updated anywhere in the app, the component will automatically re-render with the latest updated data."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"useLazyLoadQuery")," additionally, it takes a Flow type parameter, which corresponds to the Flow type for the query, in this case ",Object(i.b)("inlineCode",{parentName:"li"},"AppQuery"),".",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Remember that Relay automatically generates Flow types for any declared queries, which you can import and use with ",Object(i.b)("inlineCode",{parentName:"li"},"useLazyLoadQuery"),". These types are available in the generated files with the following name format: ",Object(i.b)("inlineCode",{parentName:"li"},"<query_name>.graphql.js"),"."),Object(i.b)("li",{parentName:"ul"},"Note that the ",Object(i.b)("inlineCode",{parentName:"li"},"variables")," will checked by Flow to ensure that you are passing values that match what the GraphQL query expects."),Object(i.b)("li",{parentName:"ul"},"Note that the ",Object(i.b)("inlineCode",{parentName:"li"},"data")," is already properly Flow typed without requiring an explicit annotation, and is based on the types from the GraphQL schema. For example, the type of ",Object(i.b)("inlineCode",{parentName:"li"},"data")," above would be: ",Object(i.b)("inlineCode",{parentName:"li"},"{| user: ?{| name: ?string |} |}"),"."))),Object(i.b)("li",{parentName:"ul"},"By default, when the component renders, Relay will automatically ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"fetch"))," the data for this query from the server (if it isn't already cached), and return it as a the result of the ",Object(i.b)("inlineCode",{parentName:"li"},"useLazyLoadQuery")," call. We'll go into more detail about how to show loading states in the ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#loading-states-with-suspense"}),"Loading States With Suspense")," section, and how Relay uses cached data in the ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#reusing-cached-data-for-render"}),"Reusing Cached Data for Render")," section."),Object(i.b)("li",{parentName:"ul"},"Note that if you re-render your component and pass ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"different query variables"))," than the ones originally used, it will cause the query to be fetched again with the new variables, and potentially re-render with different data."),Object(i.b)("li",{parentName:"ul"},"Finally, make sure you're providing a Relay environment at the root of your app before trying to render a query: ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#relay-environment-provider"}),"Relay Environment Provider"),".")),Object(i.b)("p",null,"To fetch and render a query that includes a fragment, you can compose them in the same way fragments are composed, as shown in the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#composing-fragments"}),"Composing Fragments")," section:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * UserComponent.react.js\n *\n * Fragment Component\n */\n\nimport type {UserComponent_user$key} from 'UserComponent_user.graphql';\n\nconst React = require('React');\nconst {graphql, useFragment} = require('react-relay/hooks');\n\ntype Props = {|\n  user: UserComponent_user$key,\n|};\n\nfunction UserComponent(props: Props) {\n  const data = useFragment(\n    graphql`...`,\n    props.user,\n  );\n\n  return (...);\n}\n\nmodule.exports = UserComponent;\n\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * App.react.js\n *\n * Query Component\n */\n\nimport type {AppQuery} from 'AppQuery.graphql';\n\nconst React = require('React');\nconst {graphql, useLazyLoadQuery} = require('react-relay/hooks');\n\nconst UserComponent = require('./UserComponent.react');\n\nfunction App() {\n  const data = useLazyLoadQuery<AppQuery>(\n    graphql`\n      query AppQuery($id: ID!) {\n        user(id: $id) {\n          name\n\n          # Include child fragment:\n          ...UserComponent_user\n        }\n      }\n    `,\n    {id: '4'},\n  );\n\n  // Render child component by passing the fragment reference to <UserComponent>:\n  return (\n    <>\n      <h1>{data.user?.name}</h1>\n      <UserComponent user={data.user} />\n    </>\n  );\n}\n\n")),Object(i.b)("p",null,"Note that:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"fragment reference"))," that ",Object(i.b)("inlineCode",{parentName:"li"},"UserComponent")," expects is the result of reading a parent query that includes its fragment, which in our case means a query that includes ",Object(i.b)("inlineCode",{parentName:"li"},"...UsernameSection_user"),". In other words, the ",Object(i.b)("inlineCode",{parentName:"li"},"data")," obtained as a result of ",Object(i.b)("inlineCode",{parentName:"li"},"useLazyLoadQuery")," also serves as the fragment reference for any child fragments included in that query."),Object(i.b)("li",{parentName:"ul"},"As mentioned previously, ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"all fragments must belong to a query when they are rendered,"))," which means that all fragment components ",Object(i.b)("em",{parentName:"li"},"must")," be descendants of a query. This guarantees that you will always be able to provide a fragment reference for ",Object(i.b)("inlineCode",{parentName:"li"},"useFragment"),", by starting from the result of reading a root query with ",Object(i.b)("inlineCode",{parentName:"li"},"useLazyLoadQuery"),".")),Object(i.b)("h3",{id:"variables"},"Variables"),Object(i.b)("p",null,"You may have noticed that the query declarations in our examples above contain references to an ",Object(i.b)("inlineCode",{parentName:"p"},"$id")," symbol inside the GraphQL code: these are ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://graphql.github.io/learn/queries/#variables"}),"GraphQL Variables"),"."),Object(i.b)("p",null,"GraphQL variables are a construct that allows referencing dynamic values inside a GraphQL query. When fetching a query from the server, we also need to provide as input the actual set of values to use for the variables declared inside the query:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"\n# `$id` is a variable of type `ID!`\nquery UserQuery($id: ID!) {\n\n  # The value of `$id` is used as input to the user() call:\n  user(id: $id) {\n    id\n    name\n  }\n}\n\n")),Object(i.b)("p",null,"When sending a network request to fetch the query above, we need to provide both the query, and the variables to be used for this particular execution of the query. For example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),'\n# Query:\nquery UserQuery($id: ID!) {\n  # ...\n}\n\n# Variables:\n{"id": 4}\n\n')),Object(i.b)("p",null,"Fetching the above query and variables from the server would produce the following response:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\n{\n  "data": {\n    "user": {\n      "id": "4",\n      "name": "User 4"\n    }\n  }\n}\n\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Note that changing the value of the ",Object(i.b)("inlineCode",{parentName:"li"},"id")," variable used as input would of course produce a different response.")),Object(i.b)("hr",null),Object(i.b)("p",null,"Fragments can also reference variables that have been declared by a query:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"\nfragment UserFragment on User {\n  name\n  profile_picture(scale: $scale) {\n    uri\n  }\n}\n\nquery ViewerQuery($scale: Float!) {\n  viewer {\n    actor {\n      ...UserFragment\n    }\n  }\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Even though the fragment above doesn't ",Object(i.b)("em",{parentName:"li"},"declare")," the ",Object(i.b)("inlineCode",{parentName:"li"},"$scale")," variable directly, it can still reference it. Doing so makes it so any query that includes this fragment, either directly or transitively, ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"must"))," declare the variable and it's type, otherwise an error will be produced by the Relay compiler."),Object(i.b)("li",{parentName:"ul"},"In other words, ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"query variables are available globally by any fragment that is a descendant of the query")),".")),Object(i.b)("p",null,"In Relay, fragment declarations inside components can also reference query variables:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nfunction UserComponent(props: Props) {\n  const data = useFragment(\n    graphql`\n    fragment UserComponent_user on User {\n      name\n      profile_picture(scale: $scale) {\n        uri\n      }\n    }\n    `,\n    props.user,\n  );\n\n  return (...);\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The above fragment could be included by multiple queries, and rendered by different components, which means that any query that ends up rendering/including the above fragment ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"must"))," declare the ",Object(i.b)("inlineCode",{parentName:"li"},"$scale")," variable."),Object(i.b)("li",{parentName:"ul"},"If any query that happens to include this fragment ",Object(i.b)("em",{parentName:"li"},"doesn't")," declare the ",Object(i.b)("inlineCode",{parentName:"li"},"$scale")," variable, an error will be produced by the Relay Compiler at build time, ensuring that an incorrect query never gets sent to the server (sending a query with missing variable declarations will also produce an error in the server).")),Object(i.b)("h3",{id:"arguments-and-argumentdefinitions"},Object(i.b)("inlineCode",{parentName:"h3"},"@arguments")," and ",Object(i.b)("inlineCode",{parentName:"h3"},"@argumentDefinitions")),Object(i.b)("p",null,"However, in order to prevent bloating queries with global variable declarations, Relay also provides a way to declare variables that are scoped locally to a fragment using the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"@arguments"))," and ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"@argumentDefinitions"))," directives:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\n/**\n * Declare a fragment that accepts arguments with @argumentDefinitions\n */\n\nfunction PictureComponent(props) {\n  const data = useFragment(\n    graphql`\n      fragment PictureComponent_user on User\n        @argumentDefinitions(scale: {type: "Float!"}) {\n\n        # `$scale` is a local variable here, declared above\n        # as an argument `scale`, of type `Float!`\n        profile_picture(scale: $scale) {\n          uri\n        }\n      }\n    `,\n    props.user,\n  );\n}\n\n')),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * Include fragment using @arguments\n */\n\nfunction UserComponent(props) {\n  const data = useFragment(\n    graphql`\n      fragment UserComponent_user on User {\n        name\n\n        # Pass value of 2.0 for the `scale` variable\n        ...PictureComponent_user @arguments(scale: 2.0)\n      }\n    `,\n    props.user,\n  );\n}\n\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * Include same fragment using _different_ @arguments\n */\n\nfunction OtherUserComponent(props) {\n  const data = useFragment(\n    graphql`\n      fragment OtherUserComponent_user on User {\n        name\n\n        # Pass a different value for the scale variable.\n        # The value can be another local or global variable:\n        ...PictureComponent_user @arguments(scale: $pictureScale)\n      }\n    `,\n    props.user,\n  );\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Note that when passing ",Object(i.b)("inlineCode",{parentName:"li"},"@arguments")," to a fragment, we can pass a literal value or pass another variable. The variable can be a global query variable, or another local variable declared via ",Object(i.b)("inlineCode",{parentName:"li"},"@argumentDefinitions"),"."),Object(i.b)("li",{parentName:"ul"},"When we actually fetch ",Object(i.b)("inlineCode",{parentName:"li"},"PictureComponent_user")," as part of a query, the ",Object(i.b)("inlineCode",{parentName:"li"},"scale")," value passed to the ",Object(i.b)("inlineCode",{parentName:"li"},"profile_picture")," field will depend on the argument that was provided by the parent of ",Object(i.b)("inlineCode",{parentName:"li"},"PictureComponent_user"),":",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"For ",Object(i.b)("inlineCode",{parentName:"li"},"UserComponent_user")," the value of ",Object(i.b)("inlineCode",{parentName:"li"},"$scale")," will be 2.0."),Object(i.b)("li",{parentName:"ul"},"For ",Object(i.b)("inlineCode",{parentName:"li"},"OtherUserComponent_user"),", the value of ",Object(i.b)("inlineCode",{parentName:"li"},"$scale")," will be whatever value we pass to the server for the ",Object(i.b)("inlineCode",{parentName:"li"},"$pictureScale")," variable when we fetch the query.")))),Object(i.b)("p",null,"Fragments that expect arguments can also declare default values, making the arguments optional:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\n/**\n * Declare a fragment that accepts arguments with default values\n */\n\nfunction PictureComponent(props) {\n  const data = useFragment(\n    graphql`\n      fragment PictureComponent_user on User\n        @argumentDefinitions(scale: {type: "Float!", defaultValue: 2.0}) {\n\n        # `$scale` is a local variable here, declared above\n        # as an argument `scale`, of type `Float!` with a default value of `2.0`\n        profile_picture(scale: $scale) {\n          uri\n        }\n      }\n    `,\n    props.user,\n  );\n}\n\n')),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nfunction UserComponent(props) {\n  const data = useFragment(\n    graphql`\n      fragment UserComponent_user on User {\n        name\n\n        # Do not pass an argument, value for scale will be `2.0`\n        ...PictureComponent_user\n      }\n    `,\n    props.user,\n  );\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Not passing the argument to ",Object(i.b)("inlineCode",{parentName:"li"},"PictureComponent_user")," makes it use the default value for its locally declared ",Object(i.b)("inlineCode",{parentName:"li"},"$scale")," variable, in this case 2.0.")),Object(i.b)("h4",{id:"accessing-graphql-variables-at-runtime"},"Accessing GraphQL Variables At Runtime"),Object(i.b)("p",null,"If you want to access the variables that were set at the query root, the recommended approach is to pass the variables down the component tree in your application, using props, or your own application-specific context."),Object(i.b)("p",null,"Relay currently does not expose the resolved variables (i.e. after applying argument definitions) for a specific fragment, and you should very rarely need to do so."),Object(i.b)("h3",{id:"loading-states-with-suspense"},"Loading States with Suspense"),Object(i.b)("p",null,"As you may have noticed, we mentioned that using ",Object(i.b)("inlineCode",{parentName:"p"},"useLazyLoadQuery")," will ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"fetch"))," a query from the server, but we didn't elaborate on how to render a loading UI while the query is being loaded. We will cover that in this section."),Object(i.b)("p",null,"To render loading states while a query is being fetched, we rely on ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/concurrent-mode-suspense.html"}),"React Suspense"),". Suspense is a new feature in React that allows components to interrupt or ",Object(i.b)("em",{parentName:"p"},'"suspend"'),' rendering in order to wait for some asynchronous resource (such as code, images or data) to be loaded; when a component "suspends", it indicates to React that the component isn\'t ',Object(i.b)("em",{parentName:"p"},'"ready"')," to be rendered yet, and won't be until the asynchronous resource it's waiting for is loaded. When the resource finally loads, React will try to render the component again."),Object(i.b)("p",null,"This capability is useful for components to express asynchronous dependencies like data, code, or images that they require in order to render, and lets React coordinate rendering the loading states across a component tree as these asynchronous resources become available. More generally, the use of Suspense give us better control to implement more deliberately designed loading states when our app is loading for the first time or when it's transitioning to different states, and helps prevent accidental flickering of loading elements (such as spinners), which can commonly occur when loading sequences aren't explicitly designed and coordinated."),Object(i.b)("p",null,"For a lot more details on Suspense, check the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/concurrent-mode-suspense.html"}),"React docs on Suspense"),"."),Object(i.b)("h4",{id:"loading-fallbacks-with-suspense-boundaries"},"Loading fallbacks with Suspense Boundaries"),Object(i.b)("p",null,"When a component is suspended, we need to render a ",Object(i.b)("em",{parentName:"p"},"fallback")," in place of the component while we await for it to become ",Object(i.b)("em",{parentName:"p"},'"ready"'),". In order to do so, we use the ",Object(i.b)("inlineCode",{parentName:"p"},"Suspense")," component provided by React:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst React = require('React');\nconst {Suspense} = require('React');\n\nfunction App() {\n  return (\n    // Render a fallback using Suspense as a wrapper\n    <Suspense fallback={<LoadingSpinner />}>\n      <CanSuspend />\n    </Suspense>\n  );\n}\n\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Suspense")," components can be used to wrap any component; if the target component suspends, ",Object(i.b)("inlineCode",{parentName:"p"},"Suspense")," will render the provided fallback until all its descendants become ",Object(i.b)("em",{parentName:"p"},'"ready"')," (i.e. until ",Object(i.b)("em",{parentName:"p"},"all")," of the promises thrown inside its subtree of descendants resolve). Usually, the fallback is used to render a loading state, such as a glimmer."),Object(i.b)("p",null,"Usually, different pieces of content in our app might suspend, so we can show loading state until they are resolved by using ",Object(i.b)("inlineCode",{parentName:"p"},"Suspense")," :"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * App.react.js\n */\n\nconst React = require('React');\nconst {Suspense} = require('React');\n\nconst LoadingSpinner = require('./LoadingSpinner.react');\nconst MainContent = require('./MainContent.react');\n\nfunction App() {\n  return (\n    // LoadingSpinner is rendered via the Suspense fallback\n    <Suspense fallback={<LoadingSpinner />}>\n      <MainContent\n        // MainContent may suspend\n      />\n    </Suspense>\n  );\n}\n\n")),Object(i.b)("p",null,"Let's distill what's going on here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"If ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," suspends because it's waiting on some asynchronous resource (like data), the ",Object(i.b)("inlineCode",{parentName:"li"},"Suspense")," component that wraps ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," will detect that it suspended, and will render the ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"fallback"))," element (i.e. the ",Object(i.b)("inlineCode",{parentName:"li"},"LoadingSpinner")," in this case) up until ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," is ready to be rendered. Note that this also transitively includes descendants of ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent"),", which might also suspend.")),Object(i.b)("p",null,"What's nice about Suspense is that you have granular control about how to accumulate loading states for different parts of your component tree:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * App.react.js\n */\n\nconst React = require('React');\nconst {Suspense} = require('React');\n\nconst LoadingSpinner = require('./LoadingSpinner.react');\nconst MainContent = require('./MainContent.react');\nconst SecondaryContent = require('./SecondaryContent.react');\n\nfunction App() {\n  return (\n    // A LoadingSpinner for *_all_* content is rendered via the Suspense fallback\n    <Suspense fallback={<LoadingSpinner />}>\n      <MainContent />\n      <SecondaryContent\n        // SecondaryContent can also suspend\n      />\n    </Suspense>\n  );\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"In this case, both ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," and ",Object(i.b)("inlineCode",{parentName:"li"},"SecondaryContent")," may suspend while they load their asynchronous resources; by wrapping both in a ",Object(i.b)("inlineCode",{parentName:"li"},"Suspense"),", we can show a single loading state up until they are ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"all"))," ready, and then render the entire content in a single paint, after everything has successfully loaded."),Object(i.b)("li",{parentName:"ul"},"In fact, ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," and ",Object(i.b)("inlineCode",{parentName:"li"},"SecondaryContent")," may suspend for different reasons other than fetching data, but the same ",Object(i.b)("inlineCode",{parentName:"li"},"Suspense")," component can be used to render a fallback up until ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"all"))," components in the subtree are ready to be rendered. Note that this also transitively includes descendants of ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," or ",Object(i.b)("inlineCode",{parentName:"li"},"SecondaryContent"),", which might also suspend.")),Object(i.b)("p",null,"Conversely, you can also decide to be more granular about your loading UI and wrap Suspense components around smaller or individual parts of your component tree:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * App.react.js\n */\n\nconst React = require('React');\nconst {Suspense} = require('React');\n\nconst LoadingSpinner = require('./LoadingSpinner.react');\nconst LeftColumn = require('./LeftHandColumn.react');\nconst LeftColumnPlaceholder = require('./LeftHandColumnPlaceholder.react');\nconst MainContent = require('./MainContent.react');\nconst SecondaryContent = require('./SecondaryContent.react');\n\nfunction App() {\n  return (\n    <>\n      <Suspense\n        // Show a separate loading UI for the LeftHandColumn\n        fallback={<LeftColumnPlaceholder />}\n      >\n        <LeftColumn />\n      </Suspense>\n\n      <Suspense\n        // Show a separate loading UI for both the Main and Secondary content\n        fallback={<LoadingSpinner />}\n      >\n        <MainContent />\n        <SecondaryContent />\n      </Suspense>\n    </>\n  );\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"In this case, we're showing 2 separate loading UIs:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"One to be shown until the ",Object(i.b)("inlineCode",{parentName:"li"},"LeftColumn")," becomes ready."),Object(i.b)("li",{parentName:"ul"},"And one to be shown until both the ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," and ",Object(i.b)("inlineCode",{parentName:"li"},"SecondaryContent")," become ready."))),Object(i.b)("li",{parentName:"ul"},"What is powerful about this is that by more granularly wrapping our components in Suspense, ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"we allow other components to be rendered earlier as they become ready")),". In our example, by separately wrapping ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," and ",Object(i.b)("inlineCode",{parentName:"li"},"SecondaryContent")," under ",Object(i.b)("inlineCode",{parentName:"li"},"Suspense"),", we're allowing ",Object(i.b)("inlineCode",{parentName:"li"},"LeftColumn")," to render as soon as it becomes ready, which might be earlier than when the content sections become ready.")),Object(i.b)("h4",{id:"transitions-and-updates-that-suspend"},"Transitions and Updates that Suspend"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Suspense")," boundary fallbacks allow us to describe our loading states when initially rendering some content, but our applications will also have transitions between different content. Specifically, when switching between two components within an already mounted boundary, the new component you're switching to might not have loaded all of its async dependencies, which means that it will also suspend."),Object(i.b)("p",null,"Whenever we're going to make a transition that might cause new content to suspend, we should use the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/concurrent-mode-patterns.html#transitions"}),Object(i.b)("strong",{parentName:"a"},Object(i.b)("inlineCode",{parentName:"strong"},"useTransition")))," to schedule the update for  transition:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {\n  useState,\n  useTransition,\n} = require('React');\n\nfunction TabSwitcher() {\n  // We use startTransition to schedule the update\n  const [startTransition] = useTransition();\n  const [selectedTab, setSelectedTab] = useState('Home');\n\n  return (\n    <div>\n      <Suspense fallback={<LoadingGlimmer />}>\n        <MainContent tab={selectedTab} />\n      </Suspense>\n      <Button\n        onClick={() =>\n          startTransition(() => {\n            // Schedule an update that might suspend\n            setSelectedTab('Photos');\n          })\n        }>\n        Show Photos\n      </Button>\n    </div>\n  );\n}\n\n")),Object(i.b)("p",null,"Let's take a look at what's happening here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"We have a ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," component that takes a tab to render. This component might suspend while it loads the content for the current tab. During initial render, if this component suspends, we'll show the ",Object(i.b)("inlineCode",{parentName:"li"},"LoadingGlimmer")," fallback from the ",Object(i.b)("inlineCode",{parentName:"li"},"Suspense")," boundary that is wrapping it."),Object(i.b)("li",{parentName:"ul"},"Additionally, in order to change tabs, we're keeping some state for the currently selected tab; when we set state to change the current tab, this will be an update that can cause the ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," component to suspend again, since it may have to load the content for the new tab. Since this update may cause the component to suspend, ",Object(i.b)("strong",{parentName:"li"},"we need to make sure to schedule it using the ",Object(i.b)("inlineCode",{parentName:"strong"},"startTransition")," function we get from ",Object(i.b)("inlineCode",{parentName:"strong"},"useTransition")),". By doing so, we're letting React know that the update may suspend, so React can coordinate and render it at the right priority.")),Object(i.b)("p",null,'However, when we make these sorts of transitions, we ideally want to avoid "bad loading states", that is, loading states (e.g. a glimmer) that would replace content that has already been rendered on the screen. In this case for example, if we\'re already showing content for a tab, instead of immediately replacing the content with a glimmer, we might instead want to render some sort of "pending" or "busy" state to let the user know that we\'re changing tabs, and then render the new selected tab when it\'s hopefully mostly ready. In order to do so, this is where we need to take into account the different ',Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/concurrent-mode-patterns.html#the-three-steps"}),"stages")," of a transition (",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"pending"))," \u2192 ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"loading"))," \u2192 ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"complete")),"), and make use of additional Suspense ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/concurrent-mode-patterns.html#transitions"}),"primitives"),", that allow us to control what we want to show at each stage."),Object(i.b)("p",null,"The ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"pending")),' stage is the first state in a transition, and is usually rendered close to the element that initiated the action (e.g. a "busy spinner" next to a button); it should occur immediately (at a high priority), and be rendered quickly in order to give post to the user that their action has been registered. The ',Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"loading"))," state occurs when we actually start showing the new content or the next screen; this update is usually heavier it can take a little longer, so it doesn't need to be executed at the highest priority. ",Object(i.b)("em",{parentName:"p"},"During the ",Object(i.b)("strong",{parentName:"em"},"loading")," state is where we'll show the fallbacks from our ",Object(i.b)("inlineCode",{parentName:"em"},"Suspense")," boundaries")," (i.e. placeholders for the new content, like glimmers);  some of the content might be partially rendered during this stage as async resources are loaded, so it can occur in multiple steps, until we finally reach the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"complete"))," state, where the full content is rendered."),Object(i.b)("p",null,"By default, when a suspense transition occurs, if the new content suspends, React will automatically transition to the loading state and show the fallbacks from any ",Object(i.b)("inlineCode",{parentName:"p"},"Suspense")," boundaries that are in place for the new content.  However, if we want to delay showing the loading state, and show a ",Object(i.b)("em",{parentName:"p"},"pending")," state instead, we can also use ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/concurrent-mode-patterns.html#transitions"}),Object(i.b)("strong",{parentName:"a"},Object(i.b)("inlineCode",{parentName:"strong"},"useTransition")))," to do so:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\nconst {\n  useState,\n  useTransition,\n} = require(\'React\');\n\nconst SUSPENSE_CONFIG = {\n  // timeoutMs allows us to delay showing the "loading" state for a while\n  // in favor of showing a "pending" state that we control locally\n  timeoutMs: 10 * 1000, // 10 seconds\n};\n\nfunction TabSwitcher() {\n  // isPending captures the "pending" state. It will become true\n  // **immediately** when the transition starts, and will be set back to false\n  // when the transition reaches the fully "completed" stage (i.e. when all the\n  // new content has fully loaded)\n  const [startTransition, isPending] = useTransition(SUSPENSE_CONFIG);\n  const [selectedTab, setSelectedTab] = useState(\'Home\');\n\n  return (\n    <div>\n      <Suspense fallback={<LoadingGlimmer />}>\n        <MainContent tab={selectedTab} />\n      </Suspense>\n      <Button\n        onClick={() =>\n          startTransition(() => {\n            // Schedule an update that might suspend\n            setSelectedTab(\'Photos\');\n          })\n        }\n        disabled={isPending}>\n        Show Photos\n      </Button>\n    </div>\n  );\n}\n\n')),Object(i.b)("blockquote",null,Object(i.b)("strong",null,"NOTE:")," Providing a Suspense config to ",Object(i.b)("code",null,"useTransition")," will only work as expected in ",Object(i.b)("strong",null,Object(i.b)("em",null,"React Concurrent Mode")),"."),Object(i.b)("p",null,"Let's take a look at what's happening here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"In this case, we're passing the ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"SUSPENSE_CONFIG"))," config object to ",Object(i.b)("inlineCode",{parentName:"li"},"useTransition")," in order to configure how we want this transition to behave. Specifically, we can pass a ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"timeoutMs"))," property in the config, which will dictate how long React should wait before transitioning to the ",Object(i.b)("em",{parentName:"li"},'"loading"')," state (i.e. transition to showing the fallbacks from the ",Object(i.b)("inlineCode",{parentName:"li"},"Suspense")," boundaries), in favor of showing a ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"pending"))," state controlled locally by the component during that time."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"useTransition")," will also return a ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"isPending"))," boolean value, which captures the pending state. That is, this value will become ",Object(i.b)("inlineCode",{parentName:"li"},"true")," ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"immediately"))," when the transition starts, and will become ",Object(i.b)("inlineCode",{parentName:"li"},"false")," when the transition reaches the fully ",Object(i.b)("em",{parentName:"li"},'"completed"')," stage, that is, when all the new content has been fully loaded. As mentioned above, the pending state should be used to give immediate post to the user that the action has been received, and we can do so by using the ",Object(i.b)("inlineCode",{parentName:"li"},"isPending")," value to control what we render; for example, we can use that value to render a spinner next to the button, or in this case, disable the button immediately after it is clicked.")),Object(i.b)("p",null,"For more details, check out the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/concurrent-mode-suspense.html"}),"React docs on Suspense"),"."),Object(i.b)("h4",{id:"how-we-use-suspense-in-relay"},"How We Use Suspense in Relay"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},Object(i.b)("strong",{parentName:"em"},"Queries"))),Object(i.b)("p",null,"In our case, our query renderer components are components that can suspend, so we use Suspense to render loading states while a query is being fetched. Let's see what that looks like in practice:"),Object(i.b)("p",null,"Say we have the following query renderer component:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * MainContent.react.js\n *\n * Query Component\n */\n\nconst React = require('React');\nconst {graphql, useLazyLoadQuery} = require('react-relay/hooks');\n\nfunction MainContent() {\n  // **Fetch** and render a query\n  const data = useLazyLoadQuery<...>(\n    graphql`...`,\n    variables: {...},\n  );\n\n  return (...);\n}\n\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * App.react.js\n */\n\nconst React = require('React');\nconst {Suspense} = require('React');\n\nconst LoadingSpinner = require('./LoadingSpinner.react');\nconst MainContent = require('./MainContent.react');\n\nfunction App() {\n  return (\n    // LoadingSpinner is rendered via the Suspense fallback\n    <Suspense fallback={<LoadingSpinner />}>\n      <MainContent\n        // MainContent may suspend\n      />\n    </Suspense>\n  );\n}\n\n")),Object(i.b)("p",null,"Let's distill what's going on here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"We have a ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," component, which is a query renderer that fetches and renders a query. ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," will ",Object(i.b)("em",{parentName:"li"},"suspend")," rendering when it attempts to fetch the query, indicating that it isn't ready to be rendered yet, and it will resolve when the query is fetched."),Object(i.b)("li",{parentName:"ul"},"The ",Object(i.b)("inlineCode",{parentName:"li"},"Suspense "),"component that wraps ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," will detect that ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," suspended, and will render the ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"fallback"))," element (i.e. the ",Object(i.b)("inlineCode",{parentName:"li"},"LoadingSpinner")," in this case) up until ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," is ready to be rendered; that is, up until the query is fetched.")),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},Object(i.b)("strong",{parentName:"em"},"Fragments"))),Object(i.b)("p",null,"Fragments are also integrated with Suspense in order to support rendering of data that's partially available in the Relay Store. For more details, check out the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#rendering-partially-cached-data-highly-experimental"}),"Rendering Partially Cached Data")," section."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"Transitions"))),Object(i.b)("p",null,"Additionally, our APIs for refetching (",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#re-rendering-with-different-data"}),"Re-rendering with Different Data"),") and for ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#rendering-connections"}),"Rendering Connections")," are also integrated with Suspense; for these use cases, we are initiating Suspense transitions after initial content has been rendered, such as by refetching or paginating, which means that these transitions should also use ",Object(i.b)("inlineCode",{parentName:"p"},"useTransition"),". Check out those sections for more details."),Object(i.b)("h3",{id:"error-states-with-error-boundaries"},"Error States with Error Boundaries"),Object(i.b)("p",null,"As you may have noticed, we mentioned that using ",Object(i.b)("inlineCode",{parentName:"p"},"useLazyLoadQuery")," will ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"fetch"))," a query from the server, but we didn't elaborate on how to render UI to show an error if an error occurred during fetch. We will cover that in this section."),Object(i.b)("p",null,"We can use ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/error-boundaries.html"}),Object(i.b)("strong",{parentName:"a"},"Error Boundary"))," components to catch errors that occur during render (due to a network error, or any kind of error), and render an alternative error UI when that occurs. The way it works is similar to how ",Object(i.b)("inlineCode",{parentName:"p"},"Suspense")," works, by wrapping a component tree in an error boundary, we can specify how we want to react when an error occurs, for example by rendering a fallback UI."),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/error-boundaries.html"}),"Error boundaries")," are simply components that implement the static ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"getDerivedStateFromError"))," method:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst React = require('React');\n\ntype State = {|error: ?Error|};\n\nclass ErrorBoundary extends React.Component<Props, State> {\n  static getDerivedStateFromError(error): State {\n    // Set some state derived from the caught error\n    return {error: error};\n  }\n}\n\n")),Object(i.b)("p",null,"Which we can use like so:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * App.react.js\n */\n\nconst ErrorBoundary = require('ErrorBoundary');\nconst React = require('React');\n\nconst MainContent = require('./MainContent.react');\nconst SecondaryContent = require('./SecondaryContent.react');\n\nfunction App() {\n  return (\n    // Render an ErrorSection if an error occurs within\n    // MainContent or SecondaryContent\n    <ErrorBoundary fallback={error => <ErrorUI error={error} />}>\n      <MainContent />\n      <SecondaryContent />\n    </ErrorBoundary>\n  );\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"We can use the Error Boundary to wrap subtrees and show a different UI when an error occurs within that subtree. When an error occurs, the specified ",Object(i.b)("inlineCode",{parentName:"li"},"fallback")," will be rendered instead of the content inside the boundary."),Object(i.b)("li",{parentName:"ul"},"Note that we can also control the granularity at which we render error UIs, by wrapping components at different levels with error boundaries. In this example, if any error occurs within ",Object(i.b)("inlineCode",{parentName:"li"},"MainContent")," or ",Object(i.b)("inlineCode",{parentName:"li"},"SecondaryContent"),", we will render an ",Object(i.b)("inlineCode",{parentName:"li"},"ErrorSection")," in place of the entire app content.")),Object(i.b)("h4",{id:"retrying-after-an-error"},"Retrying after an Error"),Object(i.b)("p",null,"In order to retry fetching a query after an error has occurred, we can attempt to re-mount the query component that produced an error:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * ErrorBoundaryWithRetry.react.js\n */\n\nconst React = require('React');\n\ntype State = {|error: ?Error|};\n\n// Sample ErrorBoundary that supports retrying to render the content\n// that errored\nclass ErrorBoundaryWithRetry extends React.Component<Props, State> {\n  state = {error: null};\n\n  static getDerivedStateFromError(error): State {\n    return {error: error};\n  }\n\n  _retry = () => {\n    this.setState({error: null});\n  }\n\n  render() {\n    const {children, fallback} = this.props;\n    const {error} = this.state;\n    if (error) {\n      if (typeof fallback === 'function') {\n        return fallback(error, this._retry);\n      }\n      return fallback;\n    }\n    return children;\n  }\n}\n\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * App.react.js\n */\n\nconst ErrorBoundary = require('ErrorBoundary');\nconst React = require('React');\n\nconst MainContent = require('./MainContent.react');\n\nfunction App() {\n  return (\n    <ErrorBoundaryWithRetry\n      fallback={(error, retry) =>\n        <>\n          <ErrorUI error={error} />\n          <Button\n            // Render a button to retry; this will attempt to re-render the\n            // content inside the boundary, i.e. the query component\n            onClick={retry}\n          >Retry</Button>\n        </>\n      }>\n      <MainContent />\n    </ErrorBoundaryWithRetry>\n  );\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The sample Error Boundary in this example code will provide a ",Object(i.b)("inlineCode",{parentName:"li"},"retry")," function to re-attempt to render the content that originally produced the error. By doing so, we will attempt to re-render our query component (that uses ",Object(i.b)("inlineCode",{parentName:"li"},"useLazyLoadQuery"),"), and consequently attempt to fetch the query again.")),Object(i.b)("h4",{id:"accessing-errors-in-graphql-response"},"Accessing errors in GraphQL Response"),Object(i.b)("p",null,"By default, Relay will ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"only"))," surface errors to React that are returned in the top-level ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://graphql.org/learn/validation/"}),"errors field"),", ",Object(i.b)("strong",{parentName:"p"},"if"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"the fetch function provided to the ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://relay.dev/docs/en/network-layer"}),"Relay Network")," throws or returns an Error."),Object(i.b)("li",{parentName:"ul"},"if the top-level ",Object(i.b)("inlineCode",{parentName:"li"},"data")," field wasn't returned in the response.")),Object(i.b)("p",null,"If you wish to access error information in your application to display user-friendly messages, the recommended approach is to model and expose the error information as part of your GraphQL schema."),Object(i.b)("p",null,"For example, you could expose a field in your schema that returns either the expected result, or an Error object if an error occurred while resolving that field (instead of returning null):"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"\ntype Error {\n  # User friendly message\n  message: String!\n}\n\ntype Foo {\n  bar: Result | Error\n}\n\n")),Object(i.b)("h3",{id:"environment"},"Environment"),Object(i.b)("h4",{id:"relay-environment-provider"},"Relay Environment Provider"),Object(i.b)("p",null,"In order to render Relay components, you need to render a ",Object(i.b)("inlineCode",{parentName:"p"},"RelayEnvironmentProvider")," component at the root of the app:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n// App root\n\nconst {RelayEnvironmentProvider} = require('react-relay/hooks');\n\nfunction Root() {\n  return (\n    <RelayEnvironmentProvider environment={environment}>\n      {...}\n    </RelayEnvironmentProvider>\n  );\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The ",Object(i.b)("inlineCode",{parentName:"li"},"RelayEnvironmentProvider "),"takes an environment, which it will make available to all descendant Relay components, and which is necessary for Relay to function.")),Object(i.b)("h4",{id:"accessing-the-relay-environment"},"Accessing the Relay Environment"),Object(i.b)("p",null,"If you want to access the ",Object(i.b)("em",{parentName:"p"},"current")," Relay Environment within a descendant of a ",Object(i.b)("inlineCode",{parentName:"p"},"RelayEnvironmentProvider")," component, you can use the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"useRelayEnvironment"))," Hook:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {useRelayEnvironment} = require('react-relay/hooks');\n\nfunction UserComponent(props: Props) {\n  const environment = useRelayEnvironment();\n\n  return (...);\n}\n\n")),Object(i.b)("h2",{id:"reusing-cached-data-for-render"},"Reusing Cached Data for Render"),Object(i.b)("p",null,"While our app is in use, Relay will accumulate and cache ",Object(i.b)("em",{parentName:"p"},"(for some time)")," the data for the multiple queries that have been fetched throughout usage of our app. Often times, we'll want to be able to reuse and immediately render this data that is locally cached instead of waiting for a network request when fulfilling a query; this is what we'll cover in this section."),Object(i.b)("p",null,"Some examples of when this might be useful are:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Navigating between tabs in an app, where each app renders a query. If a tab has already been visited, re-visiting the tab should render it instantly, without having to wait for a network request to fetch the data that we've already fetched before."),Object(i.b)("li",{parentName:"ul"},"Navigating to a post that was previously rendered on a feed. If the post has already been rendered on a feed, navigating to the post's permalink page should render the post immediately, since all of the data for the post should already be cached.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Even if rendering the post in the permalink page requires more data than rendering the post on a feed, we'd still like to reuse and immediately render as much of the post's data that we already have available locally, without blocking render for the entire post if only a small bit of data is missing.")))),Object(i.b)("h3",{id:"fetch-policies"},"Fetch Policies"),Object(i.b)("p",null,"The first step to reusing locally cached data is to specify a ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"fetchPolicy"))," for ",Object(i.b)("inlineCode",{parentName:"p"},"useLazyLoadQuery"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"\nconst React = require('React');\nconst {graphql, useLazyLoadQuery} = require('react-relay/hooks');\n\nfunction App() {\n  const data = useLazyLoadQuery<AppQuery>(\n    graphql`\n      query AppQuery($id: ID!) {\n        user(id: $id) {\n          name\n        }\n      }\n    `,\n    {id: '4'},\n    {fetchPolicy: 'store-or-network'},\n  );\n\n  return (\n    <h1>{data.user?.name}</h1>\n  );\n}\n\n")),Object(i.b)("p",null,"The provided ",Object(i.b)("inlineCode",{parentName:"p"},"fetchPolicy")," will determine:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("em",{parentName:"li"},"if")," the query should be fulfilled from the local cache, and"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("em",{parentName:"li"},"if")," a network request should be made to fetch the query from the server, depending on the ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#availability-of-cached-data"}),"availablity of the data for that query in the store"),".")),Object(i.b)("p",null,"By default, Relay will try to read the query from the local cache; if any piece of data for that query is ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#presence-of-data"}),"missing")," or ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#staleness-of-data"}),"stale"),", it will fetch the entire query from the network. This default ",Object(i.b)("inlineCode",{parentName:"p"},"fetchPolicy"),' is called "',Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},'store-or-network".'))),Object(i.b)("p",null,"Specifically, ",Object(i.b)("inlineCode",{parentName:"p"},"fetchPolicy")," can be any of the following options:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},'"store-or-network"'),": ",Object(i.b)("em",{parentName:"li"},"(default)")," ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"will"))," reuse locally cached data and will ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"only"))," send a network request if any data for the query is ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#presence-of-data"}),"missing")," or ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#staleness-of-data"}),"stale"),". If the query is fully cached, a network request will ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"not"))," be made."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},'"store-and-network"'),": ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"will"))," reuse locally cached data and will ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"always"))," send a network request, regardless of whether any data was ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#presence-of-data"}),"missing")," or ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#staleness-of-data"}),"stale")," in the store."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},'"network-only"'),": ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"will not"))," reuse locally cached data, and will ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"always"))," send a network request to fetch the query, ignoring any data that might be locally cached and whether it's ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#presence-of-data"}),"missing")," or ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#staleness-of-data"}),"stale"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},'"store-only"'),": ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"will only"))," reuse locally cached data, and will ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"never"))," send a network request to fetch the query. In this case, the responsibility of fetching the query falls to the caller, but this policy could also be used to read and operate on data that is entirely ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#local-data-updates"}),"local"),".")),Object(i.b)("p",null,"Note that the ",Object(i.b)("inlineCode",{parentName:"p"},"refetch")," function discussed in the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#fetching-and-rendering-different-data"}),"Fetching More Data and Rendering Different Data")," section  also takes a ",Object(i.b)("inlineCode",{parentName:"p"},"fetchPolicy"),"."),Object(i.b)("h3",{id:"availability-of-cached-data"},"Availability of Cached Data"),Object(i.b)("p",null,"The behavior of the fetch policies described in the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#fetch-policies"}),"previous section")," will depend on the availability of the data in the Relay store at the moment we attempt to evaluate a query."),Object(i.b)("p",null,"There are 2 main aspects that determine the availability of data, which we will go over in this section:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#presence-of-data"}),"Presence of data")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#staleness-of-data"}),"Staleness of data"))),Object(i.b)("h3",{id:"presence-of-data"},"Presence of Data"),Object(i.b)("p",null,"An important thing to keep in mind when attempting to reuse data that is cached in the Relay store is to understand the lifetime of that data; that is, if it is present in the store, and for how long it will be."),Object(i.b)("p",null,"Data in the Relay store for a given query will generally be present after the query has been fetched for the first time, as long as that query is being rendered on the screen. If we\u2019ve never fetched data for a specific query, then it will be missing from the store."),Object(i.b)("p",null,"However, even after we've fetched data for different queries, we can't keep all of the data that we've fetched indefinitely in memory, since over time it would grow to be too large and too stale. In order to mitigate this, Relay runs a process called ",Object(i.b)("em",{parentName:"p"},"Garbage Collection"),", in order to delete data that we're no longer using:"),Object(i.b)("h4",{id:"garbage-collection-in-relay"},"Garbage Collection in Relay"),Object(i.b)("p",null,"Specifically, Relay runs garbage collection on the local in-memory store by deleting any data that is no longer being referenced by any component in the app."),Object(i.b)("p",null,"However, this can be at odds with reusing cached data; if the data is deleted too soon, before we try to reuse it again later, that will prevent us from reusing that data to render a screen without having to wait on a network request. To address this, this section will cover what you need to do in order to ensure that the data you want to reuse is kept cached for as long as you need it."),Object(i.b)("h5",{id:"query-retention"},"Query Retention"),Object(i.b)("p",null,"Retaining a query indicates to Relay that the data for that query and variables shouldn't be deleted (i.e. garbage collected). Multiple callers might retain a single query, and as long as there is at least one caller retaining a query, it won't be deleted from the store."),Object(i.b)("p",null,"By default, any query components using useLazyLoadQuery or our other APIs will retain the query for as long as they are mounted. After they unmount, they will release the query, which means that the query might be deleted at any point in the future after that occurs."),Object(i.b)("p",null,"If you need to retain a specific query outside of the components lifecycle, you can use the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#retaining-queries"}),Object(i.b)("strong",{parentName:"a"},Object(i.b)("inlineCode",{parentName:"strong"},"retain")))," operation:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n// Retain query; this will prevent the data for this query and\n// variables from being garbage collected by Relay\nconst disposable = environment.retain(queryDescriptor);\n\n// Disposing of the disposable will release the data for this query\n// and variables, meaning that it can be deleted at any moment\n// by Relay's garbage collection if it hasn't been retained elsewhere\ndisposable.dispose();\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"As mentioned, this will allow you to retain the query even after a query component has unmounted, allowing other components, or future instances of the same component, to reuse the retained data.")),Object(i.b)("h5",{id:"controlling-relays-garbage-collection-policy"},"Controlling Relay's Garbage Collection Policy"),Object(i.b)("p",null,"There are currently 2 options you can provide to your Relay Store in to control the behavior of garbage collection:"),Object(i.b)("h6",{id:"gc-scheduler"},"GC Scheduler"),Object(i.b)("p",null,"The ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"gcScheduler"))," is a function you can provide to the Relay Store which will determine when a GC execution should be scheduled to run:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n// Sample scheduler function\n// Accepts a callback and schedules it to run at some future time.\nfunction gcScheduler(run: () => void) {\n  resolveImmediate(run);\n}\n\nconst store = new Store(source, {gcScheduler});\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"By default, if a ",Object(i.b)("inlineCode",{parentName:"li"},"gcScheduler")," option is not provided, Relay will schedule garbage collection using the ",Object(i.b)("inlineCode",{parentName:"li"},"resolveImmediate")," function."),Object(i.b)("li",{parentName:"ul"},"You can provide a scheduler function to make GC scheduling less aggressive than the default, for example based on time or ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/facebook/react/tree/master/packages/scheduler"}),"scheduler")," priorities, or any other heuristic. By convention, implementations should not execute the callback immediately.")),Object(i.b)("h6",{id:"gc-release-buffer-size"},"GC Release Buffer Size"),Object(i.b)("p",null,"The Relay Store internally holds a release buffer to keep a specific (configurable) number of queries temporarily retained even after they have been released by their original owner  (i.e., usually when a component rendering that query unmounts). This makes it possible (and more likely) to reuse data when navigating back to a page, tab or piece of content that has been visited before."),Object(i.b)("p",null,"In order to configure the size of the release buffer, you can provide a ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"gcReleaseBufferSize"))," option to the Relay Store:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst store = new Store(source, {gcReleaseBufferSize: 10});\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Note that having a buffer size of 0 is equivalent to not having the release buffer, which means that queries will be immediately released and collected.")),Object(i.b)("h3",{id:"staleness-of-data"},"Staleness of Data"),Object(i.b)("p",null,"Assuming our data is ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#presence-of-data"}),"present in the store"),", we still need to consider the staleness of such data."),Object(i.b)("p",null,"By default, Relay will never consider data in the store to be stale (regardless of how long it has been cached for), unless it\u2019s explicitly marked as stale using our data invalidation apis."),Object(i.b)("p",null,"Marking data as stale is useful for cases when we explicitly know that some data is no longer fresh (for example after executing a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#graphql-mutations"}),"Mutation"),"), and we want to make sure it get\u2019s refetched with the latest value from the server. Specifically, when data has been marked as stale, if any query references the stale data, that means the query will also be considered stale, and it will need to be fetched again the next time it is evaluated, given the provided ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#fetch-policies"}),"Fetch Policy"),"."),Object(i.b)("p",null,"Relay exposes the following APIs to mark data as stale within an update to the store:"),Object(i.b)("h4",{id:"globally-invalidating-the-relay-store"},"Globally Invalidating the Relay Store"),Object(i.b)("p",null,"The coarsest type of data invalidation we can perform is invalidating the whole store, meaning that all currently cached data will be considered stale after invalidation."),Object(i.b)("p",null,"To invalidate the store, we can call ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"invalidateStore()"))," within an ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#updater-functions"}),"updater")," function:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nfunction updater(store) {\n  store.invalidateStore();\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Calling ",Object(i.b)("inlineCode",{parentName:"li"},"invalidateStore()")," will cause ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"all"))," data that was written to the store before invalidation occurred to be considered stale, and will require any query to be refetched again the next time it\u2019s evaluated."),Object(i.b)("li",{parentName:"ul"},"Note that an updater function can be specified as part of a ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#graphql-mutations"}),"mutation"),", ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#graphql-subscriptions"}),"subscription")," or just a ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#local-data-updates"}),"local store update"),".")),Object(i.b)("h4",{id:"invalidating-specific-data-in-the-store"},"Invalidating Specific Data in the Store"),Object(i.b)("p",null,"We can also be more granular about which data we invalidate and only invalidate ",Object(i.b)("em",{parentName:"p"},"specific records")," in the store; compared to global invalidation, only queries that reference the invalidated records will be considered stale after invalidation."),Object(i.b)("p",null,"To invalidate a record, we can call ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"invalidateRecord()"))," within an ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#updater-functions"}),"updater")," function:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nfunction updater(store) {\n  const user = store.get('<id>');\n  if (user != null) {\n    user.invalidateRecord();\n  }\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Calling ",Object(i.b)("inlineCode",{parentName:"li"},"invalidateRecord()")," on the user record will mark ",Object(i.b)("em",{parentName:"li"},"that")," specific user in the store as stale. That means that any query that is cached and references that invalidated user will now be considered stale, and will require to be refetched again the next time it\u2019s evaluated."),Object(i.b)("li",{parentName:"ul"},"Note that an updater function can be specified as part of a ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#graphql-mutations"}),"mutation"),", ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#graphql-subscriptions"}),"subscription")," or just a ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#local-data-updates"}),"local store update"),".")),Object(i.b)("h4",{id:"subscribing-to-data-invalidation"},"Subscribing to Data Invalidation"),Object(i.b)("p",null,"Just marking the store or records as stale will cause queries to be refetched the next time they are evaluated; so for example, the next time you navigate back to a page that renders a stale query, the query will be refetched even if the data is cached, since the query references stale data."),Object(i.b)("p",null,"This is useful for a lot of use cases, but there are some times when we\u2019d like to immediately refetch some data upon invalidation, for example:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"When invalidating data that is already visible in the current page. Since no navigation is occurring, we won\u2019t re-revaluate the queries for the current page, so even if some data is stale, it won't be immediately refetched and we will be showing stale data."),Object(i.b)("li",{parentName:"ul"},"When invalidating data that is rendered on a previous view that was never unmounted; since the view wasn't unmounted, if we navigate back, the queries for that view wont be re-evaluated, meaning that even if some is stale, it won't be refetched and we will be showing stale data.")),Object(i.b)("p",null,"To support these use cases, Relay exposes the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"useSubscribeToInvalidationState"))," hook:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nfunction ProfilePage(props) {\n  // Example of querying data for the current page for a given user\n  const data = usePreloadedQuery(\n    graphql`...`,\n    props.preloadedQuery,\n  )\n\n  // Here we subscribe to changes in invalidation state for the given user ID.\n  // Whenever the user whith that ID is marked as stale, the provided callback will\n  // be executed*\n  useSubscribeToInvalidationState([props.userID], () => {\n    // Here we can do things like:\n    // - re-evaluate the query by passing a new preloadedQuery to usePreloadedQuery.\n    // - imperatively refetch any data\n    // - render a loading spinner or gray out the page to indicate that refetch\n    //   is happening.\n  })\n\n  return (...);\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"useSubscribeToInvalidationState")," takes an array of ids, and a callback. Whenever any of the records for those ids are marked as stale, the provided callback will fire."),Object(i.b)("li",{parentName:"ul"},"Inside the callback, we can react accordingly and refetch and/or update any current views that are rendering stale data. As an example, we could re-execute the top-level ",Object(i.b)("inlineCode",{parentName:"li"},"usePreloadedQuery")," by keeping the ",Object(i.b)("inlineCode",{parentName:"li"},"preloadedQuery")," in state and setting a new one here; since that query is stale at that point, the query will be refetched even if the data is cached in the store.")),Object(i.b)("h3",{id:"rendering-partially-cached-data-highly-experimental"},"Rendering Partially Cached Data ","[HIGHLY EXPERIMENTAL]"),Object(i.b)("blockquote",null,Object(i.b)("strong",null,"NOTE:")," Partial rendering behavior is still highly experimental and likely to change, and only enabled under an experimental option. If you still wish to use it, you can enable it by passing ",Object(i.b)("pre",null,"{","'","{",'UNSTABLE_renderPolicy: "partial"',"}","'","}")," as an option to ",Object(i.b)("pre",null,"useLazyLoadQuery"),"."),Object(i.b)("p",null,"Often times when dealing with cached data, we'd like the ability to perform partial rendering. We define ",Object(i.b)("em",{parentName:"p"},'"partial rendering"')," as the ability to immediately render a query that is partially cached. That is, parts of the query might be missing, but parts of the query might already be cached. In these cases, we want to be able to immediately render the parts of the query that are cached, without waiting on the full query to be fetched."),Object(i.b)("p",null,"This can be useful in scenarios where we want to render a screen or a page as fast as possible, and we know that some of the data for that page is already cached, so we can skip a loading state. For example, imagine a user profile page: it is very likely that the user's name has already been cached at some point during usage of the app, so when visiting a profile page, if the name of the user is cached, we'd like to render immediately, even if the rest of the data for the profile page isn't available yet."),Object(i.b)("h4",{id:"fragments-as-boundaries-for-partial-rendering"},"Fragments as boundaries for partial rendering"),Object(i.b)("p",null,"To do this, we rely on the ability of fragment containers to ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#loading-states-with-suspense"}),Object(i.b)("em",{parentName:"a"},"suspend")),". ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"A fragment container will suspend if any of the data it declared locally is missing during render, and is currently being fetched."))," Specifically, it will suspend until the data it requires is fetched, that is, until the query it belongs to (its ",Object(i.b)("em",{parentName:"p"},"parent query"),") is fetched."),Object(i.b)("p",null,"Let's explain what this means with an example. Say we have the following fragment component:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * UsernameComponent.react.js\n *\n * Fragment Component\n */\n\nimport type {UsernameComponent_user$key} from 'UsernameComponent_user.graphql';\n\nconst React = require('React');\nconst {graphql, useFragment} = require('react-relay/hooks');\n\ntype Props = {|\n  user: UsernameComponent_user$key,\n|};\n\nfunction UsernameComponent(props: Props) {\n  const user = useFragment(\n    graphql`\n      fragment UsernameComponent_user on User {\n        username\n      }\n    `,\n    props.user,\n  );\n  return (...);\n}\n\nmodule.exports = UsernameComponent;\n\n")),Object(i.b)("p",null,"And we have the following query component, which queries for some data, and also includes the fragment above:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * App.react.js\n *\n * Query Component\n */\n\nconst React = require('React');\nconst {graphql, useLazyLoadQuery} = require('react-relay/hooks');\n\nconst UsernameComponent = require('./UsernameComponent.react');\n\nfunction App() {\n  const data = useLazyLoadQuery<AppQuery>(\n    graphql`\n      query AppQuery($id: ID!) {\n        user(id: $id) {\n          name\n          ...UsernameComponent_user\n        }\n      }\n    `,\n    {id: '4'},\n    {fetchPolicy: 'store-or-network'},\n  );\n\n  return (\n    <>\n      <h1>{data.user?.name}</h1>\n      <UsernameComponent user={data.user} />\n    </>\n  );\n}\n\n")),Object(i.b)("p",null,"Say that when this ",Object(i.b)("inlineCode",{parentName:"p"},"App")," component is rendered, we've already previously fetched ",Object(i.b)("em",{parentName:"p"},"(_only"),")_ the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"name"))," for the ",Object(i.b)("inlineCode",{parentName:"p"},"User")," with ",Object(i.b)("inlineCode",{parentName:"p"},"{id: 4}"),", and it is locally cached in the Relay Store."),Object(i.b)("p",null,"If we attempt to render the query with a ",Object(i.b)("inlineCode",{parentName:"p"},"fetchPolicy")," that allows reusing locally cached data (",Object(i.b)("inlineCode",{parentName:"p"},"'store-or-network'"),", or ",Object(i.b)("inlineCode",{parentName:"p"},"'store-and-network'"),"), the following will occur:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The query will check if any of its locally required data is missing. In this case, ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"it isn't")),". Specifically, the query is only directly querying for the ",Object(i.b)("inlineCode",{parentName:"li"},"name"),", and the name ",Object(i.b)("em",{parentName:"li"},"is")," available, so as far as the query is concerned, none of the data it requires to render ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"itself"))," is missing. This is important to keep in mind: when rendering a query, we eagerly read out data and render the tree, instead of blocking rendering of the entire tree until ",Object(i.b)("em",{parentName:"li"},"all")," of the data for the query (i.e. including nested fragments) is fetched. As we render, ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"we will consider data to be missing for a component if the data it declared locally is missing, i.e. if any data required to render the current component is missing, and _not")," if data for descendant components is missing._")),Object(i.b)("li",{parentName:"ul"},"Given that the query doesn't have any data missing, it will render, and then attempt to render the child ",Object(i.b)("inlineCode",{parentName:"li"},"UsernameComponent"),"."),Object(i.b)("li",{parentName:"ul"},"When the ",Object(i.b)("inlineCode",{parentName:"li"},"UsernameComponent")," attempts to render the ",Object(i.b)("inlineCode",{parentName:"li"},"UsernameComponent_user")," fragment, it will notice that some of the data required to render itself is missing; specifically, the ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"username"))," is missing. At this point, since ",Object(i.b)("inlineCode",{parentName:"li"},"UsernameComponent")," has missing data, it will suspend rendering until the network request completes. Note that regardless of which ",Object(i.b)("inlineCode",{parentName:"li"},"fetchPolicy")," you choose, a network request will always be started if any piece of data for the full query, i.e. including fragments, is missing.")),Object(i.b)("p",null,"At this point, when ",Object(i.b)("inlineCode",{parentName:"p"},"UsernameComponent")," suspends due to the missing ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"username")),", ideally we should still be able to render the ",Object(i.b)("inlineCode",{parentName:"p"},"User"),"'s ",Object(i.b)("inlineCode",{parentName:"p"},"**name**")," immediately, since it's locally cached. However, since we aren't using a ",Object(i.b)("inlineCode",{parentName:"p"},"Suspense")," component to catch the fragment's suspension, the suspension will bubble up and the entire ",Object(i.b)("inlineCode",{parentName:"p"},"App")," component will be suspended."),Object(i.b)("p",null,"In order to achieve the desired effect of rendering the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"name"))," when it's available even if the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"username")),"  is missing, we just need to wrap the ",Object(i.b)("inlineCode",{parentName:"p"},"UsernameComponent")," in ",Object(i.b)("inlineCode",{parentName:"p"},"Suspense,")," to ",Object(i.b)("em",{parentName:"p"},"allow")," the other parts of ",Object(i.b)("inlineCode",{parentName:"p"},"App")," to continue rendering:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * App.react.js\n *\n * Query Component\n */\n\nconst React = require('React');\nconst {Suspense} = require('React');\nconst {graphql, useLazyLoadQuery} = require('react-relay/hooks');\n\nconst UsernameComponent = require('./UsernameComponent.react');\n\nfunction App() {\n  const data = useLazyLoadQuery<AppQuery>(\n    graphql`\n      query AppQuery($id: ID!) {\n        user(id: $id) {\n          name\n          ...UsernameComponent_user\n        }\n      }\n    `,\n    {id: '4'},\n    {fetchPolicy: 'store-or-network'},\n  );\n\n  return (\n    <>\n      <h1>{data.user?.name}</h1>\n\n      <Suspense\n        // Wrap the UserComponent in Suspense to allow other parts of the\n        // App to be rendered even if the username is missing.\n        fallback={<LoadingSpinner label=\"Fetching username\" />}\n      >\n        <UsernameComponent user={data.user} />\n      </Suspense>\n    </>\n  );\n}\n\n")),Object(i.b)("hr",null),Object(i.b)("p",null,"The process that we described above works the same way for nested fragments (i.e. fragments that include other fragments). This means that if the data required to render a fragment is locally cached, the fragment component will be able to render, regardless of whether data for any of its child or descendant fragments is missing. If data for a child fragment is missing, we can wrap it in a ",Object(i.b)("inlineCode",{parentName:"p"},"Suspense")," component to allow other fragments and parts of the app to continue rendering."),Object(i.b)("h3",{id:"filling-in-missing-data-missing-data-handlers"},"Filling in Missing Data (Missing Data Handlers)"),Object(i.b)("p",null,"In the previous section we covered how to reuse data that is fully or partially cached, however there are cases in which Relay can't automatically tell that it can reuse some of its local data to fulfill a query. Specifically, Relay knows how to reuse data that is cached for the ",Object(i.b)("em",{parentName:"p"},"same")," query; that is, if you fetch the exact same query twice, Relay will know that it has the data cached for that query the second time."),Object(i.b)("p",null,"However, when using different queries, there might still be cases where different queries point to the same data, which we'd want to be able to reuse. For example, imagine the following two queries:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"\n// Query 1\nquery UserQuery {\n  user(id: 4) {\n    name\n  }\n}\n\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"\n// Query 2\nquery NodeQuery {\n  node(id: 4) {\n    ... on User {\n      name\n    }\n  }\n}\n\n")),Object(i.b)("p",null,"These two queries are different, but reference the exact same data. Ideally, if one of the queries was already cached in the store, we should be able to reuse that data when rendering the other query. However, Relay doesn't have this knowledge by default, so we need to configure it to encode the knowledge that a ",Object(i.b)("inlineCode",{parentName:"p"},"node(id: 4)")," ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},'"is also a"'))," ",Object(i.b)("inlineCode",{parentName:"p"},"user(id: 4)"),"."),Object(i.b)("p",null,"To do so, we can provide ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"missingFieldHandlers"))," to the ",Object(i.b)("inlineCode",{parentName:"p"},"RelayEnvironment"),", which specify this knowledge:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {ROOT_TYPE, Environment} = require('react-relay');\n\nconst missingFieldHandlers = [\n  {\n    handle(field, record, argValues): ?string {\n      if (\n        record != null &&\n        record.__typename === ROOT_TYPE &&\n        field.name === 'user' &&\n        argValues.hasOwnProperty('id')\n      ) {\n        // If field is user(id: $id), look up the record by the value of $id\n        return argValues.id;\n      }\n      if (\n        record != null &&\n        record.__typename === ROOT_TYPE &&\n        field.name === 'story' &&\n        argValues.hasOwnProperty('story_id')\n      ) {\n        // If field is story(story_id: $story_id), look up the record by the\n        // value of $story_id.\n        return argValues.story_id;\n      }\n      return null;\n    },\n    kind: 'linked',\n  },\n];\n\nconst environment = new Environment({\n  // and other fields\n  missingFieldHandlers,\n});\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"missingFieldHandlers")," is an array of ",Object(i.b)("em",{parentName:"li"},"handlers"),". Each handler must specify a ",Object(i.b)("inlineCode",{parentName:"li"},"handle")," function, and the kind of missing fields it knows how to handle. The 2 main types of fields that you'd want to handle are:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"'scalar'")),": This represents a field that contains a scalar value, for example a number or a string."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"'linked'")),": This represents a field that references another object, i.e. not a scalar."))),Object(i.b)("li",{parentName:"ul"},"The ",Object(i.b)("inlineCode",{parentName:"li"},"handle")," function takes the field that is missing, the record that field belongs to, and any arguments that were passed to the field in the current execution of the query.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"When handling a ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"'scalar'"))," field, the handle function should return a scalar value, in order to use as the value for a missing field"),Object(i.b)("li",{parentName:"ul"},"When handling a ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"'linked'"))," field, the handle function should return an ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"ID")),", referencing another object in the store that should be use in place of the missing field."))),Object(i.b)("li",{parentName:"ul"},"As Relay attempts to fulfill a query from the local cache, whenever it detects any missing data, it will run any of the provided missing field handlers that match the field type before definitively declaring that the data is missing.")),Object(i.b)("h2",{id:"fetching-rendering-different-data"},"Fetching Rendering ",Object(i.b)("em",{parentName:"h2"},"Different")," Data"),Object(i.b)("p",null,"After an app has been initially rendered, there are various scenarios in which you might want to fetch and render more data, re-render your UI with ",Object(i.b)("em",{parentName:"p"},"different")," data, or maybe refresh existing data, usually as a result of an event or user interaction."),Object(i.b)("p",null,"In this section we'll cover some of the most common scenarios and how to build them with Relay."),Object(i.b)("h3",{id:"refreshing-rendered-data"},"Refreshing Rendered Data"),Object(i.b)("p",null,"Assuming you're not using real-time updates to update your data (e.g. using ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#graphql-subscriptions"}),"GraphQL Subscriptions"),"), often times you'll want to refetch the same data you've already rendered, in order to get the latest version available on the server. This is what we'll cover in this section."),Object(i.b)("h4",{id:"refreshing-queries"},"Refreshing Queries"),Object(i.b)("p",null,"To refresh a query, you can use the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"fetchQuery"))," function described in our ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#fetching-queries"}),"Fetching Queries")," section. Specifically, you can call ",Object(i.b)("inlineCode",{parentName:"p"},"fetchQuery")," inside the component with the exact same query and variables. Given that the query component is subscribed to any changes in its own data, when the request completes, the component will automatically update and re-render with the latest data:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {AppQuery} from 'AppQuery.graphql';\n\nconst React = require('React');\nconst {graphql, useLazyLoadQuery, useRelayEnvironment, fetchQuery} = require('react-relay/hooks');\n\nfunction App() {\n  const environment = useRelayEnvironment();\n  const variables = {id: '4'};\n  const appQuery = graphql`\n    query AppQuery($id: ID!) {\n      user(id: $id) {\n        name\n        friends {\n          count\n        }\n      }\n    }\n  `;\n\n  const refresh = () => {\n    fetchQuery(\n      environment,\n      appQuery,\n      variables,\n    )\n    .toPromise();\n  };\n\n  const data = useLazyLoadQuery<AppQuery>(appQuery, variables);\n\n  return (\n    <>\n      <h1>{data.user?.name}</h1>\n      <div>Friends count: {data.user.friends?.count}</div>\n      <Button onClick={() => refresh()}>Fetch latest count</Button>\n    </>\n  );\n}\n\n")),Object(i.b)("p",null,"If you want to know whether the request is in flight, in order to show a busy indicator or disable a UI control, you can subscribe to the observable returned by ",Object(i.b)("inlineCode",{parentName:"p"},"fetchQuery"),", and keep state in your component:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {AppQuery} from 'AppQuery.graphql';\n\nconst React = require('React');\nconst {useState} = require('React');\nconst {graphql, useLazyLoadQuery, useRelayEnvironment, fetchQuery} = require('react-relay/hooks');\n\nfunction App() {\n  const environment = useRelayEnvironment();\n  const variables = {id: '4'};\n  const appQuery = graphql`\n    query AppQuery($id: ID!) {\n      user(id: $id) {\n        name\n        friends {\n          count\n        }\n      }\n    }\n  `;\n  const [isRefreshing, setIsRefreshing] = useState(false);\n\n  const refresh = () => {\n    fetchQuery(\n      environment,\n      appQuery,\n      variables,\n    )\n    .subscribe({\n      start: () => setIsRefreshing(true),\n      complete: () => setIsRefreshing(false),\n    });\n  };\n\n  const data = useLazyLoadQuery<AppQuery>(appQuery, variables);\n\n  return (\n    <>\n      <h1>{data.user?.name}</h1>\n      <div>Friends count: {data.user.friends?.count}</div>\n      <Button\n        disabled={isRefreshing}\n        onClick={() => refetch()}>\n        Fetch latest count {isRefreshing ? <LoadingSpinner /> : null}\n      </Button>\n    </>\n  );\n}\n\n")),Object(i.b)("h4",{id:"refreshing-fragments"},"Refreshing Fragments"),Object(i.b)("p",null,"In order to refresh the data for a fragment, we can also use ",Object(i.b)("inlineCode",{parentName:"p"},"fetchQuery"),", but we need to provide a query to refetch the fragment under; remember, ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"fragments can't be fetched by themselves: they need to be part of a query,")),' so we can\'t just "fetch" the fragment again by itself.'),Object(i.b)("p",null,"However, we don't need to manually write the query; instead, we can use the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"@refetchable"))," directive, which will make it so Relay automatically generates a query to fetch the fragment when the compiler is run:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {UserComponent_user$key} from 'UserComponent_user.graphql';\n\nconst React = require('React');\nconst {graphql, useFragment, useRelayEnvironment} = require('react-relay/hooks');\n\n// This query is autogenerated by Relay given @refetchable used below\nconst UserComponentUserRefreshQuery = require('UserComponentUserRefreshQuery.graphql');\n\ntype Props = {|\n  user: UserComponent_user$key,\n|};\n\nfunction UserComponent(props: Props) {\n  const environment = useRelayEnvironment();\n  const data = useFragment(\n     graphql`\n      fragment UserComponent_user on User\n        # @refetchable makes it so Relay autogenerates a query for\n        # fetching this fragment\n        @refetchable(queryName: \"UserComponentUserRefreshQuery\") {\n        id\n        name\n        friends {\n          count\n        }\n      }\n    `,\n    props.user,\n  );\n\n  const refresh = () => {\n    fetchQuery(\n      environment,\n      UserComponentUserRefreshQuery,\n      {id: data.id},\n    )\n    .toPromise();\n  };\n\n  return (\n    <>\n      <h1>{data.name}</h1>\n      <div>Friends count: {data.friends?.count}</div>\n      <Button onClick={() => refresh()}>Fetch latest count</Button>\n    </>\n  );\n}\n\nmodule.exports = UserComponent;\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Relay will autogenerate a query by adding the ",Object(i.b)("inlineCode",{parentName:"li"},"@refetchable")," directive to our fragment, and we can import it and pass it to ",Object(i.b)("inlineCode",{parentName:"li"},"fetchQuery"),". Note that ",Object(i.b)("inlineCode",{parentName:"li"},"@refetchable"),' directive can only be added to fragments that are "refetchable", that is, on fragments that are on ',Object(i.b)("inlineCode",{parentName:"li"},"Viewer"),", or on ",Object(i.b)("inlineCode",{parentName:"li"},"Query"),", or on a type that implements ",Object(i.b)("inlineCode",{parentName:"li"},"Node")," (i.e. a type that has an ",Object(i.b)("inlineCode",{parentName:"li"},"id")," field)."),Object(i.b)("li",{parentName:"ul"},"In order to fetch the query, we need to know the ",Object(i.b)("inlineCode",{parentName:"li"},"id")," of the user since it will be a required query variable in the generated query. To do so, we simply include the ",Object(i.b)("inlineCode",{parentName:"li"},"id")," in our fragment."),Object(i.b)("li",{parentName:"ul"},"Given that the fragment container component is subscribed to any changes in its own data, when the request completes, the component will automatically update and re-render with the latest data:"),Object(i.b)("li",{parentName:"ul"},"If you want to know whether the request is in flight, in order to show a busy indicator or disable a UI control, you can use provide an ",Object(i.b)("inlineCode",{parentName:"li"},"observer")," to ",Object(i.b)("inlineCode",{parentName:"li"},"fetchQuery"),", and keep state in your component.")),Object(i.b)("h3",{id:"re-rendering-with-different-data"},"Re-rendering with Different Data"),Object(i.b)("p",null,"Often times you'll want to re-render your existing query or fragment components, but using ",Object(i.b)("em",{parentName:"p"},"different")," data than the one they were originally rendered with. This usually means fetching your existing queries or fragments with ",Object(i.b)("em",{parentName:"p"},"different variables"),"."),Object(i.b)("p",null,"Some examples of when you might want to do this:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"You've rendered a comment, and after user interaction want to fetch and re-render the comment body with the text translated to a different language."),Object(i.b)("li",{parentName:"ul"},"You've rendered a profile picture, and you want to fetch and re-render it with a different size or scale."),Object(i.b)("li",{parentName:"ul"},"You've rendered a list of search results, and you want to fetch and re-render the list with a new search term upon user input.")),Object(i.b)("h4",{id:"re-rendering-queries-with-different-data"},"Re-rendering queries with different data"),Object(i.b)("p",null,"As mentioned in the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#queries"}),"Queries")," section, passing ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"different query variables"))," than the ones originally passed when using ",Object(i.b)("inlineCode",{parentName:"p"},"useLazyLoadQuery")," will cause the query to be fetched with the new variables, and re-render your component with the new data:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {AppQuery} from 'AppQuery.graphql';\n\nconst React = require('React');\nconst {useState, useTransition} = require('React');\nconst {graphql, useLazyLoadQuery} = require('react-relay/hooks');\n\nfunction App() {\n  const [startTransition] = useTransition();\n  const [variables, setVariables] = useState({id: '4'});\n\n  const data = useLazyLoadQuery<AppQuery>(\n    graphql`\n      query AppQuery($id: ID!) {\n        user(id: $id) {\n          name\n        }\n      }\n    `,\n    variables,\n  );\n\n  return (\n    <>\n      <h1>\n        {data.user?.name}\n        <Button\n          onClick={() => {\n            startTransition(() => {\n              setVariables({id: 'different-id'});\n            });\n          }}>\n          Fetch different User\n        </Button>\n      </h1>\n    </>\n  );\n}\n\n")),Object(i.b)("p",null,"Let's distill what's going on here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Calling ",Object(i.b)("inlineCode",{parentName:"li"},"setVariables")," and passing a new set of variables will re-render the component and cause the query to be fetched again ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"with the newly provided variables")),". In this case, we will fetch the ",Object(i.b)("inlineCode",{parentName:"li"},"User")," with id ",Object(i.b)("inlineCode",{parentName:"li"},"'different-id'"),", and render the results when they're available."),Object(i.b)("li",{parentName:"ul"},"This will re-render your component and may cause it to suspend (as explained in (",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#transitions-and-updates-that-suspend"}),"Transitions And Updates That Suspend"),") if it needs to send and wait for a network request. If ",Object(i.b)("inlineCode",{parentName:"li"},"setVariables")," causes the component to suspend, you'll need to make sure that there's a ",Object(i.b)("inlineCode",{parentName:"li"},"Suspense")," boundary wrapping this component from above, and/or that you are using ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://reactjs.org/docs/concurrent-mode-patterns.html#transitions"}),Object(i.b)("inlineCode",{parentName:"a"},"useTransition"))," with a Suspense config in order to show the appropriate pending or loading state.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Note that since ",Object(i.b)("inlineCode",{parentName:"li"},"setVariables")," may cause the component to suspend, regardless of whether we're using a Suspense config to render a pending state, we should always use ",Object(i.b)("inlineCode",{parentName:"li"},"startTransition")," to schedule that update; any update that may cause a component to suspend should be scheduled using this pattern.")))),Object(i.b)("p",null,"You can also provide a different ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"fetchPolicy"))," when refetching the query in order to specify whether to use locally cached data (as we covered in ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#reusing-cached-data-for-render"}),"Reusing Cached Data for Render"),"):"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {AppQuery} from 'AppQuery.graphql';\n\nconst React = require('React');\nconst {useState, useTransition} = require('React');\nconst {graphql, useLazyLoadQuery} = require('react-relay/hooks');\n\nfunction App() {\n  const [startTransition] = useTransition();\n  const [state, setState] = useState({\n    fetchPolicy: 'store-or-network',\n    variables: {id: '4'},\n  });\n\n  const data = useLazyLoadQuery<AppQuery>(\n    graphql`\n      query AppQuery($id: ID!) {\n        user(id: $id) {\n          name\n        }\n      }\n    `,\n    variables,\n    {fetchPolicy},\n  );\n\n  return (\n    <>\n      <h1>\n        {data.user?.name}\n        <Button\n          onClick={() => {\n            startTransition(() => {\n              setState({\n                fetchPolicy: 'network-only',\n                variables: {id: 'different-id'},\n              });\n            });\n          }}>\n          Fetch different User\n        </Button>\n      </h1>\n    </>\n  );\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"In this case, we're keeping both the ",Object(i.b)("inlineCode",{parentName:"li"},"fetchPolicy")," and ",Object(i.b)("inlineCode",{parentName:"li"},"variables")," in component state in order to trigger a refetch both with different ",Object(i.b)("inlineCode",{parentName:"li"},"variables")," and a different ",Object(i.b)("inlineCode",{parentName:"li"},"fetchPolicy"),".")),Object(i.b)("h4",{id:"re-rendering-fragments-with-different-data"},"Re-rendering Fragments with Different Data"),Object(i.b)("p",null,"Sometimes, upon an event or user interaction, we'd like to render the ",Object(i.b)("em",{parentName:"p"},"same")," exact fragment that was originally rendered under the initial query, but with a different data. Conceptually, this means fetching and rendering the currently rendered fragment again, but under a new query with different variables; or in other words, ",Object(i.b)("em",{parentName:"p"},"making the rendered fragment a new query root"),". Remember that ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"fragments can't be fetched by themselves: they need to be part of a query,")),' so we can\'t just "fetch" the fragment again by itself.'),Object(i.b)("p",null,"To do so, you can use the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"useRefetchableFragment"))," hook, in order to refetch a fragment under new query and variables, using the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"refetch"))," function:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {CommentBodyRefetchQuery} from 'CommentBodyRefetchQuery.graphql';\nimport type {CommentBody_comment$key} from 'CommentBody_comment.graphql';\n\nconst React = require('React');\nconst {useTransition} = require('React')\nconst {graphql, useRefetchableFragment} = require('react-relay/hooks');\n\ntype Props = {|\n  comment: CommentBody_comment$key,\n|};\n\nfunction CommentBody(props: Props) {\n  const [startTransition] = useTransition();\n  const [data, refetch] = useRefetchableFragment<CommentBodyRefetchQuery, _>(\n    graphql`\n      fragment CommentBody_comment on Comment\n      @refetchable(queryName: \"CommentBodyRefetchQuery\") {\n        body(lang: $lang) {\n          text\n        }\n      }\n    `,\n    props.comment,\n  );\n\n  return (\n    <>\n      <p>{data.body?.text}</p>\n      <Button\n        onClick={() => {\n          startTransition(() => {\n            refetch({lang: 'SPANISH'}, {fetchPolicy: 'store-or-network'});\n          });\n        }}>\n        Translate Comment\n      </Button>\n    </>\n  );\n}\n\nmodule.exports = CommentBody;\n\n")),Object(i.b)("p",null,"Let's distill what's happening in this example:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"useRefetchableFragment")," behaves the same way as a ",Object(i.b)("inlineCode",{parentName:"li"},"useFragment")," (",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#fragments"}),"Fragments"),"), but with a few additions:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"It expects a fragment that is annotated with the ",Object(i.b)("inlineCode",{parentName:"li"},"@refetchable")," directive. Note that  ",Object(i.b)("inlineCode",{parentName:"li"},"@refetchable"),' directive can only be added to fragments that are "refetchable", that is, on fragments that are on ',Object(i.b)("inlineCode",{parentName:"li"},"Viewer"),", or on ",Object(i.b)("inlineCode",{parentName:"li"},"Query"),", or on a type that implements ",Object(i.b)("inlineCode",{parentName:"li"},"Node")," (i.e. a type that has an ",Object(i.b)("inlineCode",{parentName:"li"},"id")," field)."),Object(i.b)("li",{parentName:"ul"},"It returns a ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"refetch"))," function, which is already Flow typed to expect the query variables that the generated query expects"),Object(i.b)("li",{parentName:"ul"},"It takes to Flow type parameters: the type of the generated query (in our case  ",Object(i.b)("inlineCode",{parentName:"li"},"CommentBodyRefetchQuery"),"), and a second type which can always be inferred, so you only need to pass underscore (",Object(i.b)("inlineCode",{parentName:"li"},"_"),")."))),Object(i.b)("li",{parentName:"ul"},"Calling ",Object(i.b)("inlineCode",{parentName:"li"},"refetch")," and passing a new set of variables will fetch the fragment again ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"with the newly provided variables")),". The variables you need to provide are a subset of the variables that the generated query expects; the generated query will require an ",Object(i.b)("inlineCode",{parentName:"li"},"id"),", if the type of the fragment has an ",Object(i.b)("inlineCode",{parentName:"li"},"id")," field, and any other variables that are transitively referenced in your fragment.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"In this case we're passing the current comment ",Object(i.b)("inlineCode",{parentName:"li"},"id")," and a new value for the ",Object(i.b)("inlineCode",{parentName:"li"},"translationType")," variable to fetch the translated comment body."))),Object(i.b)("li",{parentName:"ul"},"This will re-render your component and may cause it to suspend (as explained in ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#transitions-and-updates-that-suspend"}),"Transitions And Updates That Suspend"),") if it needs to send and wait for a network request. If ",Object(i.b)("inlineCode",{parentName:"li"},"refetch")," causes the component to suspend, you'll need to make sure that there's a ",Object(i.b)("inlineCode",{parentName:"li"},"Suspense")," boundary wrapping this component from above, and/or that you are using ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://reactjs.org/docs/concurrent-mode-patterns.html#transitions"}),Object(i.b)("inlineCode",{parentName:"a"},"useTransition"))," with a Suspense config in order to show the appropriate pending state.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Note that since ",Object(i.b)("inlineCode",{parentName:"li"},"refetch")," may cause the component to suspend, regardless of whether we're using a Suspense config to render a pending state, we should always use ",Object(i.b)("inlineCode",{parentName:"li"},"startTransition")," to schedule that update; any update that may cause a component to suspend should be scheduled using this pattern.")))),Object(i.b)("h2",{id:"rendering-list-data-and-pagination"},"Rendering List Data and Pagination"),Object(i.b)("p",null,"There are several scenarios in which we'll want to query a list of data from the GraphQL server. Often times we won't want to query the ",Object(i.b)("em",{parentName:"p"},"entire")," set of data up front, but rather discrete sub-parts of the list, incrementally, usually in response to user input or other events. Querying a list of data in discrete parts is usually known as ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://graphql.github.io/learn/pagination/"}),"Pagination"),"."),Object(i.b)("h3",{id:"connections"},"Connections"),Object(i.b)("p",null,"Specifically in Relay, we do this via GraphQL fields known as ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://graphql.github.io/learn/pagination/#complete-connection-model"}),"Connections"),'. Connections are GraphQL fields that take a set of arguments to specify which "slice" of the list to query, and include in their response both the "slice" of the list that was requested, as well as information to indicate if there is more data available in the list and how to query it; this additional information can be used in order to perform pagination by querying for more "slices" or pages on the list.'),Object(i.b)("p",null,"More specifically, we perform ",Object(i.b)("em",{parentName:"p"},"cursor-based pagination,"),' in which the input used to query for "slices" of the list is a ',Object(i.b)("inlineCode",{parentName:"p"},"cursor")," and a ",Object(i.b)("inlineCode",{parentName:"p"},"count"),". Cursors are essentially opaque tokens that serve as markers or pointers to a position in the list. If you're curious to learn more about the details of cursor-based pagination and connections, check out ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://relay.dev/graphql/connections.htm"}),"this spec"),"."),Object(i.b)("h3",{id:"rendering-connections"},"Rendering Connections"),Object(i.b)("p",null,"In Relay, in order to perform pagination, first you need to declare a fragment that queries for a connection:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {graphql} = require('react-relay');\n\nconst userFragment = graphql`\n  fragment UserFragment on User {\n    name\n    friends(after: $cursor, first: $count)\n      @connection(key: \"UserFragment_friends\") {\n      edges {\n        node {\n          ...FriendComponent\n        }\n      }\n    }\n  }\n`;\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"In the example above, we're querying for the ",Object(i.b)("inlineCode",{parentName:"li"},"friends")," field, which is a connection; in other words, it adheres to the connection spec. Specifically, we can query the ",Object(i.b)("inlineCode",{parentName:"li"},"edges")," and ",Object(i.b)("inlineCode",{parentName:"li"},"node"),"s in the connection; the ",Object(i.b)("inlineCode",{parentName:"li"},"edges")," usually contain information about the relationship between the entities, while the ",Object(i.b)("inlineCode",{parentName:"li"},"node"),"s are the actual entities at the other end of the relationship; in this case, the ",Object(i.b)("inlineCode",{parentName:"li"},"node"),"s are objects of type ",Object(i.b)("inlineCode",{parentName:"li"},"User")," representing the user's friends."),Object(i.b)("li",{parentName:"ul"},"In order to indicate to Relay that we want to perform pagination over this connection, we need to mark the field with the ",Object(i.b)("inlineCode",{parentName:"li"},"@connection")," directive. We must also provide a ",Object(i.b)("em",{parentName:"li"},"static")," unique identifier for this connection, known as the ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"key")),". We recommend the following naming convention for the connection key: ",Object(i.b)("inlineCode",{parentName:"li"},"<fragment_name>_<field_name>"),"."),Object(i.b)("li",{parentName:"ul"},"We will go into more detail later as to why it is necessary to mark the field as a ",Object(i.b)("inlineCode",{parentName:"li"},"@connection")," and give it a unique ",Object(i.b)("inlineCode",{parentName:"li"},"key")," in our ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#adding-and-removing-items-from-a-connection"}),"Adding and Removing Items From a Connection")," section.")),Object(i.b)("p",null,"In order to render this fragment which queries for a connection, we can use the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"usePaginationFragment"))," Hook:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {FriendsListPaginationQuery} from 'FriendsListPaginationQuery.graphql';\nimport type {FriendsListComponent_user$key} from 'FriendsList_user.graphql';\n\nconst React = require('React');\nconst {Suspense, SuspenseList} = require('React');\n\nconst {graphql, usePaginationFragment} = require('react-relay/hooks');\n\ntype Props = {|\n  user: FriendsListComponent_user$key,\n|};\n\nfunction FriendsListComponent(props: Props) {\n  const {data} = usePaginationFragment<FriendsListPaginationQuery, _>(\n    graphql`\n      fragment FriendsListComponent_user on User\n      @refetchable(queryName: \"FriendsListPaginationQuery\") {\n        name\n        friends(first: $count, after: $cursor)\n        @connection(key: \"FriendsList_user_friends\") {\n          edges {\n            node {\n              ...FriendComponent\n            }\n          }\n        }\n      }\n    `,\n    props.user,\n  );\n\n  return (\n    <>\n      <h1>Friends of {data.name}:</h1>\n      <SuspenseList revealOrder=\"forwards\">\n        {\n          // Extract each friend from the resulting data\n          (data.friends?.edges ?? []).map(edge => {\n            const node = edge.node;\n            return (\n              <Suspense fallback={<Glimmer />}>\n                <FriendComponent user={node} />\n              </Suspense>\n            );\n          })\n        }\n      </SuspenseList>\n    </>\n  );\n}\n\nmodule.exports = FriendsListComponent;\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"usePaginationFragment")," behaves the same way as a ",Object(i.b)("inlineCode",{parentName:"li"},"useFragment")," (",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#fragments"}),"Fragments"),"), so our list of friends is available under ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"data.friends.edges.node")),", as declared by the fragment. However, it also has a few additions:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"It expects a fragment that is a connection field annotated with the ",Object(i.b)("inlineCode",{parentName:"li"},"@connection")," directive"),Object(i.b)("li",{parentName:"ul"},"It expects a fragment that is annotated with the ",Object(i.b)("inlineCode",{parentName:"li"},"@refetchable")," directive. Note that  ",Object(i.b)("inlineCode",{parentName:"li"},"@refetchable"),' directive can only be added to fragments that are "refetchable", that is, on fragments that are on ',Object(i.b)("inlineCode",{parentName:"li"},"Viewer"),", or on ",Object(i.b)("inlineCode",{parentName:"li"},"Query"),", or on a type that implements ",Object(i.b)("inlineCode",{parentName:"li"},"Node")," (i.e. a type that has an ",Object(i.b)("inlineCode",{parentName:"li"},"id")," field)."),Object(i.b)("li",{parentName:"ul"},"It takes two Flow type parameters: the type of the generated query (in our case  ",Object(i.b)("inlineCode",{parentName:"li"},"FriendsListPaginationQuery"),"), and a second type which can always be inferred, so you only need to pass underscore (",Object(i.b)("inlineCode",{parentName:"li"},"_"),")."))),Object(i.b)("li",{parentName:"ul"},"Note that we're using ",Object(i.b)("inlineCode",{parentName:"li"},"[SuspenseList](https://reactjs.org/docs/concurrent-mode-patterns.html#suspenselist)")," to render the items: this will ensure that the list is rendered in order from top to bottom even if individual items in the list suspend and resolve at different times; that is, it will prevent items from rendering out of order, which prevents content from jumping around after it has been rendered.")),Object(i.b)("h3",{id:"pagination"},"Pagination"),Object(i.b)("p",null,"To actually perform pagination over the connection, we need use the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"loadNext"))," function to fetch the next page of items, which is available from ",Object(i.b)("inlineCode",{parentName:"p"},"usePaginationFragment"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {FriendsListPaginationQuery} from 'FriendsListPaginationQuery.graphql';\nimport type {FriendsListComponent_user$key} from 'FriendsList_user.graphql';\n\nconst React = require('React');\nconst {Suspense, SuspenseList, useTransition} = require('React');\n\nconst {graphql, usePaginationFragment} = require('react-relay/hooks');\n\ntype Props = {|\n  user: FriendsListComponent_user$key,\n|};\n\nfunction FriendsListComponent(props: Props) {\n  const [startTransition] = useTransition();\n  const {data, loadNext} = usePaginationFragment<FriendsListPaginationQuery, _>(\n    graphql`\n      fragment FriendsListComponent_user on User\n      @refetchable(queryName: \"FriendsListPaginationQuery\") {\n        name\n        friends(first: $count, after: $cursor)\n        @connection(key: \"FriendsList_user_friends\") {\n          edges {\n            node {\n              name\n              age\n            }\n          }\n        }\n      }\n    `,\n    props.user,\n  );\n\n  return (\n    <>\n      <h1>Friends of {data.name}:</h1>\n      <SuspenseList revealOrder=\"forwards\">\n        {(data.friends?.edges ?? []).map(edge => {\n          const node = edge.node;\n          return (\n            <Suspense fallback={<Glimmer />}>\n              <FriendComponent user={node} />\n            </Suspense>\n          );\n        })}\n      </SuspenseList>\n\n      <Button\n        onClick={() => {\n          startTransition(() => {\n            loadNext(10)\n          });\n        }}>\n        Load more friends\n      </Button>\n    </>\n  );\n}\n\nmodule.exports = FriendsListComponent;\n\n")),Object(i.b)("p",null,"Let's distill what's happening here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"loadNext"))," takes a count to specify how many more items in the connection to fetch from the server. In this case, when ",Object(i.b)("inlineCode",{parentName:"li"},"loadNext")," is called we'll fetch the next 10 friends in the friends list of our currently rendered ",Object(i.b)("inlineCode",{parentName:"li"},"User"),"."),Object(i.b)("li",{parentName:"ul"},"When the request to fetch the next items completes, the connection will be automatically updated and the component will re-render with the latest items in the connection. In our case, this means that the ",Object(i.b)("inlineCode",{parentName:"li"},"friends")," field will always contain ",Object(i.b)("em",{parentName:"li"},"all")," of the friends that we've fetched so far. By default, ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"Relay will automatically append new items to the connection upon completing a pagination request,"))," and will make them available to your fragment component. If you need a different behavior, check out our ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#advanced-pagination-use-cases"}),"Advanced Pagination Use Cases")," section."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"loadNext")," may cause the component or new children components to suspend (as explained in ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#transitions-and-updates-that-suspend"}),"Transitions And Updates That Suspend"),"). This means that you'll need to make sure that there's a ",Object(i.b)("inlineCode",{parentName:"li"},"Suspense")," boundary wrapping this component from above, and/or that you are using ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://reactjs.org/docs/concurrent-mode-patterns.html#transitions"}),Object(i.b)("inlineCode",{parentName:"a"},"useTransition"))," with a Suspense config in order to show the appropriate pending or loading state.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Note that since ",Object(i.b)("inlineCode",{parentName:"li"},"loadNext")," may cause the component to suspend, regardless of whether we're using a Suspense config to render a pending state, we should always use ",Object(i.b)("inlineCode",{parentName:"li"},"startTransition")," to schedule that update; any update that may cause a component to suspend should be scheduled using this pattern.")))),Object(i.b)("p",null,"Often, you will also want to access information about whether there are more items available to load. To do this, you can use the ",Object(i.b)("inlineCode",{parentName:"p"},"hasNext")," value, also available from ",Object(i.b)("inlineCode",{parentName:"p"},"usePaginationFragment"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {FriendsListPaginationQuery} from 'FriendsListPaginationQuery.graphql';\nimport type {FriendsListComponent_user$key} from 'FriendsList_user.graphql';\n\nconst React = require('React');\nconst {Suspense, SuspenseList, useTransition} = require('React');\n\nconst {graphql, usePaginationFragment} = require('react-relay/hooks');\n\ntype Props = {|\n  user: FriendsListComponent_user$key,\n|};\n\nfunction FriendsListComponent(props: Props) {\n  const [startTransition] = useTransition();\n  const {\n    data,\n    loadNext,\n    hasNext,\n  } = `usePaginationFragment``<``FriendsListPaginationQuery``,`` _``>`(\n    graphql`\n      fragment FriendsListComponent_user on User\n      @refetchable(queryName: \"FriendsListPaginationQuery\") {\n        name\n        friends(first: $count, after: $cursor)\n        @connection(key: \"FriendsList_user_friends\") {\n          edges {\n            node {\n              name\n              age\n            }\n          }\n        }\n      }\n    `,\n    props.user,\n  );\n\n  return (\n    <>\n      <h1>Friends of {data.name}:</h1>\n      <SuspenseList revealOrder=\"forwards\">\n        {(data.friends?.edges ?? []).map(edge => {\n          const node = edge.node;\n          return (\n            <Suspense fallback={<Glimmer />}>\n              <FriendComponent user={node} />\n            </Suspense>\n          );\n        })}\n      </SuspenseList>\n\n      {\n        // Only render button if there are more friends to load in the list\n        hasNext ? (\n          <Button\n            onClick={() => {\n              startTransition(() => {\n                loadNext(10)\n              });\n            }}>\n            Load more friends\n          </Button>\n        ) : null}\n    </>\n  );\n}\n\nmodule.exports = FriendsListComponent;\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"hasNext")," is a boolean which indicates if the connection has more items available. This information can be useful for determining if different UI controls should be rendered. In our specific case, we only render the ",Object(i.b)("inlineCode",{parentName:"li"},"Button")," if there are more friends available in the connection .")),Object(i.b)("h3",{id:"blocking-all-at-once-pagination"},'Blocking ("all-at-once") Pagination'),Object(i.b)("p",null,"So far when we've talked about pagination, we haven't specified how we want pagination to behave when we're rendering the new items we've fetched. Since the new items that we're fetching and rendering might individually suspend due to their own asynchronous dependencies (",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#loading-states-with-suspense"}),"Loading States with Suspense"),"), we need to be able to specify what kind of behavior we want to have as we render them."),Object(i.b)("p",null,"Usually, we've identified that this will fall under one of these 2 categories:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},'"One by one"')),' (or "stream-y") pagination: Regardless of whether we\'re actually streaming at the data layer, conceptually this type of pagination is where we want to render items one by one, in order, as they become available. In this use case, we usually want to show some sort of loading placeholder for the new items (either in aggregate or for each individual item) as they are loaded in. This should not exclude the possibility of ',Object(i.b)("em",{parentName:"li"},"also")," having a ",Object(i.b)("em",{parentName:"li"},"separate")," ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://reactjs.org/docs/concurrent-mode-patterns.html#the-three-steps"}),"pending or busy state")," (like a spinner next to the button that started the action). This is generally the default pagination behavior that we'll want, which applies to most lists and feeds."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},'"All at once"'))," pagination: This type of pagination is where we want to load and render the entire next page of items ",Object(i.b)("em",{parentName:"li"},"all at once,")," in a ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"single paint")),"; that is, we want to render the next page of items only when ",Object(i.b)("em",{parentName:"li"},"all")," of the items are ready (including when individual items suspend). Unlike the previous case, in this case, we do not want to show individual placeholders for the new items in the list, but instead we want to immediately show a ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://reactjs.org/docs/concurrent-mode-patterns.html#the-three-steps"}),"pending or busy state"),', such as a spinner next (or close) to the element that started the action (like a button); this pending spinner should continue "spinning" until the entire next page of items are ',Object(i.b)("em",{parentName:"li"},"fully")," loaded and rendered. The best example of this type of use case is pagination when loading new comments in a list of comments.")),Object(i.b)("p",null,"So far in the previous pagination sections, we've implicitly been referring to the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},'"one by one"'))," pagination case when describe using ",Object(i.b)("inlineCode",{parentName:"p"},"usePaginationFragment")," + ",Object(i.b)("inlineCode",{parentName:"p"},"SuspenseList")," to render lists and show loading placeholders."),Object(i.b)("p",null,"However, if we want to implement ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},'"all at once"'))," pagination, we need to use a different API, ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"useBlockingPaginationFragment")),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\nimport type {FriendsListPaginationQuery} from \'FriendsListPaginationQuery.graphql\';\nimport type {FriendsListComponent_user$key} from \'FriendsList_user.graphql\';\n\nconst React = require(\'React\');\nconst {useTransition, Suspense, SuspenseList} = require(\'React\');\n\nconst {graphql, useBlockingPaginationFragment} = require(\'react-relay/hooks\');\n\ntype Props = {|\n  user: FriendsListComponent_user$key,\n|};\n\nconst SUSPENSE_CONFIG = {\n  // timeoutMs allows us to delay showing the "loading" state for a while\n  // in favor of showing a "pending" state that we control locally\n  timeoutMs: 30 * 1000,\n};\n\nfunction FriendsListComponent(props: Props) {\n  // isPending captures the "pending" state. It will become true\n  // **immediately** when the pagination transition starts, and will be set back\n  // to false when the transition reaches the fully "completed" stage\n  // (i.e. when all the new items in the list have fully loaded and rendered)\n  const [startTransition, isPending] = useTransition(SUSPENSE_CONFIG);\n  const {\n    data,\n    loadNext,\n    hasNext,\n  } = useBlockingPaginationFragment<FriendsListPaginationQuery, _>(\n    graphql`\n      fragment FriendsListComponent_user on User\n      @refetchable(queryName: "FriendsListPaginationQuery") {\n        name\n        friends(first: $count, after: $cursor)\n        @connection(key: "FriendsList_user_friends") {\n          edges {\n            node {\n              name\n              age\n            }\n          }\n        }\n      }\n    `,\n    props.user,\n  );\n\n  return (\n    <>\n      <h1>Friends of {data.name}:</h1>\n      <SuspenseList revealOrder="forwards">\n        {(data.friends?.edges ?? []).map(edge => {\n          const node = edge.node;\n          return (\n            <Suspense fallback={<Glimmer />}>\n              <FriendComponent user={node} />\n            </Suspense>\n          );\n        })}\n      </SuspenseList>\n\n      {\n        // Render a Spinner next to the button immediately, while transition is pending\n        isPending ? <Spinner /> : null\n      }\n\n      {hasNext ? (\n        <Button\n          // Disable the button immediately, while transition is pending\n          disabled={isPending}\n          onClick={() => {\n            startTransition(() => {\n              loadNext(10)\n            });\n          }}>\n          Load more friends\n        </Button>\n      ) : null}\n    </>\n  );\n}\n\nmodule.exports = FriendsListComponent;\n\n')),Object(i.b)("p",null,"Let's distill what's going on here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"loadNext")," will cause the component to suspend, so we need to wrap it in ",Object(i.b)("inlineCode",{parentName:"li"},"startTransition"),", as explained in ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#transitions-and-updates-that-suspend"}),"Transitions And Updates That Suspend"),")."),Object(i.b)("li",{parentName:"ul"},"Also similarly to the case described in ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#transitions-and-updates-that-suspend"}),"Transitions And Updates That Suspend"),", we're passing the ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"SUSPENSE_CONFIG"))," config object to ",Object(i.b)("inlineCode",{parentName:"li"},"useTransition")," in order to configure how we want this transition to behave. Specifically, we can pass a ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"timeoutMs"))," property in the config, which will dictate how long React should wait before transitioning to the ",Object(i.b)("em",{parentName:"li"},'"loading"')," state (i.e. transition to showing the loading placeholders for the new items), in favor of showing a ",Object(i.b)("em",{parentName:"li"},'"pending"')," state controlled locally by the component during that time."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"useTransition")," will also return a ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"isPending"))," boolean value, which captures the pending state. That is, this value will become ",Object(i.b)("inlineCode",{parentName:"li"},"true")," ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"immediately"))," when the pagination transition starts, and will become ",Object(i.b)("inlineCode",{parentName:"li"},"false")," when the transition reaches the fully ",Object(i.b)("em",{parentName:"li"},'"completed"')," stage, that is, when all the new items have been ",Object(i.b)("em",{parentName:"li"},"fully")," loaded, including their own asynchronous dependencies that would cause them to suspend. We can use the ",Object(i.b)("inlineCode",{parentName:"li"},"isPending")," value to show immediate post to the user action, in this case by rendering a spinner next to the button and disabling the button. In this case, the spinner will be rendered and the button will be disabled until ",Object(i.b)("em",{parentName:"li"},"all")," the new items in the list have been fully loaded and rendered.")),Object(i.b)("h3",{id:"using-and-changing-filters"},"Using and Changing Filters"),Object(i.b)("p",null,"Often times when querying for a list of data, you can provide different values in the query which serve as filters that change the result set, or sort it differently."),Object(i.b)("p",null,"Some examples of this are:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Building a search typeahead, where the list of results is a list filtered by the search term entered by the user."),Object(i.b)("li",{parentName:"ul"},"Changing the ordering mode of the list comments currently displayed for a post, which could produce a completely different set of comments from the server."),Object(i.b)("li",{parentName:"ul"},"Changing the way News Feed is ranked and sorted.")),Object(i.b)("p",null,"Specifically, in GraphQL, connection fields can accept arguments to sort or filter the set of queried results:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),'\nfragment UserFragment on User {\n  name\n  friends(order_by: DATE_ADDED, search_term: "Alice", first: 10) {\n    edges {\n      node {\n        name\n        age\n      }\n    }\n  }\n}\n\n')),Object(i.b)("p",null,"In Relay, we can pass those arguments as usual using GraphQL ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#variables"}),"Variables"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\ntype Props = {|\n  user: FriendsListComponent_user$key,\n|};\n\nfunction FriendsListComponent(props: Props) {\n  const userRef = props.userRef;\n\n  const {data, ...} = usePaginationFragment(\n    graphql`\n      fragment FriendsListComponent_user on User {\n        name\n        friends(\n          order_by: $orderBy,\n          search_term: $searchTerm,\n          after: $cursor,\n          first: $count,\n        ) @connection(key: "FriendsListComponent_user_friends_connection") {\n          edges {\n            node {\n              name\n              age\n            }\n          }\n        }\n      }\n    `,\n    props.user,\n  );\n\n  return (...);\n}\n\n')),Object(i.b)("p",null,"When paginating, the original values for those filters will be preserved:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\ntype Props = {|\n  user: FriendsListComponent_user$key,\n|};\n\nfunction FriendsListComponent(props: Props) {\n  const userRef = props.userRef;\n\n  const {data, loadNext} = usePaginationFragment(\n    graphql`\n      fragment FriendsListComponent_user on User {\n        name\n        friends(order_by: $orderBy, search_term: $searchTerm)\n          @connection(key: "FriendsListComponent_user_friends_connection") {\n          edges {\n            node {\n              name\n              age\n            }\n          }\n        }\n      }\n    `,\n    userRef,\n  );\n\n  return (\n    <>\n      <h1>Friends of {data.name}:</h1>\n      <List items={data.friends?.nodes}>{...}</List>\n\n      /*\n       Loading the next items will use the original order_by and search_term\n       values used for the initial query\n    */\n      <Button onClick={() => loadNext(10)}>Load more friends</Button>\n    </>\n  );\n}\n\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Note that calling ",Object(i.b)("inlineCode",{parentName:"li"},"loadNext")," will use the ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"original"))," ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"order_by"))," and ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"search_term"))," values used for the initial query. During pagination, these value won't (",Object(i.b)("em",{parentName:"li"},"and shouldn't"),") change.")),Object(i.b)("p",null,"If we want to refetch the connection with ",Object(i.b)("em",{parentName:"p"},"different")," variables, we can use the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"refetch"))," function provided by ",Object(i.b)("inlineCode",{parentName:"p"},"usePaginationFragment"),", similarly to how we do so when ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#re-rendering-fragments-with-different-data"}),"Re-rendering Fragments With Different Data"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n/**\n * FriendsListComponent.react.js\n */\nimport type {FriendsListComponent_user$ref} from 'FriendsListComponent_user.graphql';\n\nconst React = require('React');\nconst {useState, useEffect, useTransition, SuspenseList} = require('React');\n\nconst {graphql, usePaginationFragment} = require('react-relay/hooks');\n\ntype Props = {|\n  searchTerm?: string,\n  user: FriendsListComponent_user$key,\n|};\n\nfunction FriendsListComponent(props: Props) {\n  const searchTerm = props.searchTerm;\n  const [startTransition] = useTransition();\n  const {data, loadNext, refetch} = usePaginationFragment(\n    graphql`\n      fragment FriendsListComponent_user on User {\n        name\n        friends(\n          order_by: $orderBy,\n          search_term: $searchTerm,\n          after: $cursor,\n          first: $count,\n        ) @connection(key: \"FriendsListComponent_user_friends_connection\") {\n          edges {\n            node {\n              name\n              age\n            }\n          }\n        }\n      }\n    `,\n    props.user,\n  );\n\n  useEffect(() => {\n    // When the searchTerm provided via props changes, refetch the connection\n    // with the new searchTerm\n    startTransition(() => {\n      refetch({first: 10, search_term: searchTerm}, {fetchPolicy: 'store-or-network'});\n    });\n  }, [searchTerm]);\n\n  return (\n    <>\n      <h1>Friends of {data.name}:</h1>\n\n      <Button\n        // When the button is clicked, refetch the connection but sorted differently\n        onClick={() =>\n          startTransition(() => {\n            refetch({first: 10, orderBy: 'DATE_ADDED'});\n          })\n        }>\n        Sort by date added\n      </Button>\n\n      <SuspenseList>...</SuspenseList>\n      <Button onClick={() => loadNext(10)}>Load more friends</Button>\n    </>\n  );\n}\n\n")),Object(i.b)("p",null,"Let's distill what's going on here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Calling ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"refetch"))," and passing a new set of variables will fetch the fragment again ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"with the newly-provided variables")),". The variables you need to provide are a subset of the variables that the generated query expects; the generated query will require an ",Object(i.b)("inlineCode",{parentName:"li"},"id"),", if the type of the fragment has an ",Object(i.b)("inlineCode",{parentName:"li"},"id")," field, and any other variables that are transitively referenced in your fragment.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"In our case, we need to pass the count we want to fetch as the ",Object(i.b)("inlineCode",{parentName:"li"},"first")," variable, and we can pass different values for our filters, like ",Object(i.b)("inlineCode",{parentName:"li"},"orderBy")," or ",Object(i.b)("inlineCode",{parentName:"li"},"searchTerm"),"."))),Object(i.b)("li",{parentName:"ul"},"This will re-render your component and may cause it to suspend (as explained in ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#transitions-and-updates-that-suspend"}),"Transitions And Updates That Suspend"),") if it needs to send and wait for a network request. If ",Object(i.b)("inlineCode",{parentName:"li"},"refetch")," causes the component to suspend, you'll need to make sure that there's a ",Object(i.b)("inlineCode",{parentName:"li"},"Suspense")," boundary wrapping this component from above, and/or that you are using ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://reactjs.org/docs/concurrent-mode-patterns.html#transitions"}),Object(i.b)("inlineCode",{parentName:"a"},"useTransition"))," with a Suspense config in order to show the appropriate pending or loading state.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Note that since ",Object(i.b)("inlineCode",{parentName:"li"},"refetch")," may cause the component to suspend, regardless of whether we're using a Suspense config to render a pending state, we should always use ",Object(i.b)("inlineCode",{parentName:"li"},"startTransition")," to schedule that update; any update that may cause a component to suspend should be scheduled using this pattern."))),Object(i.b)("li",{parentName:"ul"},"Conceptually, when we call refetch, we're fetching the connection ",Object(i.b)("em",{parentName:"li"},"from scratch"),". In other words, we're fetching it again from the ",Object(i.b)("em",{parentName:"li"},"beginning")," and ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},'"resetting"'))," our pagination state. For example, if we fetch the connection with a different ",Object(i.b)("inlineCode",{parentName:"li"},"search_term"),", our pagination information for the previous ",Object(i.b)("inlineCode",{parentName:"li"},"search_term")," no longer makes sense, since we're essentially paginating over a new list of items.")),Object(i.b)("h3",{id:"adding-and-removing-items-from-a-connection"},"Adding and Removing Items From a Connection"),Object(i.b)("p",null,"Usually when you're rendering a connection, you'll also want to be able to add or remove items to/from the connection in response to user actions."),Object(i.b)("p",null,"As explained in our ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#updating-data"}),"Updating Data")," section, Relay holds a local in-memory store of normalized GraphQL data, where records are stored by their IDs.  When creating mutations, subscriptions, or local data updates with Relay, you must provide an ",Object(i.b)("inlineCode",{parentName:"p"},"updater")," function, inside which you can access and read records, as well as write and make updates to them. When records are updated, any components affected by the updated data will be notified and re-rendered."),Object(i.b)("h3",{id:"connection-records"},"Connection Records"),Object(i.b)("p",null,"In Relay, connection fields that are marked with the ",Object(i.b)("inlineCode",{parentName:"p"},"@connection")," directive are stored as special records in the store, and they hold and accumulate ",Object(i.b)("em",{parentName:"p"},"all")," of the items that have been fetched for the connection so far. In order to add or remove items from a connection, we need to access the connection record using the connection ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},Object(i.b)("inlineCode",{parentName:"em"},"key"))),", which was provided when declaring a ",Object(i.b)("inlineCode",{parentName:"p"},"@connection"),"; specifically, this allows us to access a connection inside an ",Object(i.b)("inlineCode",{parentName:"p"},"updater")," function using the ",Object(i.b)("inlineCode",{parentName:"p"},"ConnectionHandler")," APIs."),Object(i.b)("p",null,"For example, given the following fragment that declares a ",Object(i.b)("inlineCode",{parentName:"p"},"@connection"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {graphql} = require('react-relay');\n\nconst storyFragment = graphql`\n  fragment StoryComponent_story on Story {\n    comments @connection(key: \"StoryComponent_story_comments_connection\") {\n      nodes {\n        body {\n          text\n        }\n      }\n    }\n  }\n`;\n\n")),Object(i.b)("p",null,"We can access the connection record inside an ",Object(i.b)("inlineCode",{parentName:"p"},"updater")," function using ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"ConnectionHandler.getConnection")),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {ConnectionHandler} = require('react-relay');\n\nfunction updater(store: RecordSourceSelectorProxy) {\n  const storyRecord = store.get(storyID);\n  const connectionRecord = ConnectionHandler.getConnection(\n    storyRecord,\n    'StoryComponent_story_comments_connection',\n  );\n\n  // ...\n}\n\n")),Object(i.b)("h3",{id:"adding-edges"},"Adding Edges"),Object(i.b)("p",null,"Once we have a connection record, we also need a record for the new edge that we want to add to the connection. Usually, mutation or subscription payloads will contain the new edge that was added; if not, you can also construct a new edge from scratch."),Object(i.b)("p",null,"For example, in the following mutation we can query for the newly created edge in the mutation response:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {graphql} = require('react-relay');\n\nconst createCommentMutation = graphql`\n  mutation CreateCommentMutation($input: CommentCreateData!) {\n    comment_create(input: $input) {\n      comment_edge {\n        cursor\n        node {\n          body {\n            text\n          }\n        }\n      }\n    }\n  }\n`;\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Note that we also query for the ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"cursor"))," for the new edge; this isn't strictly necessary, but it is information that will be required if we need to perform pagination based on that ",Object(i.b)("inlineCode",{parentName:"li"},"cursor"),".")),Object(i.b)("p",null,"Inside an ",Object(i.b)("inlineCode",{parentName:"p"},"updater"),", we can access the edge inside the mutation response using Relay store APIs:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {ConnectionHandler} = require('react-relay');\n\nfunction updater(store: RecordSourceSelectorProxy) {\n  const storyRecord = store.get(storyID);\n  const connectionRecord = ConnectionHandler.getConnection(\n    storyRecord,\n    'StoryComponent_story_comments_connection',\n  );\n\n  // Get the payload returned from the server\n  const payload = store.getRootField('comment_create');\n\n  // Get the edge inside the payload\n  const serverEdge = payload.getLinkedRecord('comment_edge');\n\n  // Build edge for adding to the connection\n  const newEdge = ConnectionHandler.buildConnectionEdge(\n    store,\n    connectionRecord,\n    serverEdge,\n  );\n\n  // ...\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The mutation payload is available as a root field on that store, which can be read using the ",Object(i.b)("inlineCode",{parentName:"li"},"store.getRootField")," API. In our case, we're reading ",Object(i.b)("inlineCode",{parentName:"li"},"comment_create"),", which is the root field in the response."),Object(i.b)("li",{parentName:"ul"},"Note that we need to construct the new edge from the edge received from the server using ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"ConnectionHandler.buildConnectionEdge"))," before we can add it to the connection.")),Object(i.b)("p",null,"If you need to create a new edge from scratch, you can use ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"ConnectionHandler.createEdge")),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {ConnectionHandler} = require('react-relay');\n\nfunction updater(store: RecordSourceSelectorProxy) {\n  const storyRecord = store.get(storyID);\n  const connectionRecord = ConnectionHandler.getConnection(\n    storyRecord,\n    'StoryComponent_story_comments_connection',\n  );\n\n  // Create a new local Comment record\n  const id = `client:new_comment:${randomID()}`;\n  const newCommentRecord = store.create(id, 'Comment');\n\n  // Create new edge\n  const newEdge = ConnectionHandler.createEdge(\n    store,\n    connectionRecord,\n    newCommentRecord,\n    'CommentEdge', /* GraphQl Type for edge */\n  );\n\n  // ...\n}\n\n")),Object(i.b)("p",null,"Once we have a new edge record, we can add it to the the connection using ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"ConnectionHandler.insertEdgeAfter"))," or ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"ConnectionHandler.insertEdgeBefore")),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {ConnectionHandler} = require('react-relay');\n\nfunction updater(store: RecordSourceSelectorProxy) {\n  const storyRecord = store.get(storyID);\n  const connectionRecord = ConnectionHandler.getConnection(\n    storyRecord,\n    'StoryComponent_story_comments_connection',\n  );\n\n  const newEdge = (...);\n\n  // Add edge to the end of the connection\n  ConnectionHandler.insertEdgeAfter(\n    connectionRecord,\n    newEdge,\n  );\n\n  // Add edge to the beginning of the connection\n  ConnectionHandler.insertEdgeBefore(\n    connectionRecord,\n    newEdge,\n  );\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Note that these APIs will ",Object(i.b)("em",{parentName:"li"},"mutate")," the connection in-place.")),Object(i.b)("h3",{id:"removing-edges"},"Removing Edges"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"ConnectionHandler")," provides a similar API to remove an edge from a connection, via ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"ConnectionHandler.deleteNode")),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {ConnectionHandler} = require('react-relay');\n\nfunction updater(store: RecordSourceSelectorProxy) {\n  const storyRecord = store.get(storyID);\n  const connectionRecord = ConnectionHandler.getConnection(\n    storyRecord,\n    'StoryComponent_story_comments_connection',\n  );\n\n  // Remove edge from the connection, given the ID of the node\n  ConnectionHandler.deleteNode(\n    connectionRecord,\n    commentIDToDelete,\n  );\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"In this case ",Object(i.b)("inlineCode",{parentName:"li"},"ConnectionHandler.deleteNode")," will remove an edge given a ",Object(i.b)("strong",{parentName:"li"},"*",Object(i.b)("inlineCode",{parentName:"strong"},"node"))," ID","*",". This means it will look up which edge in the connection contains a node with the provided ID, and remove that edge."),Object(i.b)("li",{parentName:"ul"},"Note that this API will ",Object(i.b)("em",{parentName:"li"},"mutate")," the connection in-place.")),Object(i.b)("blockquote",null,Object(i.b)("strong",null,"Remember:")," When performing any of the operations described here to mutate a connection, any fragment or query components that are rendering the affected connection will be notified and re-render with the latest version of the connection."),Object(i.b)("p",null,"You can also check out our complete Relay Store APIs ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://relay.dev/docs/en/relay-store.html"}),"here")),Object(i.b)("h3",{id:"connection-identity-with-filters"},"Connection Identity With Filters"),Object(i.b)("p",null,"In our previous examples, our connections didn't take any arguments as filters. If you declared a connection that takes arguments as filters, the values used for the filters will be part of the connection identifier. In other words, ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"each of the values passed in as connection filters will be used to identify the connection in the Relay store")),", however, ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"excluding"))," pagination arguments; i.e. excluding:  ",Object(i.b)("inlineCode",{parentName:"p"},"first:"),", ",Object(i.b)("inlineCode",{parentName:"p"},"last:"),", ",Object(i.b)("inlineCode",{parentName:"p"},"before:"),", and ",Object(i.b)("inlineCode",{parentName:"p"},"after:"),"."),Object(i.b)("p",null,"For example, let's say the ",Object(i.b)("inlineCode",{parentName:"p"},"comments")," field took the following arguments, which we pass in as GraphQL ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#variables"}),"Variables"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {graphql} = require('react-relay');\n\nconst storyFragment = graphql`\n  fragment StoryComponent_story on Story {\n    comments(\n      order_by: $orderBy,\n      filter_mode: $filterMode,\n      language: $language,\n    ) @connection(key: \"StoryComponent_story_comments_connection\") {\n      edges {\n        nodes {\n          body {\n            text\n          }\n        }\n      }\n    }\n  }\n`;\n\n")),Object(i.b)("p",null,"In the example above, this means that whatever values we used for ",Object(i.b)("inlineCode",{parentName:"p"},"$orderBy"),", ",Object(i.b)("inlineCode",{parentName:"p"},"$filterMode")," and ",Object(i.b)("inlineCode",{parentName:"p"},"$language")," when we queried for the ",Object(i.b)("inlineCode",{parentName:"p"},"comments")," field will be part of the connection identifier, and we'll need to use those values when accessing the connection record from the Relay store."),Object(i.b)("p",null,"In order to do so, we need to pass a third argument to ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"ConnectionHandler.getConnection")),", with concrete filter values to identify the connection:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {ConnectionHandler} = require('react-relay');\n\nfunction updater(store: RecordSourceSelectorProxy) {\n  const storyRecord = store.get(storyID);\n\n  // Get the connection instance for the connection with comments sorted\n  // by the date they were added\n  const connectionRecordSortedByDate = ConnectionHandler.getConnection(\n    storyRecord,\n    'StoryComponent_story_comments_connection',\n    {order_by: 'DATE_ADDED', filter_mode: null, language: null}\n  );\n\n  // Get the connection instance for the connection that only contains\n  // comments made by friends\n  const connectionRecordFriendsOnly = ConnectionHandler.getConnection(\n    storyRecord,\n    'StoryComponent_story_comments_connection',\n    {order_by: null, filter_mode: 'FRIENDS_ONLY', langugage: null}\n  );\n}\n\n")),Object(i.b)("p",null,"This implies that by default, ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"each combination of values used for filters will produce a different record for the connection."))),Object(i.b)("p",null,"When making updates to a connection, you will need to make sure to update all of the relevant records affected by a change. For example, if we were to add a new comment to our example connection, we'd need to make sure ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"not"))," to add the comment to the ",Object(i.b)("inlineCode",{parentName:"p"},"FRIENDS_ONLY")," connection, if the new comment wasn't made by a friend of the user:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {ConnectionHandler} = require('react-relay');\n\nfunction updater(store: RecordSourceSelectorProxy) {\n  const storyRecord = store.get(storyID);\n\n  // Get the connection instance for the connection with comments sorted\n  // by the date they were added\n  const connectionRecordSortedByDate = ConnectionHandler.getConnection(\n    storyRecord,\n    'StoryComponent_story_comments_connection',\n    {order_by: '*DATE_ADDED*', filter_mode: null, language: null}\n  );\n\n  // Get the connection instance for the connection that only contains\n  // comments made by friends\n  const connectionRecordFriendsOnly = ConnectionHandler.getConnection(\n    storyRecord,\n    'StoryComponent_story_comments_connection',\n    {order_by: null, filter_mode: '*FRIENDS_ONLY*', language: null}\n  );\n\n  const newComment = (...);\n  const newEdge = (...);\n\n  ConnectionHandler.insertEdgeAfter(\n    connectionRecordSortedByDate,\n    newEdge,\n  );\n\n  if (isMadeByFriend(storyRecord, newComment) {\n    // Only add new comment to friends-only connection if the comment\n    // was made by a friend\n    ConnectionHandler.insertEdgeAfter(\n      connectionRecordFriendsOnly,\n      newEdge,\n    );\n  }\n}\n\n")),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},Object(i.b)("strong",{parentName:"em"},"Managing connections with many filters:"))),Object(i.b)("p",null,"As you can see, just adding a few filters to a connection can make the complexity and number of connection records that need to be managed explode. In order to more easily manage this, Relay provides 2 strategies:"),Object(i.b)("p",null,"1) Specify exactly ",Object(i.b)("em",{parentName:"p"},"which")," filters should be used as connection identifiers."),Object(i.b)("p",null,"By default, ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"all"))," ",Object(i.b)("strong",{parentName:"p"},"non-pagination")," filters will be used as part of the connection identifier. However, when declaring a ",Object(i.b)("inlineCode",{parentName:"p"},"@connection"),", you can specify the exact set of filters to use for connection identity:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\nconst {graphql} = require(\'react-relay\');\n\nconst storyFragment = graphql`\n  fragment StoryComponent_story on Story {\n    comments(\n      order_by: $orderBy\n      filter_mode: $filterMode\n      language: $language\n    )\n      @connection(\n        key: "StoryComponent_story_comments_connection"\n        filters: ["order_by", "filter_mode"]\n      ) {\n      edges {\n        nodes {\n          body {\n            text\n          }\n        }\n      }\n    }\n  }\n`;\n\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"By specifying ",Object(i.b)("inlineCode",{parentName:"li"},"filters")," when declaring the ",Object(i.b)("inlineCode",{parentName:"li"},"@connection"),", we're indicating to Relay the exact set of filter values that should be used as part of connection identity. In this case, we're excluding ",Object(i.b)("inlineCode",{parentName:"li"},"language"),", which means that only values for ",Object(i.b)("inlineCode",{parentName:"li"},"order_by")," and ",Object(i.b)("inlineCode",{parentName:"li"},"filter_mode")," will affect connection identity and thus produce new connection records."),Object(i.b)("li",{parentName:"ul"},"Conceptually, this means that we're specifying which arguments affect the output of the connection from the server, or in other words, which arguments are ",Object(i.b)("em",{parentName:"li"},"actually")," ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"filters")),". If one of the connection arguments doesn't actually change the set of items that are returned from the server, or their ordering, then it isn't really a filter on the connection, and we don't need to identify the connection differently when that value changes. In our example, changing the ",Object(i.b)("inlineCode",{parentName:"li"},"language")," of the comments we request doesn't change the set of comments that are returned by the connection, so it is safe to exclude it from ",Object(i.b)("inlineCode",{parentName:"li"},"filters"),"."),Object(i.b)("li",{parentName:"ul"},"This can also be useful if we know that any of the connection arguments will never change in our app, in which case it would also be safe to exclude from ",Object(i.b)("inlineCode",{parentName:"li"},"filters"),".")),Object(i.b)("p",null,"2) An easier API alternative to manage multiple connections with multiple filter values is still pending"),Object(i.b)("blockquote",null,Object(i.b)("strong",null,"TODO")),Object(i.b)("h3",{id:"advanced-pagination-use-cases"},"Advanced Pagination Use Cases"),Object(i.b)("p",null,"In this section we're going to cover how to implement more advanced pagination use cases than the default cases covered by ",Object(i.b)("inlineCode",{parentName:"p"},"usePaginationFragment"),"."),Object(i.b)("h4",{id:"pagination-over-multiple-connections"},"Pagination Over Multiple Connections"),Object(i.b)("p",null,"If you need to paginate over multiple connections within the same component, you can use ",Object(i.b)("inlineCode",{parentName:"p"},"usePaginationFragment")," multiple times:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {CombinedFriendsListComponent_user$key} from 'CombinedFriendsListComponent_user.graphql';\nimport type {CombinedFriendsListComponent_viewer$key} from 'CombinedFriendsListComponent_viewer.graphql';\n\nconst React = require('React');\n\nconst {graphql, usePaginationFragment} = require('react-relay/hooks');\n\ntype Props = {|\n  user: CombinedFriendsListComponent_user$key,\n  viewer: CombinedFriendsListComponent_viewer$key,\n|};\n\nfunction CombinedFriendsListComponent(props: Props) {\n\n  const {data: userData, ...userPagination} = usePaginationFragment(\n    graphql`\n      fragment CombinedFriendsListComponent_user on User {\n        name\n        friends\n          @connection(\n            key: \"CombinedFriendsListComponent_user_friends_connection\"\n          ) {\n          edges {\n            node {\n              name\n              age\n            }\n          }\n        }\n      }\n    `,\n    props.user,\n  );\n\n  const {data: viewerData, ...viewerPagination} = usePaginationFragment(\n    graphql`\n      fragment CombinedFriendsListComponent_user on Viewer {\n        actor {\n          ... on User {\n            name\n            friends\n              @connection(\n                key: \"CombinedFriendsListComponent_viewer_friends_connection\"\n              ) {\n              edges {\n                node {\n                  name\n                  age\n                }\n              }\n            }\n          }\n        }\n      }\n    `,\n    props.viewer,\n  );\n\n  return (...);\n}\n\n")),Object(i.b)("p",null,"However, we recommend trying to keep a single connection per component, to keep the components easier to follow."),Object(i.b)("h4",{id:"bi-directional-pagination"},"Bi-directional Pagination"),Object(i.b)("p",null,"In the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#pagination"}),"Pagination")," section we covered how to use ",Object(i.b)("inlineCode",{parentName:"p"},"usePaginationFragment")," to paginate in a single ",Object(i.b)("em",{parentName:"p"},'"forward"')," direction. However, connections also allow paginating in the opposite ",Object(i.b)("em",{parentName:"p"},'"backward"')," direction. The meaning of ",Object(i.b)("em",{parentName:"p"},'"forward"')," and ",Object(i.b)("em",{parentName:"p"},'"backward"')," directions will depend on how the items in the connection are sorted, for example  ",Object(i.b)("em",{parentName:"p"},'"forward"')," could mean more recent, and ",Object(i.b)("em",{parentName:"p"},'"backward"')," could mean less recent."),Object(i.b)("p",null,"Regardless of the semantic meaning of the direction, Relay also provides the same APIs to paginate in the opposite direction using ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"usePaginationFragment")),", as long  as the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"before"))," and ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"last"))," connection arguments are also used along with ",Object(i.b)("inlineCode",{parentName:"p"},"after")," and ",Object(i.b)("inlineCode",{parentName:"p"},"first"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {FriendsListComponent_user$key} from 'FriendsListComponent_user.graphql';\n\nconst React = require('React');\nconst {Suspense} = require('React');\n\nconst {graphql, usePaginationFragment} = require('react-relay/hooks');\n\ntype Props = {|\n  userRef: FriendsListComponent_user$key,\n|};\n\nfunction FriendsListComponent(props: Props) {\n  const {\n    data,\n    loadPrevious,\n    hasPrevious,\n    // ... forward pagination values\n  } = usePaginationFragment(\n    graphql`\n      fragment FriendsListComponent_user on User {\n        name\n        friends(after: $after, before: $before, first: $first, last: $last)\n          @connection(key: \"FriendsListComponent_user_friends_connection\") {\n          edges {\n            node {\n              name\n              age\n            }\n          }\n        }\n      }\n    `,\n    userRef,\n  );\n\n  return (\n    <>\n      <h1>Friends of {data.name}:</h1>\n      <List items={data.friends?.edges.map(edge => edge.node)}>\n        {node => {\n          return (\n            <div>\n              {node.name} - {node.age}\n            </div>\n          );\n        }}\n      </List>\n\n      {hasPrevious ? (\n        <Button onClick={() => loadPrevious(10)}>\n          Load more friends\n        </Button>\n      ) : null}\n\n    </>\n    // Forward pagination controls can also be included\n  );\n}\n\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The APIs for both ",Object(i.b)("em",{parentName:"li"},'"forward"')," and ",Object(i.b)("em",{parentName:"li"},'"backward"')," are exactly the same, they're only named differently. When paginating forward, then the  ",Object(i.b)("inlineCode",{parentName:"li"},"after")," and ",Object(i.b)("inlineCode",{parentName:"li"},"first")," connection arguments will be used, when paginating backward, the ",Object(i.b)("inlineCode",{parentName:"li"},"before")," and ",Object(i.b)("inlineCode",{parentName:"li"},"last")," connection arguments will be used."),Object(i.b)("li",{parentName:"ul"},"Note that the primitives for both ",Object(i.b)("em",{parentName:"li"},'"forward"')," and ",Object(i.b)("em",{parentName:"li"},'"backward"')," pagination are exposed from a single use of ",Object(i.b)("inlineCode",{parentName:"li"},"usePaginationFragment")," call, so both ",Object(i.b)("em",{parentName:"li"},'"forward"')," and ",Object(i.b)("em",{parentName:"li"},'"backward"')," pagination can be performed simultaneously in the same component.")),Object(i.b)("h4",{id:"custom-connection-state"},"Custom Connection State"),Object(i.b)("p",null,"By default, when using ",Object(i.b)("inlineCode",{parentName:"p"},"usePaginationFragment")," and ",Object(i.b)("inlineCode",{parentName:"p"},"@connection"),", Relay will ",Object(i.b)("em",{parentName:"p"},"append")," new pages of items to the connection when paginating ",Object(i.b)("em",{parentName:"p"},'"forward",')," and ",Object(i.b)("em",{parentName:"p"},"prepend")," new pages of items when paginating ",Object(i.b)("em",{parentName:"p"},'"backward"'),". This means that your component will always render the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"full"))," connection, with ",Object(i.b)("em",{parentName:"p"},"all")," of the items that have been accumulated so far via pagination, and/or items that have been added or removed via mutations or subscriptions."),Object(i.b)("p",null,"However, it is possible that you'd need different behavior for how to merge and accumulate pagination results (or other updates to the connection), and/or derive local component state from changes to the connection. Some examples of this might be:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Keeping track of different ",Object(i.b)("em",{parentName:"li"},"visible")," slices or windows of the connection."),Object(i.b)("li",{parentName:"ul"},"Visually separating each ",Object(i.b)("em",{parentName:"li"},"page")," of items. This requires knowledge of the exact set of items inside each page that has been fetched."),Object(i.b)("li",{parentName:"ul"},'Displaying different ends of the same connection simultaneously, while keeping track of the "gaps" between them, and being able to merge results when preforming pagination between the gaps. For example, imagine rendering a list of comments where the oldest comments are displayed at the top, then a "gap" that can be interacted with to paginate, and then a section at the bottom which shows the most recent comments that have been added by the user or by real-time subscriptions.')),Object(i.b)("p",null,"To address these more complex use cases, Relay is still working on a solution:"),Object(i.b)("blockquote",null,Object(i.b)("strong",null,"TODO")),Object(i.b)("h4",{id:"refreshing-connections"},"Refreshing connections"),Object(i.b)("blockquote",null,Object(i.b)("strong",null,"TODO")),Object(i.b)("h4",{id:"prefetching-pages-of-a-connection"},"Prefetching Pages of a Connection"),Object(i.b)("blockquote",null,Object(i.b)("strong",null,"TODO")),Object(i.b)("h4",{id:"rendering-one-page-of-items-at-a-time"},"Rendering One Page of Items at a Time"),Object(i.b)("blockquote",null,Object(i.b)("strong",null,"TODO")),Object(i.b)("h2",{id:"advanced-data-fetching"},"Advanced Data Fetching"),Object(i.b)("h3",{id:"preloading-data"},"Preloading Data"),Object(i.b)("h4",{id:"preloading-data-for-initial-load-server-preloading"},"Preloading Data for Initial Load (Server Preloading)"),Object(i.b)("blockquote",null,"OSS TODO"),Object(i.b)("h4",{id:"preloading-data-for-transitions-in-parallel-with-code-client-preloading"},"Preloading Data for Transitions, in Parallel With Code (Client Preloading)"),Object(i.b)("p",null,"The way navigations or transitions into different pages work by default is the following:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("em",{parentName:"li"},"first"),", we load the code necessary to render that new page, since that will usually correspond to a separate JS bundle."),Object(i.b)("li",{parentName:"ul"},"*","then, once the code for the new page is loaded, we can start rendering it, and only at that point when we start rendering the page do we send a network request to fetch the data that the page needs, for example by using ",Object(i.b)("inlineCode",{parentName:"li"},"useLazyLoadQuery")," (",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#queries"}),"Queries"),").")),Object(i.b)("p",null,"This not only applies to transitions to other pages, but also for displaying elements such as dialogs, menus, popovers, or other elements that are hidden behind some user interaction, and which have both code ",Object(i.b)("em",{parentName:"p"},"and")," data dependencies."),Object(i.b)("p",null,"The problem with this naive approach is that we have to wait for a significant amount of time before we can actually start fetching the data we need. Ideally, by the time a user interaction occurs, we'd already know what data we will need in order to fulfill that interaction, and we could start ",Object(i.b)("em",{parentName:"p"},"preloading")," it from the client immediately, ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"in parallel"))," with loading the JS code that we're going to need; by doing so, we can significantly speed up the amount of time it takes to show content to users after an interaction."),Object(i.b)("p",null,"In order to do so, we can use ",Object(i.b)("strong",{parentName:"p"},"Relay EntryPoints"),", which are a set of APIs for efficiently loading both the code and data dependencies of ",Object(i.b)("em",{parentName:"p"},"any")," view in parallel. Check out our api reference for Entry Points: (TODO)"),Object(i.b)("h3",{id:"incremental-data-delivery"},"Incremental Data Delivery"),Object(i.b)("blockquote",null,"OSS TODO"),Object(i.b)("h3",{id:"data-driven-dependencies"},"Data-driven Dependencies"),Object(i.b)("blockquote",null,"OSS TODO"),Object(i.b)("h3",{id:"image-prefetching"},"Image Prefetching"),Object(i.b)("p",null,"The standard approach to loading images with Relay is to first request image URIs via a Relay fragment, then render an appropriate image component with the resulting URI as the source. With this approach the image is only downloaded if it is actually rendered, which is often a good tradeoff as it avoids fetching images that aren't used. However, there are some cases where a product knows statically that it will render an image, and in this case performance can be improved by downloading the image as early as possible. Relay ",Object(i.b)("strong",{parentName:"p"},"image prefetching")," allows products to specify that specific image URLs be downloaded as early as possible - as soon as the GraphQL data is fetched - without waiting for the consuming component to actually render."),Object(i.b)("h4",{id:"usage"},"Usage"),Object(i.b)("blockquote",null,"OSS TODO"),Object(i.b)("h4",{id:"when-to-use-image-prefetching"},"When To Use Image Prefetching"),Object(i.b)("p",null,"We recommend only using preloading for images that will be unconditionally rendered to the DOM by your components soon after being fetched, and avoid prefetching images that are hidden behind an interaction."),Object(i.b)("h2",{id:"updating-data"},"Updating Data"),Object(i.b)("p",null,"Relay holds a local in-memory store of normalized GraphQL data, which accumulates data as GraphQL queries are made throughout usage of our app; think of it as a local database of GraphQL data. When records are updated, any components affected by the updated data will be notified and re-rendered with the updated data."),Object(i.b)("p",null,"In this section, we're going to go over how to update data in the server as well as how to update our local data store accordingly, ensuring that our components are kept in sync with the latest data."),Object(i.b)("h3",{id:"graphql-mutations"},"GraphQL Mutations"),Object(i.b)("p",null,"In GraphQL, data in the server is updated using ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://graphql.org/learn/queries/#mutations"}),"GraphQL Mutations"),". Mutations are ",Object(i.b)("em",{parentName:"p"},"read-write")," server operations, which both modify data in the backend, and allow querying for the modified data from the server in the same request."),Object(i.b)("p",null,"A GraphQL mutation looks very similar to a query, with the exception that it uses the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"mutation"))," keyword:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"\nmutation LikePostMutation($input: LikePostData!) {\n  like_post(data: $input) {\n    post {\n      id\n      viewer_does_like\n      like_count\n    }\n  }\n}\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},'The mutation above modifies the server data to "like" the specified ',Object(i.b)("inlineCode",{parentName:"li"},"Post")," object. The ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"like_post"))," field is the mutation field itself, which takes specific input and will be processed by the server to update the relevant data in the backend."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"strong"},"like_post"))," returns a specific GraphQL type which exposes the data we can query in the mutation response. In this case, we're querying for the ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"updated"))," post object, including the updated ",Object(i.b)("inlineCode",{parentName:"li"},"like_count")," and the updated value for ",Object(i.b)("inlineCode",{parentName:"li"},"viewer_does_like"),", indicating if the current viewer likes the post object.")),Object(i.b)("p",null,"An example of a successful response for the above mutation could look like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'\n{\n  "like_post": {\n    "post": {\n      "id": "post-id",\n      "viewer_does_like": true,\n      "like_count": 1,\n    }\n  }\n}\n\n')),Object(i.b)("p",null,"In Relay, we can declare GraphQL mutations using the ",Object(i.b)("inlineCode",{parentName:"p"},"graphql")," tag too:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nconst {graphql} = require('react-relay');\n\nconst likeMutation = graphql`\n  mutation LikePostMutation($input: LikePostData!) {\n    like_post(data: $input) {\n      post {\n        id\n        viewer_does_like\n        like_count\n      }\n    }\n  }\n`;\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Note that mutations can also reference GraphQL ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#variables"}),"Variables")," in the same way queries or fragments do.")),Object(i.b)("p",null,"In order to ",Object(i.b)("em",{parentName:"p"},"execute")," a mutation against the server in Relay, we can use the ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"useMutation"))," hook."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {LikePostData, LikePostMutation} from 'LikePostMutation.graphql';\n\nconst {graphql, useMutation} = require('react-relay/hooks');\n\ntype Props = {|\n  likePostData: LikePostData,\n|};\nfunction LikeButton(props: Props) {\n  const [commit, isInFlight] = useMutation<LikePostMutation>(graphql`\n    mutation LikePostMutation($input: LikePostData!)\n      like_post(data: $input) {\n        post {\n          id\n          viewer_does_like\n          like_count\n        }\n      }\n    }\n  `);\n\n  const mutationConfig = {\n    variables: {\n      input: props.likePostData,\n    },\n  };\n\n  return (\n    <Button disabled={isInFlight} onClick={() => commit(mutationConfig)}>\n      Like\n    </Button>\n  );\n}\n\nmodule.exports = LikeButton;\n\n")),Object(i.b)("p",null,"Let's distill what's happening here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"useMutation")," takes a mutation ",Object(i.b)("inlineCode",{parentName:"li"},"GraphQLTaggedNode")," (the result of using the ",Object(i.b)("inlineCode",{parentName:"li"},"graphql")," template tag), and an optional ",Object(i.b)("inlineCode",{parentName:"li"},"commitMutationFn"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"useMutation")," returns ",Object(i.b)("inlineCode",{parentName:"li"},"[commit, isInFlight]: [(UseMutationConfig<TMutation>) => Disposable, boolean]"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"isInFlight")," will be true if any mutation triggered by calling ",Object(i.b)("inlineCode",{parentName:"li"},"commit")," is still in flight. If you call ",Object(i.b)("inlineCode",{parentName:"li"},"commit")," multiple times, there can be multiple mutations in flight at once."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"commit")," is a function that accepts a ",Object(i.b)("inlineCode",{parentName:"li"},"UseMutationConfig"),". The type of ",Object(i.b)("inlineCode",{parentName:"li"},"UseMutationConfig")," is as follows:")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\ntype UseMutationConfig<TMutation: MutationParameters> = {|\n  configs?: Array<DeclarativeMutationConfig>,\n  onError?: ?(error: Error) => void,\n  onCompleted?: ?(\n    response: $ElementType<TMutation, 'response'>,\n    errors: ?Array<PayloadError>,\n  ) => void,\n  onUnsubscribe?: ?() => void,\n  optimisticResponse?: $ElementType<\n    {\n      +rawResponse?: {...},\n      ...TMutation,\n      ...\n    },\n    'rawResponse',\n  >,\n  optimisticUpdater?: ?SelectorStoreUpdater,\n  updater?: ?SelectorStoreUpdater,\n  uploadables?: UploadableMap,\n  variables: $ElementType<TMutation, 'variables'>,\n|};\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The only required property in the ",Object(i.b)("inlineCode",{parentName:"li"},"UseMutationConfig")," object is ",Object(i.b)("inlineCode",{parentName:"li"},"variables"),", which is an object containing the parameters to the mutation."),Object(i.b)("li",{parentName:"ul"},"You can also include ",Object(i.b)("inlineCode",{parentName:"li"},"onCompleted")," and ",Object(i.b)("inlineCode",{parentName:"li"},"onError")," callbacks, which are called when the mutation completes or errors out, respectively."),Object(i.b)("li",{parentName:"ul"},"Note that the input for the mutation can be Flow typed with the autogenerated type available from the ",Object(i.b)("inlineCode",{parentName:"li"},"LikePostMutation.graphql")," module. In general, the Relay will generate Flow types for mutations at build time, with the following naming format: ",Object(i.b)("inlineCode",{parentName:"li"},"<mutation_name>.graphql.js"),"."),Object(i.b)("li",{parentName:"ul"},"Note that ",Object(i.b)("inlineCode",{parentName:"li"},"variables")," and ",Object(i.b)("inlineCode",{parentName:"li"},"response")," in ",Object(i.b)("inlineCode",{parentName:"li"},"onComplete")," will be typed altogether by providing the autogenerated type ",Object(i.b)("inlineCode",{parentName:"li"},"LikePostMutation")," to ",Object(i.b)("inlineCode",{parentName:"li"},"useMutation")," from the ",Object(i.b)("inlineCode",{parentName:"li"},"LikePostMutation.graphql")," module."),Object(i.b)("li",{parentName:"ul"},"When the mutation response is received, ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"if the objects in the mutation response have IDs, the records in the local store will automatically be updated with the new field values from the response")),". In this case, it would automatically find the existing ",Object(i.b)("inlineCode",{parentName:"li"},"Post")," object matching the given ID in the store, and update the values for its ",Object(i.b)("inlineCode",{parentName:"li"},"viewer_does_like")," and ",Object(i.b)("inlineCode",{parentName:"li"},"like_count")," fields."),Object(i.b)("li",{parentName:"ul"},"Note that any local data updates caused by the mutation will automatically cause components subscribed to the data to be notified of the change and re-render."),Object(i.b)("li",{parentName:"ul"},"Calling ",Object(i.b)("inlineCode",{parentName:"li"},"commit")," results in a call to ",Object(i.b)("inlineCode",{parentName:"li"},"commitMutation"),", which you can learn about ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://relay.dev/docs/en/experimental/api-reference#commitMutation"}),"here"),".")),Object(i.b)("h4",{id:"updater-functions"},"Updater functions"),Object(i.b)("p",null,"However, if the updates you wish to perform on the local data in response to the mutation are more complex than just updating the values of fields, like deleting or creating new records, or ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#adding-and-removing-items-from-a-connection"}),"Adding and Removing Items From a Connection"),", you can provide an ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"updater"))," function to ",Object(i.b)("inlineCode",{parentName:"p"},"commit")," for full control over how to update the store:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\nimport type {LikePostData, LikePostMutation} from 'LikePostMutation.graphql';\n\nconst {graphql, useMutation} = require('react-relay/hooks');\n\ntype Props = {|\n  likePostData: LikePostData,\n|};\nfunction LikeButton(props: Props) {\n  const [commit, isInFlight] = useMutation<LikePostMutation>(graphql`\n    mutation LikePostMutation($input: LikePostData!) {\n      like_post(data: $input) {\n        post {\n          id\n          viewer_does_like\n          like_count\n        }\n      }\n    }\n  `);\n\n  const mutationConfig = {\n    variables: {\n      input: props.likePostData,\n    },\n    updater: store => {\n      const postRecord = store.get(postID);\n\n      // Get connection record\n      const connectionRecord = ConnectionHandler.getConnection(\n        postRecord,\n        'CommentsComponent_comments_connection',\n      );\n\n      // Get the payload returned from the server\n      const payload = store.getRootField('comment_create');\n\n      // Get the edge inside the payload\n      const serverEdge = payload.getLinkedRecord('comment_edge');\n\n      // Build edge for adding to the connection\n      const newEdge = ConnectionHandler.buildConnectionEdge(\n        store,\n        connectionRecord,\n        serverEdge,\n      );\n\n      // Add edge to the end of the connection\n      ConnectionHandler.insertEdgeAfter(\n        connectionRecord,\n        newEdge,\n      );\n    },\n  };\n\n  return (\n    <Button disabled={isInFlight} onClick={() => commit(mutationConfig)}>\n      Like\n    </Button>\n  );\n}\n\nmodule.exports = LikeButton;\n\n")),Object(i.b)("p",null,"Let's distill this example:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"updater")," takes a ",Object(i.b)("em",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"em"},"store"))," argument, which is an instance of a ",Object(i.b)("inlineCode",{parentName:"li"},"[RecordSourceSelectorProxy](https://relay.dev/docs/en/relay-store.html#recordsourceselectorproxy)"),";  this interface allows you to ",Object(i.b)("em",{parentName:"li"},"imperatively")," write and read data directly to and from the Relay store. This means that you have full control over how to update the store in response to the mutation response: you can ",Object(i.b)("em",{parentName:"li"},"create entirely new records"),", or ",Object(i.b)("em",{parentName:"li"},"update or delete existing ones"),". The full API for reading and writing to the Relay store is available here: https:"),Object(i.b)("li",{parentName:"ul"},"In our specific example, we're adding a new comment to our local store after it has successfully been added on the server. Specifically, we're adding a new item to a connection; for more details on the specifics of how that works, check out our ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#adding-and-removing-items-from-a-connection"}),"Adding and Removing Items From a Connection")," section."),Object(i.b)("li",{parentName:"ul"},"Note that the mutation response is a ",Object(i.b)("em",{parentName:"li"},"root field")," record that can be read from the ",Object(i.b)("inlineCode",{parentName:"li"},", specifically using the ")," API. In our case, we're reading the `` root field, which is a root field in the mutation response."),Object(i.b)("li",{parentName:"ul"},"Note that any local data updates caused by the mutation `` will automatically cause components subscribed to the data to be notified of the change and re-render.")),Object(i.b)("h4",{id:"optimistic-updates"},"Optimistic updates"),Object(i.b)("p",null,"Often times when executing a mutation we don't want to wait for the server response to complete before we respond to user interaction. For example, if a user clicks the \"Like\" button, we don't want to wait until the mutation response comes back before we show them that the post has been liked; ideally, we'd do that instantly."),Object(i.b)("p",null,"More generally, in these cases we want to immediately update our local data ",Object(i.b)("em",{parentName:"p"},"optimistically"),", in order to improve perceived responsiveness; that is, we want to update our local data to immediately reflect what it would look like after the mutation ",Object(i.b)("em",{parentName:"p"},"succeeds"),". If the mutation ends up ",Object(i.b)("em",{parentName:"p"},"not")," succeeding, we can roll back the change and show an error message, but we're ",Object(i.b)("em",{parentName:"p"},"optimistically")," expecting the mutation to succeed most of the time."),Object(i.b)("p",null,"In order to do this, Relay provides 2 APIs to specify an optimistic update when executing a mutation:"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},Object(i.b)("strong",{parentName:"em"},"Optimistic Response"))),Object(i.b)("p",null,"When you can predict what the server response for a mutation is going to be, the simplest way to optimistically update the store is by providing an ",Object(i.b)("strong",{parentName:"p"},"``")," to ``:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n\n\n")),Object(i.b)("p",null,"Let's see what's happening in this example."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The ",Object(i.b)("inlineCode",{parentName:"li"},"is an object matching the shape of the mutation response, and it simulates a successful response from the server. When"),", is provided, Relay will automatically process the response in the same way it would process the response from the server, and update the data accordingly (i.e. update the values of fields for the record with the matching id).",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"In this case, we would immediately set the ",Object(i.b)("inlineCode",{parentName:"li"},"field to")," in our `` object, which would be immediately reflected in our UI."))),Object(i.b)("li",{parentName:"ul"},"If the mutation ",Object(i.b)("em",{parentName:"li"},"succeeds"),", ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"the optimistic update will be rolled back,"))," and the server response will be applied."),Object(i.b)("li",{parentName:"ul"},"If the mutation ",Object(i.b)("em",{parentName:"li"},"fails"),", ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"the optimistic update will be rolled back,"))," and the error will be communicated via the `` callback."),Object(i.b)("li",{parentName:"ul"},"Note that by adding ",Object(i.b)("inlineCode",{parentName:"li"},"directive,  the type for")," is generated , and the flow type is applied by: ``.")),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},Object(i.b)("strong",{parentName:"em"},"Optimistic Updater"))),Object(i.b)("p",null,"However, in some cases we can't statically predict what the server response will be, or we need to optimistically perform more complex updates, like deleting or creating new records, or ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#adding-and-removing-items-from-a-connection"}),"Adding and Removing Items From a Connection"),". In these cases we can provide an ",Object(i.b)("strong",{parentName:"p"},"``")," function to ",Object(i.b)("inlineCode",{parentName:"p"},". For example, we can rewrite the above example using an ")," instead of an ``:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n\n\n")),Object(i.b)("p",null,"Let's see what's happening here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The ",Object(i.b)("inlineCode",{parentName:"li"},"has the same signature and behaves the same way as the regular")," function, the main difference being that it will be executed immediately, before the mutation response completes."),Object(i.b)("li",{parentName:"ul"},"If the mutation succeeds, ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"the optimistic update will be rolled back,"))," and the server response will be applied.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Note that if we used an ",Object(i.b)("inlineCode",{parentName:"li"},", we wouldn't be able to statically provide a value for "),", since it requires reading the current value from the store first, which we can do with an ``."),Object(i.b)("li",{parentName:"ul"},'Also note that when mutation completes, the value from the server might differ from the value we optimistically predicted locally. For example, if other "Likes" occurred at the same time, the final `` from the server might\'ve incremented by more than 1.'))),Object(i.b)("li",{parentName:"ul"},"If the mutation ",Object(i.b)("em",{parentName:"li"},"fails"),", ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"the optimistic update will be rolled back,"))," and the error will be communicated via the `` callback."),Object(i.b)("li",{parentName:"ul"},"Note that we're not providing an ",Object(i.b)("inlineCode",{parentName:"li"},"function, which is okay. If it's not provided, the default behavior will still be applied when the server response arrives (i.e. merging the new field values for")," and ",Object(i.b)("inlineCode",{parentName:"li"},"on the")," object).")),Object(i.b)("p",null,"NOTE: Remember that any updates to local data caused by a mutation will automatically notify and re-render components subscribed to that data."),Object(i.b)("h4",{id:"order-of-execution-of-updater-functions"},"Order of Execution of Updater Functions"),Object(i.b)("p",null,"In general, execution of the `` and optimistic updates will occur in the following order:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"If an ",Object(i.b)("inlineCode",{parentName:"li"},"is provided, Relay will use it to merge the new field values for the records that match the ids in the"),"."),Object(i.b)("li",{parentName:"ul"},"If `` is provided, Relay will execute it and update the store accordingly."),Object(i.b)("li",{parentName:"ul"},"If the mutation request succeeds:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Any optimistic update that was applied will be rolled back."),Object(i.b)("li",{parentName:"ul"},"Relay will use the server response to merge the new field values for the records that match the ids in the response."),Object(i.b)("li",{parentName:"ul"},"If an ",Object(i.b)("inlineCode",{parentName:"li"},"was provided, Relay will execute it and update the store accordingly. The server payload will be available to the")," as a root field in the store."))),Object(i.b)("li",{parentName:"ul"},"If the mutation request fails:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Any optimistic update was applied will be rolled back."),Object(i.b)("li",{parentName:"ul"},"The `` callback will be called.")))),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},Object(i.b)("strong",{parentName:"em"},"Full Example"))),Object(i.b)("p",null,"This means that in more complicated scenarios you can still provide all 3 options: ",Object(i.b)("inlineCode",{parentName:"p"},", ")," and ``. For example, the mutation to add a new comment could be like something like the following (for full details on updating connections, check out our ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#adding-and-removing-items-from-a-connection"}),"Adding and Removing Items From a Connection")," guide):"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n\n\n")),Object(i.b)("p",null,"Let's distill this example, according to the execution order of the updaters:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Given that an ",Object(i.b)("inlineCode",{parentName:"li"},"was provided, it will be executed _first_. This will cause the new value of")," to be merged into the existing ",Object(i.b)("inlineCode",{parentName:"li"},"object, setting it to"),"."),Object(i.b)("li",{parentName:"ul"},"Given that an ",Object(i.b)("inlineCode",{parentName:"li"},"was provided, it will be executed next. Our")," will create new comment and edge records from scratch, simulating what the new edge in the server response would look like, and then add the new edge to the connection."),Object(i.b)("li",{parentName:"ul"},"When the optimistic updates conclude, components subscribed to this data will be notified."),Object(i.b)("li",{parentName:"ul"},"When the mutation succeeds, all of our optimistic updates will be rolled back."),Object(i.b)("li",{parentName:"ul"},"The server response will be processed by Relay, and this will cause the new value of ",Object(i.b)("inlineCode",{parentName:"li"},"to be merged into the existing")," object, setting it to ``."),Object(i.b)("li",{parentName:"ul"},"Finally, the ",Object(i.b)("inlineCode",{parentName:"li"},"function we provided will be executed. The")," function is very similar to the `` function, however, instead of creating the new data from scratch, it reads it from the mutation payload and adds the new edge to the connection.")),Object(i.b)("h4",{id:"invalidating-data-during-a-mutation"},"Invalidating Data during a Mutation"),Object(i.b)("p",null,"The recommended approach when executing a mutation is to request ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"all"))," the relevant data that was affected by the mutation back from the server (as part of the mutation body), so that our local Relay store is consistent with the state of the server."),Object(i.b)("p",null,"However, often times it can be unfeasible to know and specify all the possible data that would be affected for mutations that have large rippling effects (e.g. imagine \u201cblocking a user\u201d or \u201cleaving a group\u201d)."),Object(i.b)("p",null,"For these types of mutations, it\u2019s often more straightforward to explicitly mark some data as stale (or the whole store), so that Relay knows to refetch it the next time it is rendered. In order to do so, you can use the data invalidation apis documented in our ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#staleness-of-data"}),"Staleness of Data section"),"."),Object(i.b)("h4",{id:"mutation-queueing"},"Mutation Queueing"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"TODO:")," Left to be implemented in user space"),Object(i.b)("h3",{id:"graphql-subscriptions"},"GraphQL Subscriptions"),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://graphql.org/blog/subscriptions-in-graphql-and-relay/"}),"GraphQL Subscriptions")," (GQLS) are a mechanism which allows clients to subscribe to changes in a piece of data from the server, and get notified whenever that data changes."),Object(i.b)("p",null,"A GraphQL Subscription looks very similar to a query, with the exception that it uses the subscription keyword:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"\n\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Subscribing to the above subscription will notify the client whenever the specified ",Object(i.b)("inlineCode",{parentName:"li"},' object has been "liked" or "unliked". The **'),"** field is the subscription field itself, which takes specific input and will set up the subscription in the backend."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"``")," returns a specific GraphQL type which exposes the data we can query in the subscription payload; that is, whenever the client is notified, it will receive the subscription payload in the notification. In this case, we're querying for the Post object with it's ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"updated"))," ``, which will allows us to show the like count in real time.")),Object(i.b)("p",null,"An example of a subscription payload received by the client could look like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n\n\n")),Object(i.b)("p",null,"In Relay, we can declare GraphQL subcriptions using the `` tag too:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Note that subscriptions can also reference GraphQL ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#variables"}),"Variables")," in the same way queries or fragments do.")),Object(i.b)("p",null,"In order to ",Object(i.b)("em",{parentName:"p"},"execute")," a subscription against the server in Relay, we can use the ",Object(i.b)("strong",{parentName:"p"},"``")," hook:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n\n\n")),Object(i.b)("p",null,"Let's distill what's happening here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"`` takes a config object containing the subscription and the variables that the GraphQL query expects."),Object(i.b)("li",{parentName:"ul"},"Note that the ",Object(i.b)("inlineCode",{parentName:"li"},"for the subscription can be Flow typed with the autogenerated type available from the")," module. In general, the Relay will generate Flow types for subscriptions at build time, with the following naming format: ``."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"also take")," and `` callbacks, which will be called respectively when the subscription is successfully established, or when an error occurs."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"also takes an")," callback, which will be called whenever a subscription payload is received."),Object(i.b)("li",{parentName:"ul"},"When the subscription payload is received, ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"if the objects in the subscription payload have IDs, the records in the local store will _automatically")," be updated with the new field values from the payload._")," In this case, it would automatically find the existing ",Object(i.b)("inlineCode",{parentName:"li"},"object matching the given ID in the store, and update the values for the")," field."),Object(i.b)("li",{parentName:"ul"},"Note that any local data updates caused by the subscription will automatically cause components subscribed to the data to be notified of the change and re-render.")),Object(i.b)("p",null,"However, if the updates you wish to perform on the local data in response to the subscription are more complex than just updating the values of fields, like deleting or creating new records, or ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#adding-and-removing-items-from-a-connection"}),"Adding and Removing Items From a Connection"),", you can provide an ",Object(i.b)("inlineCode",{parentName:"p"}," function to **"),"** for full control over how to update the store:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n\n\n")),Object(i.b)("p",null,"Let's distill this example:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"}," takes a _"),Object(i.b)("em",{parentName:"li"}," argument, which is an instance of a ``;  this interface allows you to _imperatively")," write and read data directly to and from the Relay store. This means that you have full control over how to update the store in response to the subscription payload: you can ",Object(i.b)("em",{parentName:"li"},"create entirely new records"),", or ",Object(i.b)("em",{parentName:"li"},"update or delete existing ones"),". The full API for reading and writing to the Relay store is available here:"),Object(i.b)("li",{parentName:"ul"},"In our specific example, we're adding a new comment to our local store when we receive a subscription payload notifying us that a new comment has been created. Specifically, we're adding a new item to a connection; for more details on the specifics of how that works, check out our ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#adding-and-removing-items-from-a-connection"}),"Adding and Removing Items From a Connection")," section."),Object(i.b)("li",{parentName:"ul"},"Note that the subscription payload is a ",Object(i.b)("em",{parentName:"li"},"root field")," record that can be read from the ",Object(i.b)("inlineCode",{parentName:"li"},", specifically using the ")," API. In our case, we're reading the `` root field, which is a root field in the subscription response."),Object(i.b)("li",{parentName:"ul"},"Note that any local data updates caused by the mutation `` will automatically cause components subscribed to the data to be notified of the change and re-render.")),Object(i.b)("h3",{id:"local-data-updates"},"Local Data Updates"),Object(i.b)("p",null,"There are a couple of APIs that Relay provides in order to make purely local updates to the Relay store (i.e. updates not tied to a server operation)."),Object(i.b)("p",null,"Note that local data updates can be made both on ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#client-only-data-client-schema-extensions"}),"client-only data"),", or on regular data that was fetched from the server via an operation."),Object(i.b)("h4",{id:"commitlocalupdate"},"commitLocalUpdate"),Object(i.b)("p",null,"To make updates using an ",Object(i.b)("inlineCode",{parentName:"p"}," function, you can use the **"),"** API:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"`` update simply takes an environment and an updater function.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"}," takes a _"),Object(i.b)("em",{parentName:"li"}," argument, which is an instance of a ``;  this interface allows you to _imperatively")," write and read data directly to and from the Relay store. This means that you have full control over how to update the store: you can ",Object(i.b)("em",{parentName:"li"},"create entirely new records"),", or ",Object(i.b)("em",{parentName:"li"},"update or delete existing ones"),". The full API for reading and writing to the Relay store is available here:"))),Object(i.b)("li",{parentName:"ul"},"In our specific example, we're adding a new comment to our local store when. Specifically, we're adding a new item to a connection; for more details on the specifics of how that works, check out our ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#adding-and-removing-items-from-a-connection"}),"Adding and Removing Items From a Connection")," section."),Object(i.b)("li",{parentName:"ul"},"Note that any local data updates will automatically cause components subscribed to the data to be notified of the change and re-render.")),Object(i.b)("h4",{id:"commitpayload"},"commitPayload"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"``")," takes an `` and the payload for the query, and writes it to the Relay Store. The payload will be resolved like a normal server response for a query."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"An ",Object(i.b)("inlineCode",{parentName:"li"},"can be created by using"),"; it takes the query and the query variables."),Object(i.b)("li",{parentName:"ul"},"The payload can be typed using the Flow type generated by adding  @raw_response_type to the query."),Object(i.b)("li",{parentName:"ul"},"Note that any local data updates will automatically cause components subscribed to the data to be notified of the change and re-render.")),Object(i.b)("h3",{id:"client-only-data-client-schema-extensions"},"Client-Only Data (Client Schema Extensions)"),Object(i.b)("p",null,"Relay provides the ability to extend the GraphQL schema ",Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"on the client"))," (i.e. in the browser), via client schema extensions, in order to model data that only needs to be created, read and updated on the client. This can be useful to add small pieces of information to data that is fetched from the server, or to entirely model client-specific state to be stored and managed by Relay."),Object(i.b)("p",null,"Client schema extensions allows you to modify existing types on the schema (e.g. by adding new fields to a type), or to create entirely new types that only exist in the client."),Object(i.b)("h4",{id:"adding-a-client-schema-file"},"Adding a Client Schema file"),Object(i.b)("p",null,"To add a client schema, create a new `` file inside your src directory. The file can be named anything."),Object(i.b)("h4",{id:"extending-existing-types"},"Extending Existing Types"),Object(i.b)("p",null,"In order to extend an existing type, add a `` file to the appropriate schema extension file:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"\n\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"In this example, we're using the ",Object(i.b)("strong",{parentName:"li"},"``")," keyword to extend an existing type, and we're adding a new field, ",Object(i.b)("inlineCode",{parentName:"li"},"to the existing")," type, which we will be able to ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#reading-client-only-data"}),"read")," in our components, and ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#updating-client-only-data"}),"update")," when necessary using normal Relay APIs; you might imagine that we might use this field to render a different visual treatment for a comment if it's new, and we might set it when creating a new comment."),Object(i.b)("li",{parentName:"ul"},"Note that in order for Relay to pick up this extension, the file needs to be inside your src directory. The file can be named anything, e.g.: ``.")),Object(i.b)("h4",{id:"adding-new-types"},"Adding New Types"),Object(i.b)("p",null,"You can define types using the same regular GraphQL syntax, by defining it inside your client schema file:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"\n\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"In this contrived example, we're defining 2 new client-only types, and ",Object(i.b)("inlineCode",{parentName:"li"},"and a regular"),". Note that they can reference themselves as normal, and reference regular server defined types. Also note that we can extend server types and add fields that are of our client-only types."),Object(i.b)("li",{parentName:"ul"},"As mentioned previously, we will be able  ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#reading-client-only-data"}),"read")," and ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#updating-client-only-data"}),"update")," this data normally via Relay APIs.")),Object(i.b)("h4",{id:"reading-client-only-data"},"Reading Client-Only Data"),Object(i.b)("p",null,"We can read client-only data by selecting it inside ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#fragments"}),"fragments")," or ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#queries"}),"queries")," as normal:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n\n\n")),Object(i.b)("h4",{id:"updating-client-only-data"},"Updating Client-Only Data"),Object(i.b)("p",null,"In order to update client-only data, you can do so regularly inside ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#graphql-mutations"}),"mutation")," or ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#graphql-subscriptions"}),"subscription")," updaters, or by using our primitives for doing ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#local-data-updates"}),"local updates")," to the store."),Object(i.b)("h2",{id:"local-application-state-management"},"Local Application State Management"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"TODO")),Object(i.b)("p",null,"Roughly, at a high level:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Read data from Relay"),Object(i.b)("li",{parentName:"ol"},"Keep your state in React, possibly derive it from Relay data"),Object(i.b)("li",{parentName:"ol"},"Write data back to Relay via mutations or local update")),Object(i.b)("h2",{id:"accessing-data-outside-react"},"Accessing Data Outside React"),Object(i.b)("p",null,"This section covers less common use cases, which involve fetching and accessing data outside of our React APIs. Most of the time you will be directly using our React APIs, so you don't need to know this to start building with Relay. However, these APIs can be useful for more advanced use cases when you need more control over how data is fetched and managed, for example when writing pieces of infrastructure on top of Relay."),Object(i.b)("h3",{id:"fetching-queries"},"Fetching Queries"),Object(i.b)("p",null,"If you want to fetch a query outside of React, you can use the ",Object(i.b)("strong",{parentName:"p"},"``")," function, which returns an observable:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"`` will automatically save the fetched data to the in-memory Relay store, and notify any components subscribed to the relevant data."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"will **_NOT_** retain the data for the query, meaning that it is not guaranteed that the data will remain saved in the Relay store at any point after the request completes. If you wish to make sure that the data is retained outside of the scope of the request, you need to call")," directly on the query to ensure it doesn't get deleted. See ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#retaining-queries"}),"Retaining Queries")," for more details."),Object(i.b)("li",{parentName:"ul"},"The data provided in the `` callback represents a snapshot of the query data read from the Relay store at the moment a payload was received from the server."),Object(i.b)("li",{parentName:"ul"},"Note that we specify the ",Object(i.b)("inlineCode",{parentName:"li"},"Flow type; this ensures that the type of the data provided by the observable matches the shape of the query, and enforces that the")," passed as input to `` match the type of the variables expected by the query.")),Object(i.b)("p",null,"If desired, you can convert the request into a Promise using ",Object(i.b)("strong",{parentName:"p"},"``"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The returned Promise that resolves to the query data, read out from the store when the first network response is received from the server. If the request fails, the promise will reject"),Object(i.b)("li",{parentName:"ul"},"Note that we specify the ",Object(i.b)("inlineCode",{parentName:"li"},"Flow type; this ensures that the type of the data the promise will resolve to matches the shape of the query, and enforces that the")," passed as input to `` match the type of the variables expected by the query.")),Object(i.b)("p",null,"See also our API Reference for ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"./api-reference#fetchquery"}),"fetchQuery"),"."),Object(i.b)("h3",{id:"prefetching-queries"},"Prefetching Queries"),Object(i.b)("p",null,"This section covers prefetching queries from the client (if you're interested in preloading for initial load or transitions,  see our ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#preloading-data"}),"Preloading Data")," section). Prefetching queries can be useful to anticipate user actions and increase the likelihood of data being immediately available when the user requests it."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"TODO")),Object(i.b)("h3",{id:"subscribing-to-queries"},"Subscribing to Queries"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"TODO")),Object(i.b)("h3",{id:"reading-queries-from-local-cache"},"Reading Queries from Local Cache"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"TODO")),Object(i.b)("h3",{id:"reading-fragments-from-local-cache"},"Reading Fragments from Local Cache"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"TODO")),Object(i.b)("h3",{id:"retaining-queries"},"Retaining Queries"),Object(i.b)("p",null,"In order to manually retain a query so that the data it references isn't garbage collected by Relay, we can use the ",Object(i.b)("strong",{parentName:"p"},"``")," method:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"\n\n\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"NOTE:")," Relay automatically manages the query data retention based on any mounted query components that are rendering the data, so","*"," you usually should ",Object(i.b)("strong",{parentName:"li"},Object(i.b)("em",{parentName:"strong"},"not"))," need to call `` directly within product code. For any advanced or special use cases, query data retention should usually be handled within infra-level code, such as a Router.")),Object(i.b)("h2",{id:"testing"},"Testing"),Object(i.b)("p",null,"See this guide for ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://relay.dev/docs/en/testing-relay-components"}),"Testing Relay Components"),", which also applies for any components built using Relay Hooks."))}d.isMDXComponent=!0}}]);