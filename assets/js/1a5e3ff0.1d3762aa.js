"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["72023"],{12057(e,t,n){n.r(t),n.d(t,{metadata:()=>a,default:()=>u,frontMatter:()=>h,contentTitle:()=>o,toc:()=>l,assets:()=>c});var a=JSON.parse('{"id":"tutorial/refetchable-fragments","title":"Refetchable Fragments","description":"In this section, we\'ll look at how to fetch different data in response to user input.","source":"@site/versioned_docs/version-v14.0.0/tutorial/refetchable-fragments.md","sourceDirName":"tutorial","slug":"/tutorial/refetchable-fragments","permalink":"/docs/v14.0.0/tutorial/refetchable-fragments","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v14.0.0/tutorial/refetchable-fragments.md","tags":[],"version":"v14.0.0","frontMatter":{},"sidebar":"docs","previous":{"title":"Interfaces & Polymorphism","permalink":"/docs/v14.0.0/tutorial/interfaces-polymorphism"},"next":{"title":"Connections & Pagination","permalink":"/docs/v14.0.0/tutorial/connections-pagination"}}'),r=n(74848),s=n(28453),i=n(17352);let h={},o="Refetchable Fragments",c={},l=[{value:"Step 1 \u2014 Add a fragment argument",id:"step-1--add-a-fragment-argument",level:3},{value:"Step 2 \u2014 Pass the fragment argument as a field argument",id:"step-2--pass-the-fragment-argument-as-a-field-argument",level:3},{value:"Step 3 \u2014 Add the @refetchable directive",id:"step-3--add-the-refetchable-directive",level:3},{value:"Step 4 \u2014 Add the search input",id:"step-4--add-the-search-input",level:3},{value:"Step 5 \u2014 Call useRefetchableFragment",id:"step-5--call-userefetchablefragment",level:3},{value:"Step 6 \u2014 Control loading with useTransition",id:"step-6--control-loading-with-usetransition",level:3},{value:"Summary",id:"summary",level:2}];function d(e){let t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:a}=t;return a||function(e,t){throw Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"refetchable-fragments",children:"Refetchable Fragments"})}),"\n",(0,r.jsx)(t.p,{children:"In this section, we'll look at how to fetch different data in response to user input."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["We'll build a ",(0,r.jsx)(t.strong,{children:"filterable friends list"}),"."]}),"\n",(0,r.jsx)(t.li,{children:"We'll see how to refetch only the necessary data, not an entire query."}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.p,{children:"Since Relay encourages you to fetch all of your data in one big query, what happens when you need to refetch some data with different variables?"}),"\n",(0,r.jsx)(t.p,{children:"For example, suppose you were building a filterable list. You would need to fetch new search results when the search input changed."}),"\n",(0,r.jsx)(t.p,{children:"One way to approach this would be to use a separate, secondary query to fetch the list, much like we did to fetch the hovercard earlier. Then we could change the query variables and refetch the query when the input changed."}),"\n",(0,r.jsxs)(t.p,{children:["However, this isn't optimal, because it needlessly uses a second query to fetch the ",(0,r.jsx)(t.em,{children:"initial"})," list, before any user input occurs. The hovercard only appeared in response to a user interaction, but if the filterable list is visible and ready to be filtered, we might as well get its initial contents as part of our big query."]}),"\n",(0,r.jsxs)(t.p,{children:["On the other hand, we don't want to refetch the ",(0,r.jsx)(t.em,{children:"entire big query"})," whenever the input changes. Not only would this mean retrieving a large amount of data unnecessarily, it could disrupt other parts of the UI. If certain data unrelated to the filterable list has changed on the server, it would appear to randomly change when the query was refetched. Besides, this would mean threading the user input up to the top of the React tree where the query lives, which would not scale very well."]}),"\n",(0,r.jsxs)(t.p,{children:["To address these issues, Relay provides ",(0,r.jsx)(t.em,{children:"refetchable fragments"}),". These are fragments that can be refetched with new variables, separately from the rest of the query that they get spread into. They allow us to change a fragment\u2019s arguments and fetch new data for the new argument values, just as we can fetch an entire query with new query variables."]}),"\n",(0,r.jsxs)(t.p,{children:["But fragments are just that, fragments \u2014 they aren\u2019t queries and can\u2019t be fetched without being spread into a query and read out from the query results. So how do refetchable fragments actually work? The answer is that the Relay compiler generates a new, separate query just to refetch the fragment. The data is retrieved ",(0,r.jsx)(t.em,{children:"initially"})," as part of whatever larger query the fragment is spread into, but then when it\u2019s refetched, the new synthetic query is used."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.p,{children:"To try this out, let's add a sidebar to the page with a filterable contacts list. After all, it wouldn't feel like a properly cozy newsfeed app without the ability to contact people."}),"\n",(0,r.jsxs)(t.p,{children:["We've already prepared a ",(0,r.jsx)(t.code,{children:"Sidebar"})," component, you just need to drop it into ",(0,r.jsx)(t.code,{children:"App.tsx"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"// change-line\nimport Sidebar from './Sidebar';\n\nexport default function App(): React.ReactElement {\n  return (\n    <RelayEnvironment>\n      <React.Suspense fallback={<LoadingSpinner />}>\n        <div className=\"app\">\n          <Newsfeed />\n          // change-line\n          <Sidebar />\n        </div>\n      </React.Suspense>\n    </RelayEnvironment>\n  );\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"You should now see a sidebar with a list of people at the top."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Contacts list",src:n(21388).A+"",width:"702",height:"1436"})}),"\n",(0,r.jsxs)(t.p,{children:["Have a look at ",(0,r.jsx)(t.code,{children:"ContactsList.tsx"})," and you\u2019ll find this fragment, which is what selects the list of contacts:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"const ContactsListFragment = graphql`\n  fragment ContactsListFragment on Viewer {\n    contacts {\n      id\n      ...ContactRowFragment\n    }\n  }\n`;\n"})}),"\n",(0,r.jsxs)(t.p,{children:["As it happens, the ",(0,r.jsx)(t.code,{children:"contacts"})," field accepts a ",(0,r.jsx)(t.code,{children:"search"})," argument that filters the list. You can try it out by changing ",(0,r.jsx)(t.code,{children:"contacts"})," in this fragment to ",(0,r.jsx)(t.code,{children:'contacts(search: "S")'}),". If you refresh the page, you should see only those contacts that have the letter S in them."]}),"\n",(0,r.jsxs)(t.p,{children:["Our goal, then, will be to hook up a search input so that, when the input changes, we refetch ",(0,r.jsx)(t.em,{children:"just this fragment"})," with a new value for that ",(0,r.jsx)(t.code,{children:"search"})," argument."]}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["As an optional exercise, try combining the queries of Sidebar and Newsfeed into a single query. There is no need for Sidebar to have its own query separate from Newsfeed; in a real app they would both have fragments and the ",(0,r.jsx)(t.em,{children:"entire screen"})," would have only a single query. We built it with a separate query to simplify the early examples in the tutorial."]})}),"\n",(0,r.jsx)(t.h3,{id:"step-1--add-a-fragment-argument",children:"Step 1 \u2014 Add a fragment argument"}),"\n",(0,r.jsx)(t.p,{children:"First we need to make this fragment accept an argument. With refetchable fragments, fragment arguments become query variables for the refetch query that Relay generates. (They also work like regular fragment arguments, so the parent query can pass in an initial value for the argument.)"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'const ContactsListFragment = graphql`\n  fragment ContactsListFragment on Viewer\n    // change\n    @argumentDefinitions(\n      search: {type: "String", defaultValue: null}\n    )\n    // end-change\n  {\n    contacts {\n      id\n      ...ContactRowFragment\n    }\n  }\n`;\n'})}),"\n",(0,r.jsx)(t.h3,{id:"step-2--pass-the-fragment-argument-as-a-field-argument",children:"Step 2 \u2014 Pass the fragment argument as a field argument"}),"\n",(0,r.jsxs)(t.p,{children:["Pass the fragment argument in as an argument to the ",(0,r.jsx)(t.code,{children:"contacts"})," field."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'const ContactsListFragment = graphql`\n  fragment ContactsListFragment on Viewer\n    @argumentDefinitions(\n      search: {type: "String", defaultValue: null}\n    )\n  {\n    // change-line\n    contacts(search: $search) {\n      id\n      ...ContactRowFragment\n    }\n  }\n`;\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Remember, the first ",(0,r.jsx)(t.code,{children:"search"})," here is the name of the argument to ",(0,r.jsx)(t.code,{children:"contacts"}),", while the second ",(0,r.jsx)(t.code,{children:"$search"})," is the variable created by our fragment argument."]}),"\n",(0,r.jsx)(t.h3,{id:"step-3--add-the-refetchable-directive",children:"Step 3 \u2014 Add the @refetchable directive"}),"\n",(0,r.jsxs)(t.p,{children:["Next we'll add a ",(0,r.jsx)(t.code,{children:"@refetchable"})," directive. This tells Relay to generate the extra query for refetching it. You have to specify the name of the generated query \u2014 it's a good idea to base it on the name of the fragment."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'const ContactsListFragment = graphql`\n  fragment ContactsListFragment on Viewer\n    // change-line\n    @refetchable(queryName: "ContactsListRefetchQuery")\n    @argumentDefinitions(\n      search: {type: "String", defaultValue: null}\n    )\n  {\n     // ...\n  }\n`;\n'})}),"\n",(0,r.jsx)(t.h3,{id:"step-4--add-the-search-input",children:"Step 4 \u2014 Add the search input"}),"\n",(0,r.jsxs)(t.p,{children:["Now we need to actually hook this up to our UI. Take a look at the ",(0,r.jsx)(t.code,{children:"ContactsList"})," component:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"export default function ContactsList({ viewer }: Props) {\n  const data = useFragment(ContactsListFragment, viewer);\n  return (\n    <Card dim={true}>\n      <h3>Contacts</h3>\n      {data.contacts.map(contact =>\n        <ContactRow key={contact.id} contact={contact} />\n      )}\n    </Card>\n  );\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"First we need to add a search field."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"// change-line\nimport SearchInput from './SearchInput';\n\n// change-line\nconst {useState} = React;\n\nfunction ContactsList({viewer}) {\n  const data = useFragment(ContactsListFragment, viewer);\n  // change-line\n  const [searchString, setSearchString] = useState('');\n  // change\n  const onSearchStringChanged = (value: string) => {\n    setSearchString(value);\n  };\n  // end-change\n  return (\n    <Card dim={true}>\n      <h3>Contacts</h3>\n      // change\n      <SearchInput\n        value={searchString}\n        onChange={onSearchStringChanged}\n      />\n      // end-change\n      {data.contacts.map(contact =>\n        <ContactRow key={contact.id} contact={contact} />\n      )}\n    </Card>\n  );\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"step-5--call-userefetchablefragment",children:"Step 5 \u2014 Call useRefetchableFragment"}),"\n",(0,r.jsxs)(t.p,{children:["Now to refetch the fragment when the string changes, we change ",(0,r.jsx)(t.code,{children:"useFragment"})," to ",(0,r.jsx)(t.code,{children:"useRefetchableFragment"}),". This hook returns a ",(0,r.jsx)(t.code,{children:"refetch"})," function which will refetch the fragment with new variables which we provide as an argument."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"// change-line\nimport {useRefetchableFragment} from 'react-relay';\n\nfunction ContactsList({viewer}) {\n  // change-line\n  const [data, refetch] = useRefetchableFragment(ContactsListFragment, viewer);\n  const [searchString, setSearchString] = useState('');\n  const onSearchStringChanged = (value) => {\n    setSearchString(value);\n    // change-line\n    refetch({search: value});\n  };\n  return (\n    // ...\n  );\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"You\u2019ll notice that Relay gives us a callback for refetching, rather than accepting the new state variables as an argument to the hook and refetching when it is re-rendered  with a different value. This means that the fetch begins as soon as the event takes place, saving some time versus waiting until React finishes re-rendering \u2014 the same principle we saw before with preloaded queries. It also gives us more control, for example if we wanted to debounce the refetch."}),"\n",(0,r.jsx)(t.h3,{id:"step-6--control-loading-with-usetransition",children:"Step 6 \u2014 Control loading with useTransition"}),"\n",(0,r.jsx)(t.p,{children:"At this point, when the fragment is refreshed, Relay uses Suspense while the new data is loading, so the entire component is replaced with a spinner! This makes the UI fairly unusable. We would rather just keep the current data on screen until the new data is available."}),"\n",(0,r.jsx)(t.p,{children:'The way Suspense normally works is this: When a component is missing data that it needs to render (as our component does after we refetch), it tells React to wait. When this happens, React finds the nearest Suspense component in the tree. It then replaces everything under that component with a "fallback" loading indicator.'}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"Component needs data",src:n(45887).A+"",width:"1522",height:"842"}),"\n",(0,r.jsx)(t.img,{alt:"React finds the nearest Suspense point",src:n(75305).A+"",width:"1452",height:"770"}),"\n",(0,r.jsx)(t.img,{alt:"Renders a fallback at that point until the data is available",src:n(11237).A+"",width:"1438",height:"720"})]}),"\n",(0,r.jsx)(t.p,{children:"This makes sense when initially loading a screen, but in this instance there's no reason to hide the existing UI and replace it with a spinner. While React is waiting, it can simply continue showing what's already there."}),"\n",(0,r.jsxs)(t.p,{children:["To achieve this, we can mark the refetch as a ",(0,r.jsx)(t.em,{children:"transition"}),". Transitions are React state updates that do not need to be immediately responded to \u2014 React can wait until the data is available."]}),"\n",(0,r.jsxs)(t.p,{children:["Transitions are marked by wrapping the state change in a call to a function provided by the ",(0,r.jsx)(t.code,{children:"useTransition"})," hook. This is what the code will look like:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"// change-line\nconst {useState, useTransition} = React;\n\nfunction ContactsList({viewer}) {\n  // change-line\n  const [isPending, startTransition] = useTransition();\n  const [searchString, setSearchString] = useState('');\n  const [data, refetch] = useRefetchableFragment(ContactsListFragment, viewer);\n  const onSearchStringChanged = (value) => {\n    setSearchString(value);\n    // change\n    startTransition(() => {\n      refetch({search: value});\n    });\n    // end-change\n  };\n  return (\n    <Card dim={true}>\n      <h3>Contacts</h3>\n      <SearchInput\n        value={searchString}\n        onChange={onSearchStringChanged}\n        // change-line\n        isPending={isPending}\n      />\n      {data.contacts.map(contact =>\n        <ContactRow key={contact.id} contact={contact} />\n      )}\n    </Card>\n  );\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["While React is waiting for the new data, instead of using a Suspense fallback, React re-renders the component with the ",(0,r.jsx)(t.code,{children:"isPending"})," flag set to true."]}),"\n",(0,r.jsxs)(t.p,{children:["We simply pass the ",(0,r.jsx)(t.code,{children:"isPending"})," flag to ",(0,r.jsx)(t.code,{children:"SearchInput"})," (which causes it to show a spinner) while the refetch is happening. Meanwhile, by placing ",(0,r.jsx)(t.code,{children:"setSearchString"})," outside of the transition but ",(0,r.jsx)(t.code,{children:"refetch"})," within it, we tell React to immediately update the search input."]}),"\n",(0,r.jsx)(t.p,{children:"We should now be able to search the contacts list with a nice user experience, showing a spinner but keeping the previous data visible while loading."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Search input goes from spinner to filtered list",src:n(31464).A+"",width:"1966",height:"1194"})}),"\n",(0,r.jsxs)(a,{children:[(0,r.jsx)("summary",{children:"Deep dive: What fragments can be refetched?"}),(0,r.jsx)(t.p,{children:"To refetch fragments, Relay has to know how to generate a query that lets it refetch just the information from the fragment. That\u2019s only possible for fragments that meet certain requirements."}),(0,r.jsx)(t.p,{children:"You might imagine that we could, if nothing else, re-run the original query that the fragment was spread into. However, GraphQL doesn\u2019t guarantee that the same query will return the same results at different times. For instance, imagine you had a GraphQL field that returned the top trending posts across the site:"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"query MyQuery {\n  topTrendingPosts {\n    title\n    summary\n    date\n    poster {\n     ...PosterFragment\n    }\n  }\n}\n"})}),(0,r.jsxs)(t.p,{children:["If you wanted to refresh just ",(0,r.jsx)(t.code,{children:"PosterFragment"})," from this query, it wouldn\u2019t work to construct a query like this:"]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"query MyQuery {\n  topTrendingPosts {\n    poster {\n     ...PosterFragment\n    }\n  }\n}\n"})}),(0,r.jsx)(t.p,{children:"... because the top trending post could be a different post by the time you refresh it!"}),(0,r.jsx)(t.p,{children:"Relay needs a way of identifying the specific node in the graph that the fragment ends up on, even if it can no longer be reached by the same path that the original query uses. If the node has a unique and stable ID, then we can just have a convention for querying for \u201Cthe graph node with some specific ID\u201D like so:"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'query RefetchQuery {\n  node(id: "abcdef") {\n    ...PosterFragment\n  }\n}\n'})}),(0,r.jsxs)(t.p,{children:["In fact, this is exactly the convention that Relay uses. It expects your server to implement a top-level field called ",(0,r.jsx)(t.code,{children:"node"})," that takes an ID and gives you the graph node with that ID. (We saw ",(0,r.jsx)(t.code,{children:"node"})," earlier with the hovercard example \u2014 there it was used to fetch a specific person given their ID using a secondary query.)"]}),(0,r.jsxs)(t.p,{children:["Not every graph node has a stable ID \u2014 some are ephemeral. To be used with ",(0,r.jsx)(t.code,{children:"node"}),", your schema has to declare that its type implements an interface called ",(0,r.jsx)(t.code,{children:"Node"}),":"]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"type Person implements Node {\n  id: ID!\n  ...\n}\n"})}),(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"Node"})," interface simply says it has an ID, but more importantly indicates by convention that that ID is stable and unique:"]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"interface Node {\n  id: ID!\n}\n"})}),(0,r.jsxs)(t.p,{children:["Besides fragments on types that implement ",(0,r.jsx)(t.code,{children:"Node"}),", you can also refetch fragments that are on ",(0,r.jsx)(t.code,{children:"Viewer"})," (since the viewer is assumed to be stable throughout a session) and that are at the top level of a query (since there\u2019s no field above them that could change identity)."]}),(0,r.jsx)(i.FbInternalOnly,{children:(0,r.jsxs)(t.p,{children:["Meta only: Ents marked with [",(0,r.jsx)(t.code,{children:"GraphQLFetchable](https://fb.workplace.com/groups/graphql.fyi/permalink/1539541276187011/)"})," can also be refetched.]]"]})})]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(t.p,{children:"Refetchable fragments let us efficiently update specific parts of the UI in response to user input, while initializing them as part of the same query that we use for the entire screen."}),"\n",(0,r.jsx)(t.p,{children:"Relay's pagination features are built on refetchable fragments, too. We'll explore those next."})]})}function u(e={}){let{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},21388(e,t,n){n.d(t,{A:()=>a});let a=n.p+"assets/images/refetchable-contacts-initial-6f0b18fcbacc45a5673bbfd8a5a92a76.png"},45887(e,t,n){n.d(t,{A:()=>a});let a=n.p+"assets/images/refetchable-suspense-1-data-needed-05e9379009624a3afdac9e422da834e5.png"},11237(e,t,n){n.d(t,{A:()=>a});let a=n.p+"assets/images/refetchable-suspense-3-fallback-d274cf296d7605ea275d4564cf529adf.png"},31464(e,t,n){n.d(t,{A:()=>a});let a=n.p+"assets/images/refetchable-transition-search-b916c9e6ffbb26b6e64c9f1e19fd6fd3.png"},75305(e,t,n){n.d(t,{A:()=>a});let a=n.p+"assets/images/refetechable-suspense-2-nearest-suspense-point-be5a2c65ed3a31ad3d32e1fb26c8c0b0.png"},28453(e,t,n){n.d(t,{R:()=>i,x:()=>h});var a=n(96540);let r={},s=a.createContext(r);function i(e){let t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function h(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);