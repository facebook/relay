"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3589],{3905:(e,t,r)=>{r.r(t),r.d(t,{MDXContext:()=>u,MDXProvider:()=>d,mdx:()=>y,useMDXComponents:()=>c,withMDXComponents:()=>p});var a=r(67294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var a in r)Object.prototype.hasOwnProperty.call(r,a)&&(e[a]=r[a])}return e},o.apply(this,arguments)}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var u=a.createContext({}),p=function(e){return function(t){var r=c(t.components);return a.createElement(e,o({},t,{components:r}))}},c=function(e){var t=a.useContext(u),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},d=function(e){var t=c(e.components);return a.createElement(u.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},v=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(r),d=n,v=p["".concat(s,".").concat(d)]||p[d]||m[d]||o;return r?a.createElement(v,i(i({ref:t},u),{},{components:r})):a.createElement(v,i({ref:t},u))}));function y(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,s=new Array(o);s[0]=v;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:n,s[1]=i;for(var u=2;u<o;u++)s[u]=r[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}v.displayName="MDXCreateElement"},12679:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>u,toc:()=>c});var a=r(83117),n=r(80102),o=(r(67294),r(3905)),s=["components"],i={id:"limitations",title:"Limitations",slug:"/guides/relay-resolvers/limitations/",description:"Limitations of Relay Resolvers"},l=void 0,u={unversionedId:"guides/relay-resolvers/limitations",id:"version-v18.0.0/guides/relay-resolvers/limitations",title:"Limitations",description:"Limitations of Relay Resolvers",source:"@site/versioned_docs/version-v18.0.0/guides/relay-resolvers/limitations.md",sourceDirName:"guides/relay-resolvers",slug:"/guides/relay-resolvers/limitations/",permalink:"/docs/v18.0.0/guides/relay-resolvers/limitations/",draft:!1,editUrl:"https://github.com/facebook/relay/tree/main/website/versioned_docs/version-v18.0.0/guides/relay-resolvers/limitations.md",tags:[],version:"v18.0.0",frontMatter:{id:"limitations",title:"Limitations",slug:"/guides/relay-resolvers/limitations/",description:"Limitations of Relay Resolvers"},sidebar:"docs",previous:{title:"Deprecated",permalink:"/docs/v18.0.0/guides/relay-resolvers/deprecated/"},next:{title:"Client Schema Extensions",permalink:"/docs/v18.0.0/guides/client-schema-extensions/"}},p={},c=[{value:"No info argument",id:"no-info-argument",level:2},{value:"Not all GraphQL constructs are supported",id:"not-all-graphql-constructs-are-supported",level:2},{value:"No support for mutations",id:"no-support-for-mutations",level:2},{value:"Resolvers are always evaluated lazily",id:"resolvers-are-always-evaluated-lazily",level:2},{value:"Verbose/awkward docblock syntax",id:"verboseawkward-docblock-syntax",level:2}],d={toc:c};function m(e){var t=e.components,r=(0,n.Z)(e,s);return(0,o.mdx)("wrapper",(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"Relay Resolvers are do have some limitations. Here we will collect a list of known limitations and provide alternatives where possible."),(0,o.mdx)("h2",{id:"no-info-argument"},"No info argument"),(0,o.mdx)("p",null,"In a full GraphQL implementation, resolvers would have access to an ",(0,o.mdx)("inlineCode",{parentName:"p"},"info")," argument. This argument is not available in Relay Resolvers today."),(0,o.mdx)("h2",{id:"not-all-graphql-constructs-are-supported"},"Not all GraphQL constructs are supported"),(0,o.mdx)("p",null,"Today Relay Resolvers only support a subset of GraphQL constructs. For example, it's not currently possible to define input types, enums or interfaces using Relay Resolvers."),(0,o.mdx)("h2",{id:"no-support-for-mutations"},"No support for mutations"),(0,o.mdx)("p",null,"Today Relay Resolvers only support the read path. Defining mutation fields is not yet supported. We are working to understand what it means to perform a mutation against a reactive schema, and hope to support them in the future."),(0,o.mdx)("h2",{id:"resolvers-are-always-evaluated-lazily"},"Resolvers are always evaluated lazily"),(0,o.mdx)("p",null,"Today Relay Resolvers are always evaluated lazily on a per-fragment basis. This has the advantage that if a resolver is not read, it will never be evaluated. However, it can lead to issues with waterfalls if your client schema ends up making async requests to fetch data as its read. We are actively exploring other execution strategies for Relay Resolvers, such as evaluating all fields in a query at request time, but expect the way resolvers are defined to remain stable."),(0,o.mdx)("h2",{id:"verboseawkward-docblock-syntax"},"Verbose/awkward docblock syntax"),(0,o.mdx)("p",null,"Today defining a resolver requires defining a function with a docblock which uses special syntax and duplicates information already specified in the function's name and types. Further, in order to enforce that these values match up, Relay emits type assertions in its generated types. While these assertions do ensure safety, they are an awkward developer experience."),(0,o.mdx)("p",null,"To address these issues we are exploring a more streamlined approach where names and types can be inferred from your Flow or TypeScript code similar to the approach taken by ",(0,o.mdx)("a",{parentName:"p",href:"https://grats.capt.dev/"},"Grats"),". This syntax may become available in future versions of Relay."))}m.isMDXComponent=!0}}]);